-- Autogenerated from MM0

import .basic

namespace mm

-- constant wff : Type

-- constant wff.proof : wff → Prop
-- prefix `⊦ `:26 := wff.proof
-- constant wff.forget {p : Prop} : (wff → p) → p

-- /-- If ` ph ` is a wff, so is ` -. ph ` or "not ` ph ` ". Part of the recursive definition of a
-- wff (well-formed formula). In classical logic (which is our logic), a wff is interpreted as
-- either true or false. So if ` ph ` is true, then ` -. ph ` is false; if ` ph ` is false, then `
-- -. ph ` is true. Traditionally, Greek letters are used to represent wffs, and we follow this
-- convention. In propositional calculus, we define only wffs built up from other wffs, i.e. there
-- is no starting or "atomic" wff. Later, in predicate calculus, we will extend the basic wff
-- definition by including atomic wffs ( ~ weq and ~ wel ). -/
-- constant wn : wff → wff


-- /-- If ` ph ` and ` ps ` are wff's, so is ` ( ph -> ps ) ` or " ` ph ` implies ` ps ` ". Part of
-- the recursive definition of a wff. The resulting wff is (interpreted as) false when ` ph ` is
-- true and ` ps ` is false; it is true otherwise. Think of the truth table for an OR gate with
-- input ` ph ` connected through an inverter. After we state the axioms of propositional calculus (
-- ~ ax-1 , ~ ax-2 , ~ ax-3 , and ~ ax-mp ) and define the biconditional ( ~ df-bi ), the constant
-- true ` T. ` ( ~ df-tru ), and the constant false ` F. ` ( ~ df-fal ), we will be able to prove
-- these truth table values: ` ( ( T. -> T. ) <-> T. ) ` ( ~ truimtru ), ` ( ( T. -> F. ) <-> F. ) `
-- ( ~ truimfal ), ` ( ( F. -> T. ) <-> T. ) ` ( ~ falimtru ), and ` ( ( F. -> F. ) <-> T. ) ` ( ~
-- falimfal ). These have straightforward meanings, for example, ` ( ( T. -> T. ) <-> T. ) ` just
-- means "the value of ` ( T. -> T. ) ` is ` T. ` ". The left-hand wff is called the antecedent, and
-- the right-hand wff is called the consequent. In the case of ` ( ph -> ( ps -> ch ) ) ` , the
-- middle ` ps ` may be informally called either an antecedent or part of the consequent depending
-- on context. Contrast with ` <-> ` ( ~ df-bi ), ` /\ ` ( ~ df-an ), and ` \/ ` ( ~ df-or ). This
-- is called "material implication" and the arrow is usually read as "implies". However, material
-- implication is not identical to the meaning of "implies" in natural language. For example, the
-- word "implies" may suggest a causal relationship in natural language. Material implication does
-- not require any causal relationship. Also, note that in material implication, if the consequent
-- is true then the wff is always true (even if the antecedent is false). Thus, if "implies" means
-- material implication, it is true that "if the moon is made of green cheese that implies that 5=5"
-- (because 5=5). Similarly, if the antecedent is false, the wff is always true. Thus, it is true
-- that, "if the moon is made of green cheese that implies that 5=7" (because the moon is not
-- actually made of green cheese). A contradiction implies anything ( ~ pm2.21i ). In short,
-- material implication has a very specific technical definition, and misunderstandings of it are
-- sometimes called "paradoxes of logical implication". -/
-- constant wi : wff → wff → wff


-- /-- Rule of Modus Ponens. The postulated inference rule of propositional calculus. See, e.g.,
-- Rule 1 of [Hamilton] p. 73. The rule says, "if ` ph ` is true, and ` ph ` implies ` ps ` , then `
-- ps ` must also be true". This rule is sometimes called "detachment", since it detaches the minor
-- premise from the major premise. "Modus ponens" is short for "modus ponendo ponens", a Latin
-- phrase that means "the mode that by affirming affirms" - remark in [Sanford] p. 39. This rule is
-- similar to the rule of modus tollens ~ mto . Note: In some web page displays such as the
-- Statement List, the symbols " ` & ` " and " ` => ` " informally indicate the relationship between
-- the hypotheses and the assertion (conclusion), abbreviating the English words "and" and
-- "implies". They are not part of the formal language. (Contributed by NM, 30-Sep-1992.) -/
-- axiom ax_mp {ph ps : wff} : ⊦ ph → ⊦ wi ph ps → ⊦ ps


-- /-- Axiom _Simp_. Axiom A1 of [Margaris] p. 49. One of the 3 axioms of propositional calculus.
-- The 3 axioms are also given as Definition 2.1 of [Hamilton] p. 28. This axiom is called _Simp_ or
-- "the principle of simplification" in _Principia Mathematica_ (Theorem *2.02 of [WhiteheadRussell]
-- p. 100) because "it enables us to pass from the joint assertion of ` ph ` and ` ps ` to the
-- assertion of ` ph ` simply". It is Proposition 1 of [Frege1879] p. 26, its first axiom.
-- (Contributed by NM, 30-Sep-1992.) -/
-- axiom ax_1 {ph ps : wff} : ⊦ wi ph (wi ps ph)


-- /-- Axiom _Frege_. Axiom A2 of [Margaris] p. 49. One of the 3 axioms of propositional calculus.
-- It "distributes" an antecedent over two consequents. This axiom was part of Frege's original
-- system and is known as _Frege_ in the literature; see Proposition 2 of [Frege1879] p. 26. It is
-- also proved as Theorem *2.77 of [WhiteheadRussell] p. 108. The other direction of this axiom also
-- turns out to be true, as demonstrated by ~ pm5.41 . (Contributed by NM, 30-Sep-1992.) -/
-- axiom ax_2 {ph ps ch : wff} : ⊦ wi (wi ph (wi ps ch)) (wi (wi ph ps) (wi ph ch))


-- /-- Axiom _Transp_. Axiom A3 of [Margaris] p. 49. One of the 3 axioms of propositional calculus.
-- It swaps or "transposes" the order of the consequents when negation is removed. An informal
-- example is that the statement "if there are no clouds in the sky, it is not raining" implies the
-- statement "if it is raining, there are clouds in the sky". This axiom is called _Transp_ or "the
-- principle of transposition" in _Principia Mathematica_ (Theorem *2.17 of [WhiteheadRussell] p.
-- 103). We will also use the term "contraposition" for this principle, although the reader is
-- advised that in the field of philosophical logic, "contraposition" has a different technical
-- meaning. (Contributed by NM, 30-Sep-1992.) Use its alias ~ con4 instead. (New usage is
-- discouraged.) -/
-- axiom ax_3 {ph ps : wff} : ⊦ wi (wi (wn ph) (wn ps)) (wi ps ph)


/-- A double modus ponens inference. (Contributed by NM, 5-Apr-1994.) -/
theorem mp2 {ph ps ch : wff}
  (mp2_1 : ⊦ ph)
  (mp2_2 : ⊦ ps)
  (mp2_3 : ⊦ wi ph (wi ps ch)) :
  ⊦ ch :=
@ax_mp ps ch
  mp2_2
  (@ax_mp ph (wi ps ch)
    mp2_1
    mp2_3)


/-- A double modus ponens inference. (Contributed by Mario Carneiro, 24-Jan-2013.) -/
theorem mp2b {ph ps ch : wff}
  (mp2b_1 : ⊦ ph)
  (mp2b_2 : ⊦ wi ph ps)
  (mp2b_3 : ⊦ wi ps ch) :
  ⊦ ch :=
@ax_mp ps ch
  (@ax_mp ph ps
    mp2b_1
    mp2b_2)
  mp2b_3


/-- Inference introducing an antecedent. Inference associated with ~ ax-1 . Its associated inference
is ~ a1ii . See ~ conventions for a definition of "associated inference". (Contributed by NM,
29-Dec-1992.) -/
theorem a1i {ph ps : wff}
  (a1i_1 : ⊦ ph) :
  ⊦ wi ps ph :=
@ax_mp ph (wi ps ph)
  a1i_1
  (@ax_1 ph ps)


/-- Inference introducing two antecedents. Two applications of ~ a1i . Inference associated with ~
2a1 . (Contributed by Jeff Hankins, 4-Aug-2009.) -/
theorem «2a1i» {ph ps ch : wff}
  («2a1i_1» : ⊦ ph) :
  ⊦ wi ps (wi ch ph) :=
@a1i (wi ch ph) ps
  (@a1i ph ch
    «2a1i_1»)


/-- Inference detaching an antecedent and introducing a new one. (Contributed by Stefan O'Rear,
29-Jan-2015.) -/
theorem mp1i {ph ps ch : wff}
  (mp1i_1 : ⊦ ph)
  (mp1i_2 : ⊦ wi ph ps) :
  ⊦ wi ch ps :=
@a1i ps ch
  (@ax_mp ph ps
    mp1i_1
    mp1i_2)


/-- Inference distributing an antecedent. Inference associated with ~ ax-2 . Its associated
inference is ~ mpd . (Contributed by NM, 29-Dec-1992.) -/
theorem a2i {ph ps ch : wff}
  (a2i_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wi ph ps) (wi ph ch) :=
@ax_mp (wi ph (wi ps ch)) (wi (wi ph ps) (wi ph ch))
  a2i_1
  (@ax_2 ph ps ch)


/-- A modus ponens deduction. A translation of natural deduction rule ` -> ` E ( ` -> `
elimination), see ~ natded . Deduction form of ~ ax-mp . Inference associated with ~ a2i . Commuted
form of ~ mpcom . (Contributed by NM, 29-Dec-1992.) -/
theorem mpd {ph ps ch : wff}
  (mpd_1 : ⊦ wi ph ps)
  (mpd_2 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph ch :=
@ax_mp (wi ph ps) (wi ph ch)
  mpd_1
  (@a2i ph ps ch
    mpd_2)


/-- Inference adding common antecedents in an implication. Inference associated with ~ imim2 . Its
associated inference is ~ syl . (Contributed by NM, 28-Dec-1992.) -/
theorem imim2i {ph ps ch : wff}
  (imim2i_1 : ⊦ wi ph ps) :
  ⊦ wi (wi ch ph) (wi ch ps) :=
@a2i ch ph ps
  (@a1i (wi ph ps) ch
    imim2i_1)


/-- An inference version of the transitive laws for implication ~ imim2 and ~ imim1 (and ~ imim1i
and ~ imim2i ), which Russell and Whitehead call "the principle of the syllogism ... because ... the
syllogism in Barbara is derived from [[ ~ syl ]" (quote after Theorem *2.06 of [WhiteheadRussell] p.
101). Some authors call this law a "hypothetical syllogism". Its associated inference is ~ mp2b . (A
bit of trivia: this is the most commonly referenced assertion in our database (13449 times as of
22-Jul-2021). In second place is ~ eqid (9597 times), followed by ~ adantr (8861 times), ~ syl2anc
(7421 times), ~ adantl (6403 times), and ~ simpr (5829 times). The Metamath program command 'show
usage' shows the number of references.) (Contributed by NM, 30-Sep-1992.) (Proof shortened by Mel L.
O'Cat, 20-Oct-2011.) (Proof shortened by Wolf Lammen, 26-Jul-2012.) -/
theorem syl {ph ps ch : wff}
  (syl_1 : ⊦ wi ph ps)
  (syl_2 : ⊦ wi ps ch) :
  ⊦ wi ph ch :=
@mpd ph ps ch
  syl_1
  (@a1i (wi ps ch) ph
    syl_2)


/-- Inference chaining two syllogisms ~ syl . Inference associated with ~ imim12i . (Contributed by
NM, 28-Dec-1992.) -/
theorem «3syl» {ph ps ch th : wff}
  («3syl_1» : ⊦ wi ph ps)
  («3syl_2» : ⊦ wi ps ch)
  («3syl_3» : ⊦ wi ch th) :
  ⊦ wi ph th :=
@syl ph ch th
  (@syl ph ps ch
    «3syl_1»
    «3syl_2»)
  «3syl_3»


/-- Inference chaining three syllogisms ~ syl . (Contributed by BJ, 14-Jul-2018.) The use of this
theorem is marked "discouraged" because it can cause the Metamath program "MM-PA> MINIMIZE__WITH *"
command to have very long run times. However, feel free to use "MM-PA> MINIMIZE__WITH 4syl /
OVERRIDE" if you wish. Remember to update the "discouraged" file if it gets used. (New usage is
discouraged.) -/
theorem «4syl» {ph ps ch th ta : wff}
  («4syl_1» : ⊦ wi ph ps)
  («4syl_2» : ⊦ wi ps ch)
  («4syl_3» : ⊦ wi ch th)
  («4syl_4» : ⊦ wi th ta) :
  ⊦ wi ph ta :=
@syl ph th ta
  (@«3syl» ph ps ch th
    «4syl_1»
    «4syl_2»
    «4syl_3»)
  «4syl_4»


/-- A nested modus ponens inference. Inference associated with ~ com12 . (Contributed by NM,
29-Dec-1992.) (Proof shortened by Stefan Allan, 20-Mar-2006.) -/
theorem mpi {ph ps ch : wff}
  (mpi_1 : ⊦ ps)
  (mpi_2 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph ch :=
@mpd ph ps ch
  (@a1i ps ph
    mpi_1)
  mpi_2


/-- A syllogism combined with a modus ponens inference. (Contributed by Alan Sare, 25-Jul-2011.) -/
theorem mpisyl {ph ps ch th : wff}
  (mpisyl_1 : ⊦ wi ph ps)
  (mpisyl_2 : ⊦ ch)
  (mpisyl_3 : ⊦ wi ps (wi ch th)) :
  ⊦ wi ph th :=
@syl ph ps th
  mpisyl_1
  (@mpi ps ch th
    mpisyl_2
    mpisyl_3)


/-- Principle of identity. Theorem *2.08 of [WhiteheadRussell] p. 101. For another version of the
proof directly from axioms, see ~ idALT . Its associated inference, ~ idi , requires no axioms for
its proof, contrary to ~ id . Note that the second occurrences of ` ph ` in Steps 1 and 2 may be
simultaneously replaced by any wff ` ps ` , which may ease the understanding of the proof.
(Contributed by NM, 29-Dec-1992.) (Proof shortened by Stefan Allan, 20-Mar-2006.) -/
theorem id {ph : wff} :
  ⊦ wi ph ph :=
@mpd ph (wi ph ph) ph
  (@ax_1 ph ph)
  (@ax_1 ph (wi ph ph))


/-- Principle of identity ~ id with antecedent. (Contributed by NM, 26-Nov-1995.) -/
theorem idd {ph ps : wff} :
  ⊦ wi ph (wi ps ps) :=
@a1i (wi ps ps) ph
  (@id ps)


/-- Deduction introducing an embedded antecedent. Deduction form of ~ ax-1 and ~ a1i . (Contributed
by NM, 5-Jan-1993.) (Proof shortened by Stefan Allan, 20-Mar-2006.) -/
theorem a1d {ph ps ch : wff}
  (a1d_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wi ch ps) :=
@syl ph ps (wi ch ps)
  a1d_1
  (@ax_1 ps ch)


/-- Deduction introducing two antecedents. Two applications of ~ a1d . Deduction associated with ~
2a1 and ~ 2a1i . (Contributed by BJ, 10-Aug-2020.) -/
theorem «2a1d» {ph ps ch th : wff}
  («2a1d_1» : ⊦ wi ph ps) :
  ⊦ wi ph (wi ch (wi th ps)) :=
@a1d ph (wi th ps) ch
  (@a1d ph ps th
    «2a1d_1»)


/-- Add two antecedents to a wff. (Contributed by Jeff Hankins, 4-Aug-2009.) -/
theorem a1i13 {ph ps ch th : wff}
  (a1i13_1 : ⊦ wi ps th) :
  ⊦ wi ph (wi ps (wi ch th)) :=
@a1i (wi ps (wi ch th)) ph
  (@a1d ps th ch
    a1i13_1)


/-- Deduction distributing an embedded antecedent. Deduction form of ~ ax-2 . (Contributed by NM,
23-Jun-1994.) -/
theorem a2d {ph ps ch th : wff}
  (a2d_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi (wi ps ch) (wi ps th)) :=
@syl ph (wi ps (wi ch th)) (wi (wi ps ch) (wi ps th))
  a2d_1
  (@ax_2 ps ch th)


/-- Syllogism inference with commutation of antecedents. (Contributed by NM, 29-Aug-2004.) (Proof
shortened by Mel L. O'Cat, 2-Feb-2006.) (Proof shortened by Stefan Allan, 23-Feb-2006.) -/
theorem sylcom {ph ps ch th : wff}
  (sylcom_1 : ⊦ wi ph (wi ps ch))
  (sylcom_2 : ⊦ wi ps (wi ch th)) :
  ⊦ wi ph (wi ps th) :=
@syl ph (wi ps ch) (wi ps th)
  sylcom_1
  (@a2i ps ch th
    sylcom_2)


/-- Syllogism inference with commuted antecedents. (Contributed by NM, 24-May-2005.) -/
theorem syl5com {ph ps ch th : wff}
  (syl5com_1 : ⊦ wi ph ps)
  (syl5com_2 : ⊦ wi ch (wi ps th)) :
  ⊦ wi ph (wi ch th) :=
@sylcom ph ch ps th
  (@a1d ph ps ch
    syl5com_1)
  syl5com_2


/-- Inference that swaps (commutes) antecedents in an implication. Inference associated with ~
pm2.04 . Its associated inference is ~ mpi . (Contributed by NM, 29-Dec-1992.) (Proof shortened by
Wolf Lammen, 4-Aug-2012.) -/
theorem com12 {ph ps ch : wff}
  (com12_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ps (wi ph ch) :=
@syl5com ps ps ph ch
  (@id ps)
  com12_1


/-- A syllogism inference. Commuted form of an instance of ~ syl . (Contributed by BJ, 25-Oct-2021.)
-/
theorem syl11 {ph ps ch th : wff}
  (syl11_1 : ⊦ wi ph (wi ps ch))
  (syl11_2 : ⊦ wi th ph) :
  ⊦ wi ps (wi th ch) :=
@com12 th ps ch
  (@syl th ph (wi ps ch)
    syl11_2
    syl11_1)


/-- A syllogism rule of inference. The first premise is used to replace the second antecedent of the
second premise. (Contributed by NM, 27-Dec-1992.) (Proof shortened by Wolf Lammen, 25-May-2013.) -/
theorem syl5 {ph ps ch th : wff}
  (syl5_1 : ⊦ wi ph ps)
  (syl5_2 : ⊦ wi ch (wi ps th)) :
  ⊦ wi ch (wi ph th) :=
@com12 ph ch th
  (@syl5com ph ps ch th
    syl5_1
    syl5_2)


/-- A syllogism rule of inference. The second premise is used to replace the consequent of the first
premise. (Contributed by NM, 5-Jan-1993.) (Proof shortened by Wolf Lammen, 30-Jul-2012.) -/
theorem syl6 {ph ps ch th : wff}
  (syl6_1 : ⊦ wi ph (wi ps ch))
  (syl6_2 : ⊦ wi ch th) :
  ⊦ wi ph (wi ps th) :=
@sylcom ph ps ch th
  syl6_1
  (@a1i (wi ch th) ps
    syl6_2)


/-- Combine ~ syl5 and ~ syl6 . (Contributed by NM, 14-Nov-2013.) -/
theorem syl56 {ph ps ch th ta : wff}
  (syl56_1 : ⊦ wi ph ps)
  (syl56_2 : ⊦ wi ch (wi ps th))
  (syl56_3 : ⊦ wi th ta) :
  ⊦ wi ch (wi ph ta) :=
@syl5 ph ps ch ta
  syl56_1
  (@syl6 ch ps th ta
    syl56_2
    syl56_3)


/-- Syllogism inference with commuted antecedents. (Contributed by NM, 25-May-2005.) -/
theorem syl6com {ph ps ch th : wff}
  (syl6com_1 : ⊦ wi ph (wi ps ch))
  (syl6com_2 : ⊦ wi ch th) :
  ⊦ wi ps (wi ph th) :=
@com12 ph ps th
  (@syl6 ph ps ch th
    syl6com_1
    syl6com_2)


/-- Modus ponens inference with commutation of antecedents. Commuted form of ~ mpd . (Contributed by
NM, 17-Mar-1996.) -/
theorem mpcom {ph ps ch : wff}
  (mpcom_1 : ⊦ wi ps ph)
  (mpcom_2 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ps ch :=
@mpd ps ph ch
  mpcom_1
  (@com12 ph ps ch
    mpcom_2)


/-- Syllogism inference with common nested antecedent. (Contributed by NM, 4-Nov-2004.) -/
theorem syli {ph ps ch th : wff}
  (syli_1 : ⊦ wi ps (wi ph ch))
  (syli_2 : ⊦ wi ch (wi ph th)) :
  ⊦ wi ps (wi ph th) :=
@sylcom ps ph ch th
  syli_1
  (@com12 ch ph th
    syli_2)


/-- Replace two antecedents. Implication-only version of ~ syl2an . (Contributed by Wolf Lammen,
14-May-2013.) -/
theorem syl2im {ph ps ch th ta : wff}
  (syl2im_1 : ⊦ wi ph ps)
  (syl2im_2 : ⊦ wi ch th)
  (syl2im_3 : ⊦ wi ps (wi th ta)) :
  ⊦ wi ph (wi ch ta) :=
@syl ph ps (wi ch ta)
  syl2im_1
  (@syl5 ch th ps ta
    syl2im_2
    syl2im_3)


/-- A commuted version of ~ syl2im . Implication-only version of ~ syl2anr . (Contributed by BJ,
20-Oct-2021.) -/
theorem syl2imc {ph ps ch th ta : wff}
  (syl2im_1 : ⊦ wi ph ps)
  (syl2im_2 : ⊦ wi ch th)
  (syl2im_3 : ⊦ wi ps (wi th ta)) :
  ⊦ wi ch (wi ph ta) :=
@com12 ph ch ta
  (@syl2im ph ps ch th ta
    syl2im_1
    syl2im_2
    syl2im_3)


/-- This theorem, sometimes called "Assertion" or "Pon" (for "ponens"), can be thought of as a
closed form of modus ponens ~ ax-mp . Theorem *2.27 of [WhiteheadRussell] p. 104. (Contributed by
NM, 15-Jul-1993.) -/
theorem pm2_27 {ph ps : wff} :
  ⊦ wi ph (wi (wi ph ps) ps) :=
@com12 (wi ph ps) ph ps
  (@id (wi ph ps))


/-- A nested modus ponens deduction. Double deduction associated with ~ ax-mp . Deduction associated
with ~ mpd . (Contributed by NM, 12-Dec-2004.) -/
theorem mpdd {ph ps ch th : wff}
  (mpdd_1 : ⊦ wi ph (wi ps ch))
  (mpdd_2 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi ps th) :=
@mpd ph (wi ps ch) (wi ps th)
  mpdd_1
  (@a2d ph ps ch th
    mpdd_2)


/-- A nested modus ponens deduction. Deduction associated with ~ mpi . (Contributed by NM,
14-Dec-2004.) -/
theorem mpid {ph ps ch th : wff}
  (mpid_1 : ⊦ wi ph ch)
  (mpid_2 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi ps th) :=
@mpdd ph ps ch th
  (@a1d ph ch ps
    mpid_1)
  mpid_2


/-- A nested modus ponens deduction. (Contributed by NM, 16-Apr-2005.) (Proof shortened by Mel L.
O'Cat, 15-Jan-2008.) -/
theorem mpdi {ph ps ch th : wff}
  (mpdi_1 : ⊦ wi ps ch)
  (mpdi_2 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi ps th) :=
@mpdd ph ps ch th
  (@a1i (wi ps ch) ph
    mpdi_1)
  mpdi_2


/-- A doubly nested modus ponens inference. (Contributed by NM, 31-Dec-1993.) (Proof shortened by
Wolf Lammen, 31-Jul-2012.) -/
theorem mpii {ph ps ch th : wff}
  (mpii_1 : ⊦ ch)
  (mpii_2 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi ps th) :=
@mpdi ph ps ch th
  (@a1i ch ps
    mpii_1)
  mpii_2


/-- Syllogism deduction. Deduction associated with ~ syl . See ~ conventions for the meaning of
"associated deduction" or "deduction form". (Contributed by NM, 5-Aug-1993.) (Proof shortened by Mel
L. O'Cat, 19-Feb-2008.) (Proof shortened by Wolf Lammen, 3-Aug-2012.) -/
theorem syld {ph ps ch th : wff}
  (syld_1 : ⊦ wi ph (wi ps ch))
  (syld_2 : ⊦ wi ph (wi ch th)) :
  ⊦ wi ph (wi ps th) :=
@mpdd ph ps ch th
  syld_1
  (@a1d ph (wi ch th) ps
    syld_2)


/-- Syllogism deduction. Commuted form of ~ syld . (Contributed by BJ, 25-Oct-2021.) -/
theorem syldc {ph ps ch th : wff}
  (syld_1 : ⊦ wi ph (wi ps ch))
  (syld_2 : ⊦ wi ph (wi ch th)) :
  ⊦ wi ps (wi ph th) :=
@com12 ph ps th
  (@syld ph ps ch th
    syld_1
    syld_2)


/-- A double modus ponens deduction. Deduction associated with ~ mp2 . (Contributed by NM,
23-May-2013.) (Proof shortened by Wolf Lammen, 23-Jul-2013.) -/
theorem mp2d {ph ps ch th : wff}
  (mp2d_1 : ⊦ wi ph ps)
  (mp2d_2 : ⊦ wi ph ch)
  (mp2d_3 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph th :=
@mpd ph ps th
  mp2d_1
  (@mpid ph ps ch th
    mp2d_2
    mp2d_3)


/-- Double deduction introducing an antecedent. Deduction associated with ~ a1d . Double deduction
associated with ~ ax-1 and ~ a1i . (Contributed by NM, 17-Dec-2004.) (Proof shortened by Mel L.
O'Cat, 15-Jan-2008.) -/
theorem a1dd {ph ps ch th : wff}
  (a1dd_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi ps (wi th ch)) :=
@syl6 ph ps ch (wi th ch)
  a1dd_1
  (@ax_1 ch th)


/-- Double deduction introducing two antecedents. Two applications of ~ 2a1dd . Deduction associated
with ~ 2a1d . Double deduction associated with ~ 2a1 and ~ 2a1i . (Contributed by Jeff Hankins,
5-Aug-2009.) -/
theorem «2a1dd» {ph ps ch th ta : wff}
  («2a1dd_1» : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi ps (wi th (wi ta ch))) :=
@a1dd ph ps (wi ta ch) th
  (@a1dd ph ps ch ta
    «2a1dd_1»)


/-- Inference absorbing redundant antecedent. Inference associated with ~ pm2.43 . (Contributed by
NM, 10-Jan-1993.) (Proof shortened by Mel L. O'Cat, 28-Nov-2008.) -/
theorem pm2_43i {ph ps : wff}
  (pm2_43i_1 : ⊦ wi ph (wi ph ps)) :
  ⊦ wi ph ps :=
@mpd ph ph ps
  (@id ph)
  pm2_43i_1


/-- Deduction absorbing redundant antecedent. Deduction associated with ~ pm2.43 and ~ pm2.43i .
(Contributed by NM, 18-Aug-1993.) (Proof shortened by Mel L. O'Cat, 28-Nov-2008.) -/
theorem pm2_43d {ph ps ch : wff}
  (pm2_43d_1 : ⊦ wi ph (wi ps (wi ps ch))) :
  ⊦ wi ph (wi ps ch) :=
@mpdi ph ps ps ch
  (@id ps)
  pm2_43d_1


/-- Inference absorbing redundant antecedent. (Contributed by NM, 7-Nov-1995.) (Proof shortened by
Mel L. O'Cat, 28-Nov-2008.) -/
theorem pm2_43a {ph ps ch : wff}
  (pm2_43a_1 : ⊦ wi ps (wi ph (wi ps ch))) :
  ⊦ wi ps (wi ph ch) :=
@mpid ps ph ps ch
  (@id ps)
  pm2_43a_1


/-- Inference absorbing redundant antecedent. (Contributed by NM, 31-Oct-1995.) -/
theorem pm2_43b {ph ps ch : wff}
  (pm2_43b_1 : ⊦ wi ps (wi ph (wi ps ch))) :
  ⊦ wi ph (wi ps ch) :=
@com12 ps ph ch
  (@pm2_43a ph ps ch
    pm2_43b_1)


/-- Deduction adding nested antecedents. Deduction associated with ~ imim2 and ~ imim2i .
(Contributed by NM, 10-Jan-1993.) -/
theorem imim2d {ph ps ch th : wff}
  (imim2d_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wi th ps) (wi th ch)) :=
@a2d ph th ps ch
  (@a1d ph (wi ps ch) th
    imim2d_1)


/-- A closed form of syllogism (see ~ syl ). Theorem *2.05 of [WhiteheadRussell] p. 100. Its
associated inference is ~ imim2i . Its associated deduction is ~ imim2d . An alternate proof from
more basic results is given by ~ ax-1 followed by ~ a2d . (Contributed by NM, 29-Dec-1992.) (Proof
shortened by Wolf Lammen, 6-Sep-2012.) -/
theorem imim2 {ph ps ch : wff} :
  ⊦ wi (wi ph ps) (wi (wi ch ph) (wi ch ps)) :=
@imim2d (wi ph ps) ph ps ch
  (@id (wi ph ps))


/-- Deduction embedding an antecedent. (Contributed by Wolf Lammen, 4-Oct-2013.) -/
theorem embantd {ph ps ch th : wff}
  (embantd_1 : ⊦ wi ph ps)
  (embantd_2 : ⊦ wi ph (wi ch th)) :
  ⊦ wi ph (wi (wi ps ch) th) :=
@mpid ph (wi ps ch) ps th
  embantd_1
  (@imim2d ph ch th ps
    embantd_2)


/-- Triple syllogism deduction. Deduction associated with ~ 3syld . (Contributed by Jeff Hankins,
4-Aug-2009.) -/
theorem «3syld» {ph ps ch th ta : wff}
  («3syld_1» : ⊦ wi ph (wi ps ch))
  («3syld_2» : ⊦ wi ph (wi ch th))
  («3syld_3» : ⊦ wi ph (wi th ta)) :
  ⊦ wi ph (wi ps ta) :=
@syld ph ps th ta
  (@syld ph ps ch th
    «3syld_1»
    «3syld_2»)
  «3syld_3»


/-- A double syllogism inference. (Contributed by Alan Sare, 20-Apr-2011.) -/
theorem sylsyld {ph ps ch th ta : wff}
  (sylsyld_1 : ⊦ wi ph ps)
  (sylsyld_2 : ⊦ wi ph (wi ch th))
  (sylsyld_3 : ⊦ wi ps (wi th ta)) :
  ⊦ wi ph (wi ch ta) :=
@syld ph ch th ta
  sylsyld_2
  (@syl ph ps (wi th ta)
    sylsyld_1
    sylsyld_3)


/-- Inference joining two implications. Inference associated with ~ imim12 . Its associated
inference is ~ 3syl . (Contributed by NM, 12-Mar-1993.) (Proof shortened by Mel L. O'Cat,
29-Oct-2011.) -/
theorem imim12i {ph ps ch th : wff}
  (imim12i_1 : ⊦ wi ph ps)
  (imim12i_2 : ⊦ wi ch th) :
  ⊦ wi (wi ps ch) (wi ph th) :=
@syl5 ph ps (wi ps ch) th
  imim12i_1
  (@imim2i ch th ps
    imim12i_2)


/-- Inference adding common consequents in an implication, thereby interchanging the original
antecedent and consequent. Inference associated with ~ imim1 . Its associated inference is ~ syl .
(Contributed by NM, 28-Dec-1992.) (Proof shortened by Wolf Lammen, 4-Aug-2012.) -/
theorem imim1i {ph ps ch : wff}
  (imim1i_1 : ⊦ wi ph ps) :
  ⊦ wi (wi ps ch) (wi ph ch) :=
@imim12i ph ps ch ch
  imim1i_1
  (@id ch)


/-- Inference adding three nested antecedents. (Contributed by NM, 19-Dec-2006.) -/
theorem imim3i {ph ps ch th : wff}
  (imim3i_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wi th ph) (wi (wi th ps) (wi th ch)) :=
@a2d (wi th ph) th ps ch
  (@imim2i ph (wi ps ch) th
    imim3i_1)


/-- A syllogism inference combined with contraction. (Contributed by NM, 4-May-1994.) (Revised by
NM, 13-Jul-2013.) -/
theorem sylc {ph ps ch th : wff}
  (sylc_1 : ⊦ wi ph ps)
  (sylc_2 : ⊦ wi ph ch)
  (sylc_3 : ⊦ wi ps (wi ch th)) :
  ⊦ wi ph th :=
@pm2_43i ph th
  (@syl2im ph ps ph ch th
    sylc_1
    sylc_2
    sylc_3)


/-- A syllogism inference combined with contraction. (Contributed by Alan Sare, 7-Jul-2011.) -/
theorem syl3c {ph ps ch th ta : wff}
  (syl3c_1 : ⊦ wi ph ps)
  (syl3c_2 : ⊦ wi ph ch)
  (syl3c_3 : ⊦ wi ph th)
  (syl3c_4 : ⊦ wi ps (wi ch (wi th ta))) :
  ⊦ wi ph ta :=
@mpd ph th ta
  syl3c_3
  (@sylc ph ps ch (wi th ta)
    syl3c_1
    syl3c_2
    syl3c_4)


/-- A syllogism inference. (Contributed by Alan Sare, 8-Jul-2011.) (Proof shortened by Wolf Lammen,
13-Sep-2012.) -/
theorem syl6mpi {ph ps ch th ta : wff}
  (syl6mpi_1 : ⊦ wi ph (wi ps ch))
  (syl6mpi_2 : ⊦ th)
  (syl6mpi_3 : ⊦ wi ch (wi th ta)) :
  ⊦ wi ph (wi ps ta) :=
@syl6 ph ps ch ta
  syl6mpi_1
  (@mpi ch th ta
    syl6mpi_2
    syl6mpi_3)


/-- Modus ponens combined with a syllogism inference. (Contributed by Alan Sare, 20-Apr-2011.) -/
theorem mpsyl {ph ps ch th : wff}
  (mpsyl_1 : ⊦ ph)
  (mpsyl_2 : ⊦ wi ps ch)
  (mpsyl_3 : ⊦ wi ph (wi ch th)) :
  ⊦ wi ps th :=
@sylc ps ph ch th
  (@a1i ph ps
    mpsyl_1)
  mpsyl_2
  mpsyl_3


/-- Modus ponens combined with a double syllogism inference. (Contributed by Alan Sare,
22-Jul-2012.) -/
theorem mpsylsyld {ph ps ch th ta : wff}
  (mpsylsyld_1 : ⊦ ph)
  (mpsylsyld_2 : ⊦ wi ps (wi ch th))
  (mpsylsyld_3 : ⊦ wi ph (wi th ta)) :
  ⊦ wi ps (wi ch ta) :=
@sylsyld ps ph ch th ta
  (@a1i ph ps
    mpsylsyld_1)
  mpsylsyld_2
  mpsylsyld_3


/-- Inference combining ~ syl6 with contraction. (Contributed by Alan Sare, 2-May-2011.) -/
theorem syl6c {ph ps ch th ta : wff}
  (syl6c_1 : ⊦ wi ph (wi ps ch))
  (syl6c_2 : ⊦ wi ph (wi ps th))
  (syl6c_3 : ⊦ wi ch (wi th ta)) :
  ⊦ wi ph (wi ps ta) :=
@mpdd ph ps th ta
  syl6c_2
  (@syl6 ph ps ch (wi th ta)
    syl6c_1
    syl6c_3)


/-- A syllogism inference combined with contraction. (Contributed by Alan Sare, 18-Mar-2012.) -/
theorem syl6ci {ph ps ch th ta : wff}
  (syl6ci_1 : ⊦ wi ph (wi ps ch))
  (syl6ci_2 : ⊦ wi ph th)
  (syl6ci_3 : ⊦ wi ch (wi th ta)) :
  ⊦ wi ph (wi ps ta) :=
@syl6c ph ps ch th ta
  syl6ci_1
  (@a1d ph th ps
    syl6ci_2)
  syl6ci_3


/-- Nested syllogism deduction. Deduction associated with ~ syld . Double deduction associated with
~ syl . (Contributed by NM, 12-Dec-2004.) (Proof shortened by Wolf Lammen, 11-May-2013.) -/
theorem syldd {ph ps ch th ta : wff}
  (syldd_1 : ⊦ wi ph (wi ps (wi ch th)))
  (syldd_2 : ⊦ wi ph (wi ps (wi th ta))) :
  ⊦ wi ph (wi ps (wi ch ta)) :=
@syl6c ph ps (wi th ta) (wi ch th) (wi ch ta)
  syldd_2
  syldd_1
  (@imim2 th ta ch)


/-- A nested syllogism deduction. Deduction associated with ~ syl5 . (Contributed by NM,
14-May-1993.) (Proof shortened by Josh Purinton, 29-Dec-2000.) (Proof shortened by Mel L. O'Cat,
2-Feb-2006.) -/
theorem syl5d {ph ps ch th ta : wff}
  (syl5d_1 : ⊦ wi ph (wi ps ch))
  (syl5d_2 : ⊦ wi ph (wi th (wi ch ta))) :
  ⊦ wi ph (wi th (wi ps ta)) :=
@syldd ph th ps ch ta
  (@a1d ph (wi ps ch) th
    syl5d_1)
  syl5d_2


/-- A syllogism rule of inference. The first premise is used to replace the third antecedent of the
second premise. (Contributed by NM, 12-Jan-1993.) (Proof shortened by Wolf Lammen, 3-Aug-2012.) -/
theorem syl7 {ph ps ch th ta : wff}
  (syl7_1 : ⊦ wi ph ps)
  (syl7_2 : ⊦ wi ch (wi th (wi ps ta))) :
  ⊦ wi ch (wi th (wi ph ta)) :=
@syl5d ch ph ps th ta
  (@a1i (wi ph ps) ch
    syl7_1)
  syl7_2


/-- A nested syllogism deduction. Deduction associated with ~ syl6 . (Contributed by NM,
11-May-1993.) (Proof shortened by Josh Purinton, 29-Dec-2000.) (Proof shortened by Mel L. O'Cat,
2-Feb-2006.) -/
theorem syl6d {ph ps ch th ta : wff}
  (syl6d_1 : ⊦ wi ph (wi ps (wi ch th)))
  (syl6d_2 : ⊦ wi ph (wi th ta)) :
  ⊦ wi ph (wi ps (wi ch ta)) :=
@syldd ph ps ch th ta
  syl6d_1
  (@a1d ph (wi th ta) ps
    syl6d_2)


/-- A syllogism rule of inference. The second premise is used to replace the consequent of the first
premise. (Contributed by NM, 1-Aug-1994.) (Proof shortened by Wolf Lammen, 3-Aug-2012.) -/
theorem syl8 {ph ps ch th ta : wff}
  (syl8_1 : ⊦ wi ph (wi ps (wi ch th)))
  (syl8_2 : ⊦ wi th ta) :
  ⊦ wi ph (wi ps (wi ch ta)) :=
@syl6d ph ps ch th ta
  syl8_1
  (@a1i (wi th ta) ph
    syl8_2)


/-- A nested syllogism inference with different antecedents. (Contributed by NM, 13-May-1993.)
(Proof shortened by Josh Purinton, 29-Dec-2000.) -/
theorem syl9 {ph ps ch th ta : wff}
  (syl9_1 : ⊦ wi ph (wi ps ch))
  (syl9_2 : ⊦ wi th (wi ch ta)) :
  ⊦ wi ph (wi th (wi ps ta)) :=
@syl5d ph ps ch th ta
  syl9_1
  (@a1i (wi th (wi ch ta)) ph
    syl9_2)


/-- A nested syllogism inference with different antecedents. (Contributed by NM, 14-May-1993.) -/
theorem syl9r {ph ps ch th ta : wff}
  (syl9r_1 : ⊦ wi ph (wi ps ch))
  (syl9r_2 : ⊦ wi th (wi ch ta)) :
  ⊦ wi th (wi ph (wi ps ta)) :=
@com12 ph th (wi ps ta)
  (@syl9 ph ps ch th ta
    syl9r_1
    syl9r_2)


/-- A nested syllogism inference. (Contributed by Alan Sare, 17-Jul-2011.) -/
theorem syl10 {ph ps ch th ta et : wff}
  (syl10_1 : ⊦ wi ph (wi ps ch))
  (syl10_2 : ⊦ wi ph (wi ps (wi th ta)))
  (syl10_3 : ⊦ wi ch (wi ta et)) :
  ⊦ wi ph (wi ps (wi th et)) :=
@syldd ph ps th ta et
  syl10_2
  (@syl6 ph ps ch (wi ta et)
    syl10_1
    syl10_3)


/-- Triple deduction introducing an antecedent to a wff. Deduction associated with ~ a1dd . Double
deduction associated with ~ a1d . Triple deduction associated with ~ ax-1 and ~ a1i . (Contributed
by Jeff Hankins, 4-Aug-2009.) -/
theorem a1ddd {ph ps ch th ta : wff}
  (a1ddd_1 : ⊦ wi ph (wi ps (wi ch ta))) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@syl8 ph ps ch ta (wi th ta)
  a1ddd_1
  (@ax_1 ta th)


/-- Deduction combining antecedents and consequents. Deduction associated with ~ imim12 and ~
imim12i . (Contributed by NM, 7-Aug-1994.) (Proof shortened by Mel L. O'Cat, 30-Oct-2011.) -/
theorem imim12d {ph ps ch th ta : wff}
  (imim12d_1 : ⊦ wi ph (wi ps ch))
  (imim12d_2 : ⊦ wi ph (wi th ta)) :
  ⊦ wi ph (wi (wi ch th) (wi ps ta)) :=
@syl5d ph ps ch (wi ch th) ta
  imim12d_1
  (@imim2d ph th ta ch
    imim12d_2)


/-- Deduction adding nested consequents. Deduction associated with ~ imim1 and ~ imim1i .
(Contributed by NM, 3-Apr-1994.) (Proof shortened by Wolf Lammen, 12-Sep-2012.) -/
theorem imim1d {ph ps ch th : wff}
  (imim1d_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wi ch th) (wi ps th)) :=
@imim12d ph ps ch th th
  imim1d_1
  (@idd ph th)


/-- A closed form of syllogism (see ~ syl ). Theorem *2.06 of [WhiteheadRussell] p. 100. Its
associated inference is ~ imim1i . (Contributed by NM, 29-Dec-1992.) (Proof shortened by Wolf
Lammen, 25-May-2013.) -/
theorem imim1 {ph ps ch : wff} :
  ⊦ wi (wi ph ps) (wi (wi ps ch) (wi ph ch)) :=
@imim1d (wi ph ps) ph ps ch
  (@id (wi ph ps))


/-- Commutation of antecedents. Swap 2nd and 3rd. Deduction associated with ~ com12 . (Contributed
by NM, 27-Dec-1992.) (Proof shortened by Wolf Lammen, 4-Aug-2012.) -/
theorem com23 {ph ps ch th : wff}
  (com3_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi ch (wi ps th)) :=
@syl9 ph ps (wi ch th) ch th
  com3_1
  (@pm2_27 ch th)


/-- Commutation of antecedents. Rotate right. (Contributed by NM, 25-Apr-1994.) -/
theorem com3r {ph ps ch th : wff}
  (com3_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ch (wi ph (wi ps th)) :=
@com12 ph ch (wi ps th)
  (@com23 ph ps ch th
    com3_1)


/-- Commutation of antecedents. Swap 1st and 3rd. (Contributed by NM, 25-Apr-1994.) (Proof shortened
by Wolf Lammen, 28-Jul-2012.) -/
theorem com13 {ph ps ch th : wff}
  (com3_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ch (wi ps (wi ph th)) :=
@com23 ch ph ps th
  (@com3r ph ps ch th
    com3_1)


/-- Commutation of antecedents. Rotate left. (Contributed by NM, 25-Apr-1994.) (Proof shortened by
Wolf Lammen, 28-Jul-2012.) -/
theorem com3l {ph ps ch th : wff}
  (com3_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ps (wi ch (wi ph th)) :=
@com3r ch ph ps th
  (@com3r ph ps ch th
    com3_1)


/-- Swap antecedents. Theorem *2.04 of [WhiteheadRussell] p. 100. This was the third axiom in
Frege's logic system, specifically Proposition 8 of [Frege1879] p. 35. Its associated inference is ~
com12 . (Contributed by NM, 27-Dec-1992.) (Proof shortened by Wolf Lammen, 12-Sep-2012.) -/
theorem pm2_04 {ph ps ch : wff} :
  ⊦ wi (wi ph (wi ps ch)) (wi ps (wi ph ch)) :=
@com23 (wi ph (wi ps ch)) ph ps ch
  (@id (wi ph (wi ps ch)))


/-- Commutation of antecedents. Swap 3rd and 4th. Deduction associated with ~ com23 . Double
deduction associated with ~ com12 . (Contributed by NM, 25-Apr-1994.) -/
theorem com34 {ph ps ch th ta : wff}
  (com4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ph (wi ps (wi th (wi ch ta))) :=
@syl6 ph ps (wi ch (wi th ta)) (wi th (wi ch ta))
  com4_1
  (@pm2_04 ch th ta)


/-- Commutation of antecedents. Rotate left. (Contributed by NM, 25-Apr-1994.) (Proof shortened by
Mel L. O'Cat, 15-Aug-2004.) -/
theorem com4l {ph ps ch th ta : wff}
  (com4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ps (wi ch (wi th (wi ph ta))) :=
@com34 ps ch ph th ta
  (@com3l ph ps ch (wi th ta)
    com4_1)


/-- Commutation of antecedents. Rotate twice. (Contributed by NM, 25-Apr-1994.) -/
theorem com4t {ph ps ch th ta : wff}
  (com4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ch (wi th (wi ph (wi ps ta))) :=
@com4l ps ch th ph ta
  (@com4l ph ps ch th ta
    com4_1)


/-- Commutation of antecedents. Rotate right. (Contributed by NM, 25-Apr-1994.) -/
theorem com4r {ph ps ch th ta : wff}
  (com4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi th (wi ph (wi ps (wi ch ta))) :=
@com4l ch th ph ps ta
  (@com4t ph ps ch th ta
    com4_1)


/-- Commutation of antecedents. Swap 2nd and 4th. Deduction associated with ~ com13 . (Contributed
by NM, 25-Apr-1994.) (Proof shortened by Wolf Lammen, 28-Jul-2012.) -/
theorem com24 {ph ps ch th ta : wff}
  (com4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ph (wi th (wi ch (wi ps ta))) :=
@com13 ch th ph (wi ps ta)
  (@com4t ph ps ch th ta
    com4_1)


/-- Commutation of antecedents. Swap 1st and 4th. (Contributed by NM, 25-Apr-1994.) (Proof shortened
by Wolf Lammen, 28-Jul-2012.) -/
theorem com14 {ph ps ch th ta : wff}
  (com4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi th (wi ps (wi ch (wi ph ta))) :=
@com3r ps ch th (wi ph ta)
  (@com4l ph ps ch th ta
    com4_1)


/-- Commutation of antecedents. Swap 4th and 5th. Deduction associated with ~ com34 . Double
deduction associated with ~ com23 . Triple deduction associated with ~ com12 . (Contributed by Jeff
Hankins, 28-Jun-2009.) -/
theorem com45 {ph ps ch th ta et : wff}
  (com5_1 : ⊦ wi ph (wi ps (wi ch (wi th (wi ta et))))) :
  ⊦ wi ph (wi ps (wi ch (wi ta (wi th et)))) :=
@syl8 ph ps ch (wi th (wi ta et)) (wi ta (wi th et))
  com5_1
  (@pm2_04 th ta et)


/-- Commutation of antecedents. Swap 2nd and 5th. Deduction associated with ~ com14 . (Contributed
by Jeff Hankins, 28-Jun-2009.) -/
theorem com25 {ph ps ch th ta et : wff}
  (com5_1 : ⊦ wi ph (wi ps (wi ch (wi th (wi ta et))))) :
  ⊦ wi ph (wi ta (wi ch (wi th (wi ps et)))) :=
@com24 ph th ch ta (wi ps et)
  (@com45 ph th ch ps ta et
    (@com24 ph ps ch th (wi ta et)
      com5_1))


/-- Inference associated with ~ jarr . Partial converse of ~ ja (the other partial converse being ~
jarli ). (Contributed by Wolf Lammen, 20-Sep-2013.) -/
theorem jarri {ph ps ch : wff}
  (jarri_1 : ⊦ wi (wi ph ps) ch) :
  ⊦ wi ps ch :=
@syl ps (wi ph ps) ch
  (@ax_1 ps ph)
  jarri_1


/-- Deduction associated with ~ pm2.86 . (Contributed by NM, 29-Jun-1995.) (Proof shortened by Wolf
Lammen, 3-Apr-2013.) -/
theorem pm2_86d {ph ps ch th : wff}
  (pm2_86d_1 : ⊦ wi ph (wi (wi ps ch) (wi ps th))) :
  ⊦ wi ph (wi ps (wi ch th)) :=
@com23 ph ch ps th
  (@syl5 ch (wi ps ch) ph (wi ps th)
    (@ax_1 ch ps)
    pm2_86d_1)


/-- Inference associated with ~ pm2.86 . (Contributed by NM, 5-Aug-1993.) (Proof shortened by Wolf
Lammen, 3-Apr-2013.) -/
theorem pm2_86i {ph ps ch : wff}
  (pm2_86i_1 : ⊦ wi (wi ph ps) (wi ph ch)) :
  ⊦ wi ph (wi ps ch) :=
@com12 ps ph ch
  (@jarri ph ps (wi ph ch)
    pm2_86i_1)


/-- Alias for ~ ax-3 to be used instead of it for labeling consistency. Its associated inference is
~ con4i and its associated deduction is ~ con4d . (Contributed by BJ, 24-Dec-2020.) -/
theorem con4 {ph ps : wff} :
  ⊦ wi (wi (wn ph) (wn ps)) (wi ps ph) :=
@ax_3 ph ps


/-- Inference associated with ~ con4 . Its associated inference is ~ mt4 . Remark: this can also be
proved using ~ notnot followed by ~ nsyl2 , giving a shorter proof but depending on more axioms
(namely, ~ ax-1 and ~ ax-2 ). (Contributed by NM, 29-Dec-1992.) -/
theorem con4i {ph ps : wff}
  (con4i_1 : ⊦ wi (wn ph) (wn ps)) :
  ⊦ wi ps ph :=
@ax_mp (wi (wn ph) (wn ps)) (wi ps ph)
  con4i_1
  (@con4 ph ps)


/-- Deduction associated with ~ con4 . (Contributed by NM, 26-Mar-1995.) -/
theorem con4d {ph ps ch : wff}
  (con4d_1 : ⊦ wi ph (wi (wn ps) (wn ch))) :
  ⊦ wi ph (wi ch ps) :=
@syl ph (wi (wn ps) (wn ch)) (wi ch ps)
  con4d_1
  (@con4 ps ch)


/-- The rule of modus tollens. Inference associated with ~ con4i . (Contributed by Wolf Lammen,
12-May-2013.) -/
theorem mt4 {ph ps : wff}
  (mt4_1 : ⊦ ph)
  (mt4_2 : ⊦ wi (wn ps) (wn ph)) :
  ⊦ ps :=
@ax_mp ph ps
  mt4_1
  (@con4i ps ph
    mt4_2)


/-- Modus tollens deduction. Deduction form of ~ mt4 . (Contributed by NM, 9-Jun-2006.) -/
theorem mt4d {ph ps ch : wff}
  (mt4d_1 : ⊦ wi ph ps)
  (mt4d_2 : ⊦ wi ph (wi (wn ch) (wn ps))) :
  ⊦ wi ph ch :=
@mpd ph ps ch
  mt4d_1
  (@con4d ph ch ps
    mt4d_2)


/-- A contradiction implies anything. Inference associated with ~ pm2.21 . Its associated inference
is ~ pm2.24ii . (Contributed by NM, 16-Sep-1993.) -/
theorem pm2_21i {ph ps : wff}
  (pm2_21i_1 : ⊦ wn ph) :
  ⊦ wi ph ps :=
@con4i ps ph
  (@a1i (wn ph) (wn ps)
    pm2_21i_1)


/-- A contradiction implies anything. Deduction associated with ~ pm2.21 . (Contributed by NM,
10-Feb-1996.) -/
theorem pm2_21d {ph ps ch : wff}
  (pm2_21d_1 : ⊦ wi ph (wn ps)) :
  ⊦ wi ph (wi ps ch) :=
@con4d ph ch ps
  (@a1d ph (wn ps) (wn ch)
    pm2_21d_1)


/-- From a wff and its negation, anything follows. Theorem *2.21 of [WhiteheadRussell] p. 104. Also
called the Duns Scotus law. Its commuted form is ~ pm2.24 and its associated inference is ~ pm2.21i
. (Contributed by NM, 29-Dec-1992.) (Proof shortened by Wolf Lammen, 14-Sep-2012.) -/
theorem pm2_21 {ph ps : wff} :
  ⊦ wi (wn ph) (wi ph ps) :=
@pm2_21d (wn ph) ph ps
  (@id (wn ph))


/-- Theorem *2.24 of [WhiteheadRussell] p. 104. Its associated inference is ~ pm2.24i . Commuted
form of ~ pm2.21 . (Contributed by NM, 3-Jan-2005.) -/
theorem pm2_24 {ph ps : wff} :
  ⊦ wi ph (wi (wn ph) ps) :=
@com12 (wn ph) ph ps
  (@pm2_21 ph ps)


/-- Inference associated with ~ jarl . Partial converse of ~ ja (the other partial converse being ~
jarri ). (Contributed by Wolf Lammen, 4-Oct-2013.) -/
theorem jarli {ph ps ch : wff}
  (jarli_1 : ⊦ wi (wi ph ps) ch) :
  ⊦ wi (wn ph) ch :=
@syl (wn ph) (wi ph ps) ch
  (@pm2_21 ph ps)
  jarli_1


/-- Deduction form of the Clavius law ~ pm2.18 . (Contributed by FL, 12-Jul-2009.) (Proof shortened
by Andrew Salmon, 7-May-2011.) Revised to shorten ~ pm2.18 . (Revised by Wolf Lammen, 17-Nov-2023.)
-/
theorem pm2_18d {ph ps : wff}
  (pm2_18d_1 : ⊦ wi ph (wi (wn ps) ps)) :
  ⊦ wi ph ps :=
@mt4d ph ph ps
  (@id ph)
  (@sylcom ph (wn ps) ps (wn ph)
    pm2_18d_1
    (@pm2_21 ps (wn ph)))


/-- Clavius law, or "consequentia mirabilis" ("admirable consequence"). If a formula is implied by
its negation, then it is true. Can be used in proofs by contradiction. Theorem *2.18 of
[WhiteheadRussell] p. 103. See also the weak Clavius law ~ pm2.01 . (Contributed by NM,
29-Dec-1992.) (Proof shortened by Wolf Lammen, 17-Nov-2023.) -/
theorem pm2_18 {ph : wff} :
  ⊦ wi (wi (wn ph) ph) ph :=
@pm2_18d (wi (wn ph) ph) ph
  (@id (wi (wn ph) ph))


/-- Inference associated with the Clavius law ~ pm2.18 . (Contributed by BJ, 30-Mar-2020.) -/
theorem pm2_18i {ph : wff}
  (pm2_18i_1 : ⊦ wi (wn ph) ph) :
  ⊦ ph :=
@ax_mp (wi (wn ph) ph) ph
  pm2_18i_1
  (@pm2_18 ph)


/-- Double negation elimination. Converse of ~ notnot and one implication of ~ notnotb . Theorem
*2.14 of [WhiteheadRussell] p. 102. This was the fifth axiom of Frege, specifically Proposition 31
of [Frege1879] p. 44. In classical logic (our logic) this is always true. In intuitionistic logic
this is not always true, and formulas for which it is true are called "stable". (Contributed by NM,
29-Dec-1992.) (Proof shortened by David Harvey, 5-Sep-1999.) (Proof shortened by Josh Purinton,
29-Dec-2000.) -/
theorem notnotr {ph : wff} :
  ⊦ wi (wn (wn ph)) ph :=
@jarli (wn ph) ph ph
  (@pm2_18 ph)


/-- Inference associated with ~ notnotr . For a shorter proof using ~ ax-2 , see ~ notnotriALT .
(Contributed by NM, 27-Feb-2008.) (Proof shortened by Wolf Lammen, 15-Jul-2021.) Remove dependency
on ~ ax-2 . (Revised by Steven Nguyen, 27-Dec-2022.) -/
theorem notnotri {ph : wff}
  (notnotri_1 : ⊦ wn (wn ph)) :
  ⊦ ph :=
@mt4 (wn (wn ph)) ph
  notnotri_1
  (@pm2_21i (wn ph) (wn (wn (wn ph)))
    notnotri_1)


/-- Deduction associated with ~ notnotr and ~ notnotri . Double negation elimination rule. A
translation of the natural deduction rule ` -. -. ` C , ` _G |- -. -. ps => _G |- ps ` ; see ~
natded . This is Definition NNC in [Pfenning] p. 17. This rule is valid in classical logic (our
logic), but not in intuitionistic logic. (Contributed by DAW, 8-Feb-2017.) -/
theorem notnotrd {ph ps : wff}
  (notnotrd_1 : ⊦ wi ph (wn (wn ps))) :
  ⊦ wi ph ps :=
@syl ph (wn (wn ps)) ps
  notnotrd_1
  (@notnotr ps)


/-- A contraposition deduction. (Contributed by NM, 19-Aug-1993.) -/
theorem con2d {ph ps ch : wff}
  (con2d_1 : ⊦ wi ph (wi ps (wn ch))) :
  ⊦ wi ph (wi ch (wn ps)) :=
@con4d ph (wn ps) ch
  (@syl5 (wn (wn ps)) ps ph (wn ch)
    (@notnotr ps)
    con2d_1)


/-- Contraposition. Theorem *2.03 of [WhiteheadRussell] p. 100. (Contributed by NM, 29-Dec-1992.)
(Proof shortened by Wolf Lammen, 12-Feb-2013.) -/
theorem con2 {ph ps : wff} :
  ⊦ wi (wi ph (wn ps)) (wi ps (wn ph)) :=
@con2d (wi ph (wn ps)) ph ps
  (@id (wi ph (wn ps)))


/-- Modus tollens deduction. (Contributed by NM, 4-Jul-1994.) -/
theorem mt2d {ph ps ch : wff}
  (mt2d_1 : ⊦ wi ph ch)
  (mt2d_2 : ⊦ wi ph (wi ps (wn ch))) :
  ⊦ wi ph (wn ps) :=
@mpd ph ch (wn ps)
  mt2d_1
  (@con2d ph ps ch
    mt2d_2)


/-- A negated syllogism inference. (Contributed by NM, 1-Dec-1995.) -/
theorem nsyl3 {ph ps ch : wff}
  (nsyl3_1 : ⊦ wi ph (wn ps))
  (nsyl3_2 : ⊦ wi ch ps) :
  ⊦ wi ch (wn ph) :=
@mt2d ch ph ps
  nsyl3_2
  (@a1i (wi ph (wn ps)) ch
    nsyl3_1)


/-- A contraposition inference. Its associated inference is ~ mt2 . (Contributed by NM,
10-Jan-1993.) (Proof shortened by Mel L. O'Cat, 28-Nov-2008.) (Proof shortened by Wolf Lammen,
13-Jun-2013.) -/
theorem con2i {ph ps : wff}
  (con2i_a : ⊦ wi ph (wn ps)) :
  ⊦ wi ps (wn ph) :=
@nsyl3 ph ps ps
  con2i_a
  (@id ps)


/-- A negated syllogism inference. (Contributed by NM, 31-Dec-1993.) (Proof shortened by Wolf
Lammen, 2-Mar-2013.) -/
theorem nsyl {ph ps ch : wff}
  (nsyl_1 : ⊦ wi ph (wn ps))
  (nsyl_2 : ⊦ wi ch ps) :
  ⊦ wi ph (wn ch) :=
@con2i ch ph
  (@nsyl3 ph ps ch
    nsyl_1
    nsyl_2)


/-- A negated syllogism inference. (Contributed by NM, 26-Jun-1994.) (Proof shortened by Wolf
Lammen, 14-Nov-2023.) -/
theorem nsyl2 {ph ps ch : wff}
  (nsyl2_1 : ⊦ wi ph (wn ps))
  (nsyl2_2 : ⊦ wi (wn ch) ps) :
  ⊦ wi ph ch :=
@con4i ch ph
  (@nsyl3 ph ps (wn ch)
    nsyl2_1
    nsyl2_2)


/-- Double negation introduction. Converse of ~ notnotr and one implication of ~ notnotb . Theorem
*2.12 of [WhiteheadRussell] p. 101. This was the sixth axiom of Frege, specifically Proposition 41
of [Frege1879] p. 47. (Contributed by NM, 28-Dec-1992.) (Proof shortened by Wolf Lammen,
2-Mar-2013.) -/
theorem notnot {ph : wff} :
  ⊦ wi ph (wn (wn ph)) :=
@con2i (wn ph) ph
  (@id (wn ph))


/-- Inference associated with ~ notnot . (Contributed by NM, 27-Feb-2008.) -/
theorem notnoti {ph : wff}
  (notnoti_1 : ⊦ ph) :
  ⊦ wn (wn ph) :=
@ax_mp ph (wn (wn ph))
  notnoti_1
  (@notnot ph)


/-- A contraposition deduction. (Contributed by NM, 27-Dec-1992.) -/
theorem con1d {ph ps ch : wff}
  (con1d_1 : ⊦ wi ph (wi (wn ps) ch)) :
  ⊦ wi ph (wi (wn ch) ps) :=
@con4d ph ps (wn ch)
  (@syl6 ph (wn ps) ch (wn (wn ch))
    con1d_1
    (@notnot ch))


/-- Contraposition. Theorem *2.15 of [WhiteheadRussell] p. 102. Its associated inference is ~ con1i
. (Contributed by NM, 29-Dec-1992.) (Proof shortened by Wolf Lammen, 12-Feb-2013.) -/
theorem con1 {ph ps : wff} :
  ⊦ wi (wi (wn ph) ps) (wi (wn ps) ph) :=
@con1d (wi (wn ph) ps) ph ps
  (@id (wi (wn ph) ps))


/-- A contraposition inference. Inference associated with ~ con1 . Its associated inference is ~ mt3
. (Contributed by NM, 3-Jan-1993.) (Proof shortened by Mel L. O'Cat, 28-Nov-2008.) (Proof shortened
by Wolf Lammen, 19-Jun-2013.) -/
theorem con1i {ph ps : wff}
  (con1i_1 : ⊦ wi (wn ph) ps) :
  ⊦ wi (wn ps) ph :=
@nsyl2 (wn ps) ps ph
  (@id (wn ps))
  con1i_1


/-- Modus tollens deduction. (Contributed by NM, 26-Mar-1995.) -/
theorem mt3d {ph ps ch : wff}
  (mt3d_1 : ⊦ wi ph (wn ch))
  (mt3d_2 : ⊦ wi ph (wi (wn ps) ch)) :
  ⊦ wi ph ps :=
@mpd ph (wn ch) ps
  mt3d_1
  (@con1d ph ps ch
    mt3d_2)


/-- Modus tollens inference. (Contributed by NM, 26-Mar-1995.) (Proof shortened by Wolf Lammen,
15-Sep-2012.) -/
theorem mt3i {ph ps ch : wff}
  (mt3i_1 : ⊦ wn ch)
  (mt3i_2 : ⊦ wi ph (wi (wn ps) ch)) :
  ⊦ wi ph ps :=
@mt3d ph ps ch
  (@a1i (wn ch) ph
    mt3i_1)
  mt3i_2


/-- Inference associated with ~ pm2.24 . Its associated inference is ~ pm2.24ii . (Contributed by
NM, 20-Aug-2001.) -/
theorem pm2_24i {ph ps : wff}
  (pm2_24i_1 : ⊦ ph) :
  ⊦ wi (wn ph) ps :=
@con1i ps ph
  (@a1i ph (wn ps)
    pm2_24i_1)


/-- Deduction form of ~ pm2.24 . (Contributed by NM, 30-Jan-2006.) -/
theorem pm2_24d {ph ps ch : wff}
  (pm2_24d_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wi (wn ps) ch) :=
@con1d ph ch ps
  (@a1d ph ps (wn ch)
    pm2_24d_1)


/-- A contraposition deduction. Deduction form of ~ con3 . (Contributed by NM, 10-Jan-1993.) -/
theorem con3d {ph ps ch : wff}
  (con3d_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wn ch) (wn ps)) :=
@con1d ph (wn ps) ch
  (@syl5 (wn (wn ps)) ps ph ch
    (@notnotr ps)
    con3d_1)


/-- Contraposition. Theorem *2.16 of [WhiteheadRussell] p. 103. This was the fourth axiom of Frege,
specifically Proposition 28 of [Frege1879] p. 43. Its associated inference is ~ con3i . (Contributed
by NM, 29-Dec-1992.) (Proof shortened by Wolf Lammen, 13-Feb-2013.) -/
theorem con3 {ph ps : wff} :
  ⊦ wi (wi ph ps) (wi (wn ps) (wn ph)) :=
@con3d (wi ph ps) ph ps
  (@id (wi ph ps))


/-- A contraposition inference. Inference associated with ~ con3 . Its associated inference is ~ mto
. (Contributed by NM, 3-Jan-1993.) (Proof shortened by Wolf Lammen, 20-Jun-2013.) -/
theorem con3i {ph ps : wff}
  (con3i_a : ⊦ wi ph ps) :
  ⊦ wi (wn ps) (wn ph) :=
@nsyl (wn ps) ps ph
  (@id (wn ps))
  con3i_a


/-- Rotate through consequent right. (Contributed by Wolf Lammen, 3-Nov-2013.) -/
theorem con3rr3 {ph ps ch : wff}
  (con3rr3_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wn ch) (wi ph (wn ps)) :=
@com12 ph (wn ch) (wn ps)
  (@con3d ph ps ch
    con3rr3_1)


/-- A negated syllogism deduction. (Contributed by NM, 9-Apr-2005.) -/
theorem nsyld {ph ps ch ta : wff}
  (nsyld_1 : ⊦ wi ph (wi ps (wn ch)))
  (nsyld_2 : ⊦ wi ph (wi ta ch)) :
  ⊦ wi ph (wi ps (wn ta)) :=
@syld ph ps (wn ch) (wn ta)
  nsyld_1
  (@con3d ph ta ch
    nsyld_2)


/-- A negated syllogism inference. (Contributed by NM, 3-May-1994.) -/
theorem nsyli {ph ps ch th : wff}
  (nsyli_1 : ⊦ wi ph (wi ps ch))
  (nsyli_2 : ⊦ wi th (wn ch)) :
  ⊦ wi ph (wi th (wn ps)) :=
@syl5 th (wn ch) ph (wn ps)
  nsyli_2
  (@con3d ph ps ch
    nsyli_1)


/-- A negated syllogism inference. (Contributed by NM, 15-Feb-1996.) -/
theorem nsyl4 {ph ps ch : wff}
  (nsyl4_1 : ⊦ wi ph ps)
  (nsyl4_2 : ⊦ wi (wn ph) ch) :
  ⊦ wi (wn ch) ps :=
@syl (wn ch) ph ps
  (@con1i ph ch
    nsyl4_2)
  nsyl4_1


/-- A negated syllogism inference. (Contributed by Wolf Lammen, 20-May-2024.) -/
theorem nsyl5 {ph ps ch : wff}
  (nsyl4_1 : ⊦ wi ph ps)
  (nsyl4_2 : ⊦ wi (wn ph) ch) :
  ⊦ wi (wn ps) ch :=
@con1i ch ps
  (@nsyl4 ph ps ch
    nsyl4_1
    nsyl4_2)


/-- Theorem *3.2 of [WhiteheadRussell] p. 111, expressed with primitive connectives (see ~ pm3.2 ).
(Contributed by NM, 29-Dec-1992.) (Proof shortened by Josh Purinton, 29-Dec-2000.) -/
theorem pm3_2im {ph ps : wff} :
  ⊦ wi ph (wi ps (wn (wi ph (wn ps)))) :=
@con2d ph (wi ph (wn ps)) ps
  (@pm2_27 ph (wn ps))


/-- An importation inference. (Contributed by NM, 29-Dec-1992.) (Proof shortened by Wolf Lammen,
20-Jul-2013.) -/
theorem impi {ph ps ch : wff}
  (impi_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wn (wi ph (wn ps))) ch :=
@con1i ch (wi ph (wn ps))
  (@con3rr3 ph ps ch
    impi_1)


/-- An exportation inference. (Contributed by NM, 29-Dec-1992.) (Proof shortened by Mel L. O'Cat,
28-Nov-2008.) -/
theorem expi {ph ps ch : wff}
  (expi_1 : ⊦ wi (wn (wi ph (wn ps))) ch) :
  ⊦ wi ph (wi ps ch) :=
@syl6 ph ps (wn (wi ph (wn ps))) ch
  (@pm3_2im ph ps)
  expi_1


/-- Simplification. Similar to Theorem *3.27 (Simp) of [WhiteheadRussell] p. 112. (Contributed by
NM, 3-Jan-1993.) (Proof shortened by Wolf Lammen, 13-Nov-2012.) -/
theorem simprim {ph ps : wff} :
  ⊦ wi (wn (wi ph (wn ps))) ps :=
@impi ph ps ps
  (@idd ph ps)


/-- Simplification. Similar to Theorem *3.26 (Simp) of [WhiteheadRussell] p. 112. (Contributed by
NM, 3-Jan-1993.) (Proof shortened by Wolf Lammen, 21-Jul-2012.) -/
theorem simplim {ph ps : wff} :
  ⊦ wi (wn (wi ph ps)) ph :=
@con1i ph (wi ph ps)
  (@pm2_21 ph ps)


/-- Deduction eliminating an antecedent. (Contributed by NM, 27-Apr-1994.) (Proof shortened by Wolf
Lammen, 12-Sep-2013.) -/
theorem pm2_61d {ph ps ch : wff}
  (pm2_61d_1 : ⊦ wi ph (wi ps ch))
  (pm2_61d_2 : ⊦ wi ph (wi (wn ps) ch)) :
  ⊦ wi ph ch :=
@pm2_18d ph ch
  (@syld ph (wn ch) ps ch
    (@con1d ph ps ch
      pm2_61d_2)
    pm2_61d_1)


/-- Inference eliminating an antecedent. (Contributed by NM, 15-Jul-2005.) -/
theorem pm2_61d1 {ph ps ch : wff}
  (pm2_61d1_1 : ⊦ wi ph (wi ps ch))
  (pm2_61d1_2 : ⊦ wi (wn ps) ch) :
  ⊦ wi ph ch :=
@pm2_61d ph ps ch
  pm2_61d1_1
  (@a1i (wi (wn ps) ch) ph
    pm2_61d1_2)


/-- Inference eliminating an antecedent. (Contributed by NM, 18-Aug-1993.) -/
theorem pm2_61d2 {ph ps ch : wff}
  (pm2_61d2_1 : ⊦ wi ph (wi (wn ps) ch))
  (pm2_61d2_2 : ⊦ wi ps ch) :
  ⊦ wi ph ch :=
@pm2_61d ph ps ch
  (@a1i (wi ps ch) ph
    pm2_61d2_2)
  pm2_61d2_1


/-- Inference eliminating an antecedent. (Contributed by NM, 5-Apr-1994.) (Proof shortened by Wolf
Lammen, 19-Nov-2023.) -/
theorem pm2_61i {ph ps : wff}
  (pm2_61i_1 : ⊦ wi ph ps)
  (pm2_61i_2 : ⊦ wi (wn ph) ps) :
  ⊦ ps :=
@pm2_18i ps
  (@nsyl4 ph ps ps
    pm2_61i_1
    pm2_61i_2)


/-- Inference eliminating two antecedents. (Contributed by NM, 4-Jan-1993.) (Proof shortened by Josh
Purinton, 29-Dec-2000.) -/
theorem pm2_61ii {ph ps ch : wff}
  (pm2_61ii_1 : ⊦ wi (wn ph) (wi (wn ps) ch))
  (pm2_61ii_2 : ⊦ wi ph ch)
  (pm2_61ii_3 : ⊦ wi ps ch) :
  ⊦ ch :=
@pm2_61i ph ch
  pm2_61ii_2
  (@pm2_61d2 (wn ph) ps ch
    pm2_61ii_1
    pm2_61ii_3)


/-- Inference eliminating two antecedents. (Contributed by NM, 13-Jul-2005.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 13-Nov-2012.) -/
theorem pm2_61nii {ph ps ch : wff}
  (pm2_61nii_1 : ⊦ wi ph (wi ps ch))
  (pm2_61nii_2 : ⊦ wi (wn ph) ch)
  (pm2_61nii_3 : ⊦ wi (wn ps) ch) :
  ⊦ ch :=
@pm2_61i ph ch
  (@pm2_61d1 ph ps ch
    pm2_61nii_1
    pm2_61nii_3)
  pm2_61nii_2


/-- Inference joining the antecedents of two premises. For partial converses, see ~ jarri and ~
jarli . (Contributed by NM, 24-Jan-1993.) (Proof shortened by Mel L. O'Cat, 19-Feb-2008.) -/
theorem ja {ph ps ch : wff}
  (ja_1 : ⊦ wi (wn ph) ch)
  (ja_2 : ⊦ wi ps ch) :
  ⊦ wi (wi ph ps) ch :=
@pm2_61d1 (wi ph ps) ph ch
  (@imim2i ps ch ph
    ja_2)
  ja_1


/-- Deduction form of ~ ja . (Contributed by Scott Fenton, 13-Dec-2010.) (Proof shortened by Andrew
Salmon, 17-Sep-2011.) -/
theorem jad {ph ps ch th : wff}
  (jad_1 : ⊦ wi ph (wi (wn ps) th))
  (jad_2 : ⊦ wi ph (wi ch th)) :
  ⊦ wi ph (wi (wi ps ch) th) :=
@com12 (wi ps ch) ph th
  (@ja ps ch (wi ph th)
    (@com12 ph (wn ps) th
      jad_1)
    (@com12 ph ch th
      jad_2))


/-- Weak Clavius law. If a formula implies its negation, then it is false. A form of "reductio ad
absurdum", which can be used in proofs by contradiction. Theorem *2.01 of [WhiteheadRussell] p. 100.
Provable in minimal calculus, contrary to the Clavius law ~ pm2.18 . (Contributed by NM,
18-Aug-1993.) (Proof shortened by Mel L. O'Cat, 21-Nov-2008.) (Proof shortened by Wolf Lammen,
31-Oct-2012.) -/
theorem pm2_01 {ph : wff} :
  ⊦ wi (wi ph (wn ph)) (wn ph) :=
@ja ph (wn ph) (wn ph)
  (@id (wn ph))
  (@id (wn ph))


/-- Deduction based on reductio ad absurdum. (Contributed by NM, 18-Aug-1993.) (Proof shortened by
Wolf Lammen, 5-Mar-2013.) -/
theorem pm2_01d {ph ps : wff}
  (pm2_01d_1 : ⊦ wi ph (wi ps (wn ps))) :
  ⊦ wi ph (wn ps) :=
@pm2_61d1 ph ps (wn ps)
  pm2_01d_1
  (@id (wn ps))


/-- Inference for proof by contradiction. (Contributed by NM, 18-May-1994.) (Proof shortened by Wolf
Lammen, 11-Sep-2013.) -/
theorem pm2_65i {ph ps : wff}
  (pm2_65i_1 : ⊦ wi ph ps)
  (pm2_65i_2 : ⊦ wi ph (wn ps)) :
  ⊦ wn ph :=
@pm2_61i ps (wn ph)
  (@con2i ph ps
    pm2_65i_2)
  (@con3i ph ps
    pm2_65i_1)


/-- A contradiction implies anything. Deduction from ~ pm2.21 . (Contributed by Mario Carneiro,
9-Feb-2017.) (Proof shortened by Wolf Lammen, 22-Jul-2019.) -/
theorem pm2_21dd {ph ps ch : wff}
  (pm2_21dd_1 : ⊦ wi ph ps)
  (pm2_21dd_2 : ⊦ wi ph (wn ps)) :
  ⊦ wi ph ch :=
@pm2_21i ph ch
  (@pm2_65i ph ps
    pm2_21dd_1
    pm2_21dd_2)


/-- Deduction for proof by contradiction. (Contributed by NM, 26-Jun-1994.) (Proof shortened by Wolf
Lammen, 26-May-2013.) -/
theorem pm2_65d {ph ps ch : wff}
  (pm2_65d_1 : ⊦ wi ph (wi ps ch))
  (pm2_65d_2 : ⊦ wi ph (wi ps (wn ch))) :
  ⊦ wi ph (wn ps) :=
@pm2_01d ph ps
  (@nsyld ph ps ch ps
    pm2_65d_2
    pm2_65d_1)


/-- The rule of modus tollens. The rule says, "if ` ps ` is not true, and ` ph ` implies ` ps ` ,
then ` ph ` must also be not true". Modus tollens is short for "modus tollendo tollens", a Latin
phrase that means "the mode that by denying denies" - remark in [Sanford] p. 39. It is also called
denying the consequent. Modus tollens is closely related to modus ponens ~ ax-mp . Note that this
rule is also valid in intuitionistic logic. Inference associated with ~ con3i . (Contributed by NM,
19-Aug-1993.) (Proof shortened by Wolf Lammen, 11-Sep-2013.) -/
theorem mto {ph ps : wff}
  (mto_1 : ⊦ wn ps)
  (mto_2 : ⊦ wi ph ps) :
  ⊦ wn ph :=
@pm2_65i ph ps
  mto_2
  (@a1i (wn ps) ph
    mto_1)


/-- Modus tollens deduction. (Contributed by NM, 3-Apr-1994.) (Proof shortened by Wolf Lammen,
11-Sep-2013.) -/
theorem mtod {ph ps ch : wff}
  (mtod_1 : ⊦ wi ph (wn ch))
  (mtod_2 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wn ps) :=
@pm2_65d ph ps ch
  mtod_2
  (@a1d ph (wn ch) ps
    mtod_1)


/-- Modus tollens inference. (Contributed by NM, 5-Jul-1994.) (Proof shortened by Wolf Lammen,
15-Sep-2012.) -/
theorem mtoi {ph ps ch : wff}
  (mtoi_1 : ⊦ wn ch)
  (mtoi_2 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wn ps) :=
@mtod ph ps ch
  (@a1i (wn ch) ph
    mtoi_1)
  mtoi_2


/-- A rule similar to modus tollens. Inference associated with ~ con1i . (Contributed by NM,
18-May-1994.) (Proof shortened by Wolf Lammen, 11-Sep-2013.) -/
theorem mt3 {ph ps : wff}
  (mt3_1 : ⊦ wn ps)
  (mt3_2 : ⊦ wi (wn ph) ps) :
  ⊦ ph :=
@notnotri ph
  (@mto (wn ph) ps
    mt3_1
    mt3_2)


-- /-- Extend wff definition to include the biconditional connective. -/
-- constant wb : wff → wff → wff


-- /-- Define the biconditional (logical "iff" or "if and only if"), also called biimplication.
-- Definition ~ df-bi in this section is our first definition, which introduces and defines the
-- biconditional connective ` <-> ` . We define a wff of the form ` ( ph <-> ps ) ` as an
-- abbreviation for ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` . Unlike most traditional
-- developments, we have chosen not to have a separate symbol such as "Df." to mean "is defined as".
-- Instead, we will later use the biconditional connective for this purpose ( ~ df-or is its first
-- use), as it allows us to use logic to manipulate definitions directly. This greatly simplifies
-- many proofs since it eliminates the need for a separate mechanism for introducing and eliminating
-- definitions. Of course, we cannot use this mechanism to define the biconditional itself, since it
-- hasn't been introduced yet. Instead, we use a more general form of definition, described as
-- follows. In its most general form, a definition is simply an assertion that introduces a new
-- symbol (or a new combination of existing symbols, as in ~ df-3an ) that is eliminable and does
-- not strengthen the existing language. The latter requirement means that the set of provable
-- statements not containing the new symbol (or new combination) should remain exactly the same
-- after the definition is introduced. Our definition of the biconditional may look unusual compared
-- to most definitions, but it strictly satisfies these requirements. The justification for our
-- definition is that if we mechanically replace ` ( ph <-> ps ) ` (the definiendum i.e. the thing
-- being defined) with ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` (the definiens i.e. the defining
-- expression) in the definition, the definition becomes the previously proved theorem ~ bijust . It
-- is impossible to use ~ df-bi to prove any statement expressed in the original language that can't
-- be proved from the original axioms, because if we simply replace each instance of ~ df-bi in the
-- proof with the corresponding ~ bijust instance, we will end up with a proof from the original
-- axioms. Note that from Metamath's point of view, a definition is just another axiom - i.e. an
-- assertion we claim to be true - but from our high level point of view, we are not strengthening
-- the language. To indicate this fact, we prefix definition labels with "df-" instead of "ax-".
-- (This prefixing is an informal convention that means nothing to the Metamath proof verifier; it
-- is just a naming convention for human readability.) After we define the constant true ` T. ` ( ~
-- df-tru ) and the constant false ` F. ` ( ~ df-fal ), we will be able to prove these truth table
-- values: ` ( ( T. <-> T. ) <-> T. ) ` ( ~ trubitru ), ` ( ( T. <-> F. ) <-> F. ) ` ( ~ trubifal ),
-- ` ( ( F. <-> T. ) <-> F. ) ` ( ~ falbitru ), and ` ( ( F. <-> F. ) <-> T. ) ` ( ~ falbifal ). See
-- ~ dfbi1 , ~ dfbi2 , and ~ dfbi3 for theorems suggesting typical textbook definitions of ` <-> ` ,
-- showing that our definition has the properties we expect. Theorem ~ dfbi1 is particularly useful
-- if we want to eliminate ` <-> ` from an expression to convert it to primitives. Theorem ~ dfbi
-- shows this definition rewritten in an abbreviated form after conjunction is introduced, for
-- easier understanding. Contrast with ` \/ ` ( ~ df-or ), ` -> ` ( ~ wi ), ` -/\ ` ( ~ df-nan ),
-- and ` \/_ ` ( ~ df-xor ). In some sense ` <-> ` returns true if two truth values are equal; ` = `
-- ( ~ df-cleq ) returns true if two classes are equal. (Contributed by NM, 27-Dec-1992.) -/
-- axiom df_bi {ph ps : wff} : ⊦ wn (wi (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wn (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps))))


/-- Property of the biconditional connective. (Contributed by NM, 11-May-1999.) -/
theorem impbi {ph ps : wff} :
  ⊦ wi (wi ph ps) (wi (wi ps ph) (wb ph ps)) :=
@expi (wi ph ps) (wi ps ph) (wb ph ps)
  (@ax_mp (wn (wi (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wn (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps))))) (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps))
    (@df_bi ph ps)
    (@simprim (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps))))


/-- Infer an equivalence from an implication and its converse. Inference associated with ~ impbi .
(Contributed by NM, 29-Dec-1992.) -/
theorem impbii {ph ps : wff}
  (impbii_1 : ⊦ wi ph ps)
  (impbii_2 : ⊦ wi ps ph) :
  ⊦ wb ph ps :=
@mp2 (wi ph ps) (wi ps ph) (wb ph ps)
  impbii_1
  impbii_2
  (@impbi ph ps)


/-- Deduce an equivalence from two implications. Double deduction associated with ~ impbi and ~
impbii . Deduction associated with ~ impbid . (Contributed by Rodolfo Medina, 12-Oct-2010.) -/
theorem impbidd {ph ps ch th : wff}
  (impbidd_1 : ⊦ wi ph (wi ps (wi ch th)))
  (impbidd_2 : ⊦ wi ph (wi ps (wi th ch))) :
  ⊦ wi ph (wi ps (wb ch th)) :=
@syl6c ph ps (wi ch th) (wi th ch) (wb ch th)
  impbidd_1
  impbidd_2
  (@impbi ch th)


/-- Deduce an equivalence from two implications. (Contributed by Wolf Lammen, 12-May-2013.) -/
theorem impbid21d {ph ps ch th : wff}
  (impbid21d_1 : ⊦ wi ps (wi ch th))
  (impbid21d_2 : ⊦ wi ph (wi th ch)) :
  ⊦ wi ph (wi ps (wb ch th)) :=
@syl2imc ps (wi ch th) ph (wi th ch) (wb ch th)
  impbid21d_1
  impbid21d_2
  (@impbi ch th)


/-- Deduce an equivalence from two implications. Deduction associated with ~ impbi and ~ impbii .
(Contributed by NM, 24-Jan-1993.) Revised to prove it from ~ impbid21d . (Revised by Wolf Lammen,
3-Nov-2012.) -/
theorem impbid {ph ps ch : wff}
  (impbid_1 : ⊦ wi ph (wi ps ch))
  (impbid_2 : ⊦ wi ph (wi ch ps)) :
  ⊦ wi ph (wb ps ch) :=
@pm2_43i ph (wb ps ch)
  (@impbid21d ph ph ps ch
    impbid_1
    impbid_2)


/-- Relate the biconditional connective to primitive connectives. See ~ dfbi1ALT for an unusual
version proved directly from axioms. (Contributed by NM, 29-Dec-1992.) -/
theorem dfbi1 {ph ps : wff} :
  ⊦ wb (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph)))) :=
@mt3 (wb (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wi (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wn (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps))))
  (@df_bi ph ps)
  (@con3rr3 (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps)) (wb (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph)))))
    (@impbi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))))


/-- Property of the biconditional connective. (Contributed by NM, 11-May-1999.) -/
theorem biimp {ph ps : wff} :
  ⊦ wi (wb ph ps) (wi ph ps) :=
@syl (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph)))) (wi ph ps)
  (@ax_mp (wn (wi (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wn (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps))))) (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph)))))
    (@df_bi ph ps)
    (@simplim (wi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph))))) (wn (wi (wn (wi (wi ph ps) (wn (wi ps ph)))) (wb ph ps)))))
  (@simplim (wi ph ps) (wn (wi ps ph)))


/-- Infer an implication from a logical equivalence. Inference associated with ~ biimp .
(Contributed by NM, 29-Dec-1992.) -/
theorem biimpi {ph ps : wff}
  (biimpi_1 : ⊦ wb ph ps) :
  ⊦ wi ph ps :=
@ax_mp (wb ph ps) (wi ph ps)
  biimpi_1
  (@biimp ph ps)


/-- A mixed syllogism inference from a biconditional and an implication. Useful for substituting an
antecedent with a definition. (Contributed by NM, 3-Jan-1993.) -/
theorem sylbi {ph ps ch : wff}
  (sylbi_1 : ⊦ wb ph ps)
  (sylbi_2 : ⊦ wi ps ch) :
  ⊦ wi ph ch :=
@syl ph ps ch
  (@biimpi ph ps
    sylbi_1)
  sylbi_2


/-- A mixed syllogism inference from an implication and a biconditional. (Contributed by NM,
3-Jan-1993.) -/
theorem sylib {ph ps ch : wff}
  (sylib_1 : ⊦ wi ph ps)
  (sylib_2 : ⊦ wb ps ch) :
  ⊦ wi ph ch :=
@syl ph ps ch
  sylib_1
  (@biimpi ps ch
    sylib_2)


/-- A mixed syllogism inference from two biconditionals. (Contributed by BJ, 30-Mar-2019.) -/
theorem sylbb {ph ps ch : wff}
  (sylbb_1 : ⊦ wb ph ps)
  (sylbb_2 : ⊦ wb ps ch) :
  ⊦ wi ph ch :=
@sylbi ph ps ch
  sylbb_1
  (@biimpi ps ch
    sylbb_2)


/-- Property of the biconditional connective. (Contributed by NM, 11-May-1999.) (Proof shortened by
Wolf Lammen, 11-Nov-2012.) -/
theorem biimpr {ph ps : wff} :
  ⊦ wi (wb ph ps) (wi ps ph) :=
@sylbi (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph)))) (wi ps ph)
  (@dfbi1 ph ps)
  (@simprim (wi ph ps) (wi ps ph))


/-- Commutative law for the biconditional. (Contributed by Wolf Lammen, 10-Nov-2012.) -/
theorem bicom1 {ph ps : wff} :
  ⊦ wi (wb ph ps) (wb ps ph) :=
@impbid (wb ph ps) ps ph
  (@biimpr ph ps)
  (@biimp ph ps)


/-- Commutative law for the biconditional. Theorem *4.21 of [WhiteheadRussell] p. 117. (Contributed
by NM, 11-May-1993.) -/
theorem bicom {ph ps : wff} :
  ⊦ wb (wb ph ps) (wb ps ph) :=
@impbii (wb ph ps) (wb ps ph)
  (@bicom1 ph ps)
  (@bicom1 ps ph)


/-- Commute two sides of a biconditional in a deduction. (Contributed by NM, 14-May-1993.) -/
theorem bicomd {ph ps ch : wff}
  (bicomd_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb ch ps) :=
@sylib ph (wb ps ch) (wb ch ps)
  bicomd_1
  (@bicom ps ch)


/-- Inference from commutative law for logical equivalence. (Contributed by NM, 3-Jan-1993.) -/
theorem bicomi {ph ps : wff}
  (bicomi_1 : ⊦ wb ph ps) :
  ⊦ wb ps ph :=
@ax_mp (wb ph ps) (wb ps ph)
  bicomi_1
  (@bicom1 ph ps)


/-- Infer an equivalence from two implications. (Contributed by NM, 6-Mar-2007.) -/
theorem impbid1 {ph ps ch : wff}
  (impbid1_1 : ⊦ wi ph (wi ps ch))
  (impbid1_2 : ⊦ wi ch ps) :
  ⊦ wi ph (wb ps ch) :=
@impbid ph ps ch
  impbid1_1
  (@a1i (wi ch ps) ph
    impbid1_2)


/-- Infer an equivalence from two implications. (Contributed by NM, 6-Mar-2007.) (Proof shortened by
Wolf Lammen, 27-Sep-2013.) -/
theorem impbid2 {ph ps ch : wff}
  (impbid2_1 : ⊦ wi ps ch)
  (impbid2_2 : ⊦ wi ph (wi ch ps)) :
  ⊦ wi ph (wb ps ch) :=
@bicomd ph ch ps
  (@impbid1 ph ch ps
    impbid2_2
    impbid2_1)


/-- A variation on ~ impbid with contraposition. (Contributed by Jeff Hankins, 3-Jul-2009.) -/
theorem impcon4bid {ph ps ch : wff}
  (impcon4bid_1 : ⊦ wi ph (wi ps ch))
  (impcon4bid_2 : ⊦ wi ph (wi (wn ps) (wn ch))) :
  ⊦ wi ph (wb ps ch) :=
@impbid ph ps ch
  impcon4bid_1
  (@con4d ph ps ch
    impcon4bid_2)


/-- Infer a converse implication from a logical equivalence. Inference associated with ~ biimpr .
(Contributed by NM, 29-Dec-1992.) (Proof shortened by Wolf Lammen, 16-Sep-2013.) -/
theorem biimpri {ph ps : wff}
  (biimpri_1 : ⊦ wb ph ps) :
  ⊦ wi ps ph :=
@biimpi ps ph
  (@bicomi ph ps
    biimpri_1)


/-- Deduce an implication from a logical equivalence. Deduction associated with ~ biimp and ~ biimpi
. (Contributed by NM, 11-Jan-1993.) -/
theorem biimpd {ph ps ch : wff}
  (biimpd_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wi ps ch) :=
@syl ph (wb ps ch) (wi ps ch)
  biimpd_1
  (@biimp ps ch)


/-- An inference from a biconditional, related to modus ponens. (Contributed by NM, 11-May-1993.) -/
theorem mpbi {ph ps : wff}
  (mpbi_min : ⊦ ph)
  (mpbi_maj : ⊦ wb ph ps) :
  ⊦ ps :=
@ax_mp ph ps
  mpbi_min
  (@biimpi ph ps
    mpbi_maj)


/-- An inference from a biconditional, related to modus ponens. (Contributed by NM, 28-Dec-1992.) -/
theorem mpbir {ph ps : wff}
  (mpbir_min : ⊦ ps)
  (mpbir_maj : ⊦ wb ph ps) :
  ⊦ ph :=
@ax_mp ps ph
  mpbir_min
  (@biimpri ph ps
    mpbir_maj)


/-- A deduction from a biconditional, related to modus ponens. (Contributed by NM, 21-Jun-1993.) -/
theorem mpbid {ph ps ch : wff}
  (mpbid_min : ⊦ wi ph ps)
  (mpbid_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph ch :=
@mpd ph ps ch
  mpbid_min
  (@biimpd ph ps ch
    mpbid_maj)


/-- An inference from a nested biconditional, related to modus ponens. (Contributed by NM,
16-May-1993.) (Proof shortened by Wolf Lammen, 25-Oct-2012.) -/
theorem mpbii {ph ps ch : wff}
  (mpbii_min : ⊦ ps)
  (mpbii_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph ch :=
@mpbid ph ps ch
  (@a1i ps ph
    mpbii_min)
  mpbii_maj


/-- A mixed syllogism inference from an implication and a biconditional. Useful for substituting a
consequent with a definition. (Contributed by NM, 3-Jan-1993.) -/
theorem sylibr {ph ps ch : wff}
  (sylibr_1 : ⊦ wi ph ps)
  (sylibr_2 : ⊦ wb ch ps) :
  ⊦ wi ph ch :=
@syl ph ps ch
  sylibr_1
  (@biimpri ch ps
    sylibr_2)


/-- A mixed syllogism inference from a biconditional and an implication. (Contributed by NM,
3-Jan-1993.) -/
theorem sylbir {ph ps ch : wff}
  (sylbir_1 : ⊦ wb ps ph)
  (sylbir_2 : ⊦ wi ps ch) :
  ⊦ wi ph ch :=
@syl ph ps ch
  (@biimpri ps ph
    sylbir_1)
  sylbir_2


/-- A mixed syllogism inference from two biconditionals. Note on the various syllogism-like
statements in set.mm. The hypothetical syllogism ~ syl infers an implication from two implications
(and there are ~ 3syl and ~ 4syl for chaining more inferences). There are four inferences inferring
an implication from one implication and one biconditional: ~ sylbi , ~ sylib , ~ sylbir , ~ sylibr ;
four inferences inferring an implication from two biconditionals: ~ sylbb , ~ sylbbr , ~ sylbb1 , ~
sylbb2 ; four inferences inferring a biconditional from two biconditionals: ~ bitri , ~ bitr2i , ~
bitr3i , ~ bitr4i (and more for chaining more biconditionals). There are also closed forms and
deduction versions of these, like, among many others, ~ syld , ~ syl5 , ~ syl6 , ~ mpbid , ~ bitrd ,
~ syl5bb , ~ bitrdi and variants. (Contributed by BJ, 21-Apr-2019.) -/
theorem sylbbr {ph ps ch : wff}
  (sylbbr_1 : ⊦ wb ph ps)
  (sylbbr_2 : ⊦ wb ps ch) :
  ⊦ wi ch ph :=
@sylibr ch ps ph
  (@biimpri ps ch
    sylbbr_2)
  sylbbr_1


/-- A mixed syllogism inference from two biconditionals. (Contributed by BJ, 21-Apr-2019.) -/
theorem sylbb2 {ph ps ch : wff}
  (sylbb2_1 : ⊦ wb ph ps)
  (sylbb2_2 : ⊦ wb ch ps) :
  ⊦ wi ph ch :=
@sylbi ph ps ch
  sylbb2_1
  (@biimpri ch ps
    sylbb2_2)


/-- A syllogism deduction. (Contributed by NM, 3-Aug-1994.) -/
theorem sylibd {ph ps ch th : wff}
  (sylibd_1 : ⊦ wi ph (wi ps ch))
  (sylibd_2 : ⊦ wi ph (wb ch th)) :
  ⊦ wi ph (wi ps th) :=
@syld ph ps ch th
  sylibd_1
  (@biimpd ph ch th
    sylibd_2)


/-- A syllogism deduction. (Contributed by NM, 3-Aug-1994.) -/
theorem sylbid {ph ps ch th : wff}
  (sylbid_1 : ⊦ wi ph (wb ps ch))
  (sylbid_2 : ⊦ wi ph (wi ch th)) :
  ⊦ wi ph (wi ps th) :=
@syld ph ps ch th
  (@biimpd ph ps ch
    sylbid_1)
  sylbid_2


/-- A deduction from a biconditional, related to modus ponens. (Contributed by NM, 9-Aug-1994.) -/
theorem mpbidi {ph ps ch th : wff}
  (mpbidi_min : ⊦ wi th (wi ph ps))
  (mpbidi_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi th (wi ph ch) :=
@sylcom th ph ps ch
  mpbidi_min
  (@biimpd ph ps ch
    mpbidi_maj)


/-- A mixed syllogism inference from a nested implication and a biconditional. Useful for
substituting an embedded antecedent with a definition. (Contributed by NM, 12-Jan-1993.) -/
theorem syl5bi {ph ps ch th : wff}
  (syl5bi_1 : ⊦ wb ph ps)
  (syl5bi_2 : ⊦ wi ch (wi ps th)) :
  ⊦ wi ch (wi ph th) :=
@syl5 ph ps ch th
  (@biimpi ph ps
    syl5bi_1)
  syl5bi_2


/-- A mixed syllogism inference from a nested implication and a biconditional. (Contributed by NM,
21-Jun-1993.) -/
theorem syl5bir {ph ps ch th : wff}
  (syl5bir_1 : ⊦ wb ps ph)
  (syl5bir_2 : ⊦ wi ch (wi ps th)) :
  ⊦ wi ch (wi ph th) :=
@syl5 ph ps ch th
  (@biimpri ps ph
    syl5bir_1)
  syl5bir_2


/-- A mixed syllogism inference. (Contributed by NM, 12-Jan-1993.) -/
theorem syl5ib {ph ps ch th : wff}
  (syl5ib_1 : ⊦ wi ph ps)
  (syl5ib_2 : ⊦ wi ch (wb ps th)) :
  ⊦ wi ch (wi ph th) :=
@syl5 ph ps ch th
  syl5ib_1
  (@biimpd ch ps th
    syl5ib_2)


/-- A mixed syllogism inference. (Contributed by NM, 19-Jun-2007.) -/
theorem syl5ibcom {ph ps ch th : wff}
  (syl5ib_1 : ⊦ wi ph ps)
  (syl5ib_2 : ⊦ wi ch (wb ps th)) :
  ⊦ wi ph (wi ch th) :=
@com12 ch ph th
  (@syl5ib ph ps ch th
    syl5ib_1
    syl5ib_2)


/-- A mixed syllogism inference. (Contributed by NM, 3-Apr-1994.) -/
theorem syl5ibr {ph ps ch th : wff}
  (syl5ibr_1 : ⊦ wi ph th)
  (syl5ibr_2 : ⊦ wi ch (wb ps th)) :
  ⊦ wi ch (wi ph ps) :=
@syl5ib ph th ch ps
  syl5ibr_1
  (@bicomd ch ps th
    syl5ibr_2)


/-- A mixed syllogism inference. (Contributed by NM, 20-Jun-2007.) -/
theorem syl5ibrcom {ph ps ch th : wff}
  (syl5ibr_1 : ⊦ wi ph th)
  (syl5ibr_2 : ⊦ wi ch (wb ps th)) :
  ⊦ wi ph (wi ch ps) :=
@com12 ch ph ps
  (@syl5ibr ph ps ch th
    syl5ibr_1
    syl5ibr_2)


/-- Deduce a converse implication from a logical equivalence. Deduction associated with ~ biimpr and
~ biimpri . (Contributed by NM, 11-Jan-1993.) (Proof shortened by Wolf Lammen, 22-Sep-2013.) -/
theorem biimprd {ph ps ch : wff}
  (biimprd_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wi ch ps) :=
@syl5ibr ch ps ph ch
  (@id ch)
  biimprd_1


/-- Deduce a commuted implication from a logical equivalence. (Contributed by NM, 3-May-1994.)
(Proof shortened by Wolf Lammen, 22-Sep-2013.) -/
theorem biimpcd {ph ps ch : wff}
  (biimpcd_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ps (wi ph ch) :=
@syl5ibcom ps ps ph ch
  (@id ps)
  biimpcd_1


/-- Deduce a converse commuted implication from a logical equivalence. (Contributed by NM,
3-May-1994.) (Proof shortened by Wolf Lammen, 20-Dec-2013.) -/
theorem biimprcd {ph ps ch : wff}
  (biimpcd_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ch (wi ph ps) :=
@syl5ibrcom ch ps ph ch
  (@id ch)
  biimpcd_1


/-- A mixed syllogism inference from a nested implication and a biconditional. (Contributed by NM,
21-Jun-1993.) -/
theorem syl6ib {ph ps ch th : wff}
  (syl6ib_1 : ⊦ wi ph (wi ps ch))
  (syl6ib_2 : ⊦ wb ch th) :
  ⊦ wi ph (wi ps th) :=
@syl6 ph ps ch th
  syl6ib_1
  (@biimpi ch th
    syl6ib_2)


/-- A mixed syllogism inference from a nested implication and a biconditional. Useful for
substituting an embedded consequent with a definition. (Contributed by NM, 10-Jan-1993.) -/
theorem syl6ibr {ph ps ch th : wff}
  (syl6ibr_1 : ⊦ wi ph (wi ps ch))
  (syl6ibr_2 : ⊦ wb th ch) :
  ⊦ wi ph (wi ps th) :=
@syl6 ph ps ch th
  syl6ibr_1
  (@biimpri th ch
    syl6ibr_2)


/-- A mixed syllogism inference. (Contributed by NM, 2-Jan-1994.) -/
theorem syl6bi {ph ps ch th : wff}
  (syl6bi_1 : ⊦ wi ph (wb ps ch))
  (syl6bi_2 : ⊦ wi ch th) :
  ⊦ wi ph (wi ps th) :=
@syl6 ph ps ch th
  (@biimpd ph ps ch
    syl6bi_1)
  syl6bi_2


/-- A mixed syllogism inference. (Contributed by NM, 18-May-1994.) -/
theorem syl6bir {ph ps ch th : wff}
  (syl6bir_1 : ⊦ wi ph (wb ch ps))
  (syl6bir_2 : ⊦ wi ch th) :
  ⊦ wi ph (wi ps th) :=
@syl6 ph ps ch th
  (@biimprd ph ch ps
    syl6bir_1)
  syl6bir_2


/-- A mixed syllogism inference from a doubly nested implication and a biconditional. (Contributed
by NM, 14-May-1993.) -/
theorem syl7bi {ph ps ch th ta : wff}
  (syl7bi_1 : ⊦ wb ph ps)
  (syl7bi_2 : ⊦ wi ch (wi th (wi ps ta))) :
  ⊦ wi ch (wi th (wi ph ta)) :=
@syl7 ph ps ch th ta
  (@biimpi ph ps
    syl7bi_1)
  syl7bi_2


/-- A deduction from a biconditional, related to modus ponens. (Contributed by NM, 5-Aug-1993.) -/
theorem mpbird {ph ps ch : wff}
  (mpbird_min : ⊦ wi ph ch)
  (mpbird_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph ps :=
@mpd ph ch ps
  mpbird_min
  (@biimprd ph ps ch
    mpbird_maj)


/-- An inference from a nested biconditional, related to modus ponens. (Contributed by NM,
21-Jun-1993.) (Proof shortened by Wolf Lammen, 25-Oct-2012.) -/
theorem mpbiri {ph ps ch : wff}
  (mpbiri_min : ⊦ ch)
  (mpbiri_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph ps :=
@mpbird ph ps ch
  (@a1i ch ph
    mpbiri_min)
  mpbiri_maj


/-- A syllogism deduction. (Contributed by NM, 3-Aug-1994.) -/
theorem sylibrd {ph ps ch th : wff}
  (sylibrd_1 : ⊦ wi ph (wi ps ch))
  (sylibrd_2 : ⊦ wi ph (wb th ch)) :
  ⊦ wi ph (wi ps th) :=
@syld ph ps ch th
  sylibrd_1
  (@biimprd ph th ch
    sylibrd_2)


/-- A syllogism deduction. (Contributed by NM, 3-Aug-1994.) -/
theorem sylbird {ph ps ch th : wff}
  (sylbird_1 : ⊦ wi ph (wb ch ps))
  (sylbird_2 : ⊦ wi ph (wi ch th)) :
  ⊦ wi ph (wi ps th) :=
@syld ph ps ch th
  (@biimprd ph ch ps
    sylbird_1)
  sylbird_2


/-- Principle of identity for logical equivalence. Theorem *4.2 of [WhiteheadRussell] p. 117. This
is part of Frege's eighth axiom per Proposition 54 of [Frege1879] p. 50; see also ~ eqid .
(Contributed by NM, 2-Jun-1993.) -/
theorem biid {ph : wff} :
  ⊦ wb ph ph :=
@impbii ph ph
  (@id ph)
  (@id ph)


/-- Principle of identity with antecedent. (Contributed by NM, 25-Nov-1995.) -/
theorem biidd {ph ps : wff} :
  ⊦ wi ph (wb ps ps) :=
@a1i (wb ps ps) ph
  (@biid ps)


/-- Two propositions are equivalent if they are both true. Closed form of ~ 2th . Equivalent to a ~
biimp -like version of the xor-connective. This theorem stays true, no matter how you permute its
operands. This is evident from its sharper version ` ( ph <-> ( ps <-> ( ph <-> ps ) ) ) ` .
(Contributed by Wolf Lammen, 12-May-2013.) -/
theorem pm5_1im {ph ps : wff} :
  ⊦ wi ph (wi ps (wb ph ps)) :=
@impbid21d ph ps ph ps
  (@ax_1 ps ph)
  (@ax_1 ph ps)


/-- Two truths are equivalent. (Contributed by NM, 18-Aug-1993.) -/
theorem «2th» {ph ps : wff}
  («2th_1» : ⊦ ph)
  («2th_2» : ⊦ ps) :
  ⊦ wb ph ps :=
@impbii ph ps
  (@a1i ps ph
    «2th_2»)
  (@a1i ph ps
    «2th_1»)


/-- Two truths are equivalent. Deduction form. (Contributed by NM, 3-Jun-2012.) -/
theorem «2thd» {ph ps ch : wff}
  («2thd_1» : ⊦ wi ph ps)
  («2thd_2» : ⊦ wi ph ch) :
  ⊦ wi ph (wb ps ch) :=
@sylc ph ps ch (wb ps ch)
  «2thd_1»
  «2thd_2»
  (@pm5_1im ps ch)


/-- Inference that converts a biconditional implied by one of its arguments, into an implication.
(Contributed by NM, 17-Oct-2003.) -/
theorem ibi {ph ps : wff}
  (ibi_1 : ⊦ wi ph (wb ph ps)) :
  ⊦ wi ph ps :=
@mpbid ph ph ps
  (@id ph)
  ibi_1


/-- Inference that converts a biconditional implied by one of its arguments, into an implication.
(Contributed by NM, 22-Jul-2004.) -/
theorem ibir {ph ps : wff}
  (ibir_1 : ⊦ wi ph (wb ps ph)) :
  ⊦ wi ph ps :=
@ibi ph ps
  (@bicomd ph ps ph
    ibir_1)


/-- Deduction that converts a biconditional implied by one of its arguments, into an implication.
Deduction associated with ~ ibi . (Contributed by NM, 26-Jun-2004.) -/
theorem ibd {ph ps ch : wff}
  (ibd_1 : ⊦ wi ph (wi ps (wb ps ch))) :
  ⊦ wi ph (wi ps ch) :=
@syli ps ph (wb ps ch) ch
  ibd_1
  (@biimp ps ch)


/-- Distribution of implication over biconditional. Theorem *5.74 of [WhiteheadRussell] p. 126.
(Contributed by NM, 1-Aug-1994.) (Proof shortened by Wolf Lammen, 11-Apr-2013.) -/
theorem pm5_74 {ph ps ch : wff} :
  ⊦ wb (wi ph (wb ps ch)) (wb (wi ph ps) (wi ph ch)) :=
@impbii (wi ph (wb ps ch)) (wb (wi ph ps) (wi ph ch))
  (@impbid (wi ph (wb ps ch)) (wi ph ps) (wi ph ch)
    (@imim3i (wb ps ch) ps ch ph
      (@biimp ps ch))
    (@imim3i (wb ps ch) ch ps ph
      (@biimpr ps ch)))
  (@impbidd (wb (wi ph ps) (wi ph ch)) ph ps ch
    (@pm2_86d (wb (wi ph ps) (wi ph ch)) ph ps ch
      (@biimp (wi ph ps) (wi ph ch)))
    (@pm2_86d (wb (wi ph ps) (wi ph ch)) ph ch ps
      (@biimpr (wi ph ps) (wi ph ch))))


/-- Distribution of implication over biconditional (inference form). (Contributed by NM,
1-Aug-1994.) -/
theorem pm5_74i {ph ps ch : wff}
  (pm5_74i_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wb (wi ph ps) (wi ph ch) :=
@mpbi (wi ph (wb ps ch)) (wb (wi ph ps) (wi ph ch))
  pm5_74i_1
  (@pm5_74 ph ps ch)


/-- Distribution of implication over biconditional (reverse inference form). (Contributed by NM,
1-Aug-1994.) -/
theorem pm5_74ri {ph ps ch : wff}
  (pm5_74ri_1 : ⊦ wb (wi ph ps) (wi ph ch)) :
  ⊦ wi ph (wb ps ch) :=
@mpbir (wi ph (wb ps ch)) (wb (wi ph ps) (wi ph ch))
  pm5_74ri_1
  (@pm5_74 ph ps ch)


/-- Distribution of implication over biconditional (deduction form). (Contributed by NM,
21-Mar-1996.) -/
theorem pm5_74d {ph ps ch th : wff}
  (pm5_74d_1 : ⊦ wi ph (wi ps (wb ch th))) :
  ⊦ wi ph (wb (wi ps ch) (wi ps th)) :=
@sylib ph (wi ps (wb ch th)) (wb (wi ps ch) (wi ps th))
  pm5_74d_1
  (@pm5_74 ps ch th)


/-- An inference from transitive law for logical equivalence. (Contributed by NM, 3-Jan-1993.)
(Proof shortened by Wolf Lammen, 13-Oct-2012.) -/
theorem bitri {ph ps ch : wff}
  (bitri_1 : ⊦ wb ph ps)
  (bitri_2 : ⊦ wb ps ch) :
  ⊦ wb ph ch :=
@impbii ph ch
  (@sylbb ph ps ch
    bitri_1
    bitri_2)
  (@sylbbr ph ps ch
    bitri_1
    bitri_2)


/-- An inference from transitive law for logical equivalence. (Contributed by NM, 12-Mar-1993.) -/
theorem bitr2i {ph ps ch : wff}
  (bitr2i_1 : ⊦ wb ph ps)
  (bitr2i_2 : ⊦ wb ps ch) :
  ⊦ wb ch ph :=
@bicomi ph ch
  (@bitri ph ps ch
    bitr2i_1
    bitr2i_2)


/-- An inference from transitive law for logical equivalence. (Contributed by NM, 2-Jun-1993.) -/
theorem bitr3i {ph ps ch : wff}
  (bitr3i_1 : ⊦ wb ps ph)
  (bitr3i_2 : ⊦ wb ps ch) :
  ⊦ wb ph ch :=
@bitri ph ps ch
  (@bicomi ps ph
    bitr3i_1)
  bitr3i_2


/-- An inference from transitive law for logical equivalence. (Contributed by NM, 3-Jan-1993.) -/
theorem bitr4i {ph ps ch : wff}
  (bitr4i_1 : ⊦ wb ph ps)
  (bitr4i_2 : ⊦ wb ch ps) :
  ⊦ wb ph ch :=
@bitri ph ps ch
  bitr4i_1
  (@bicomi ch ps
    bitr4i_2)


/-- Deduction form of ~ bitri . (Contributed by NM, 12-Mar-1993.) (Proof shortened by Wolf Lammen,
14-Apr-2013.) -/
theorem bitrd {ph ps ch th : wff}
  (bitrd_1 : ⊦ wi ph (wb ps ch))
  (bitrd_2 : ⊦ wi ph (wb ch th)) :
  ⊦ wi ph (wb ps th) :=
@pm5_74ri ph ps th
  (@bitri (wi ph ps) (wi ph ch) (wi ph th)
    (@pm5_74i ph ps ch
      bitrd_1)
    (@pm5_74i ph ch th
      bitrd_2))


/-- Deduction form of ~ bitr2i . (Contributed by NM, 9-Jun-2004.) -/
theorem bitr2d {ph ps ch th : wff}
  (bitr2d_1 : ⊦ wi ph (wb ps ch))
  (bitr2d_2 : ⊦ wi ph (wb ch th)) :
  ⊦ wi ph (wb th ps) :=
@bicomd ph ps th
  (@bitrd ph ps ch th
    bitr2d_1
    bitr2d_2)


/-- Deduction form of ~ bitr3i . (Contributed by NM, 14-May-1993.) -/
theorem bitr3d {ph ps ch th : wff}
  (bitr3d_1 : ⊦ wi ph (wb ps ch))
  (bitr3d_2 : ⊦ wi ph (wb ps th)) :
  ⊦ wi ph (wb ch th) :=
@bitrd ph ch ps th
  (@bicomd ph ps ch
    bitr3d_1)
  bitr3d_2


/-- Deduction form of ~ bitr4i . (Contributed by NM, 30-Jun-1993.) -/
theorem bitr4d {ph ps ch th : wff}
  (bitr4d_1 : ⊦ wi ph (wb ps ch))
  (bitr4d_2 : ⊦ wi ph (wb th ch)) :
  ⊦ wi ph (wb ps th) :=
@bitrd ph ps ch th
  bitr4d_1
  (@bicomd ph th ch
    bitr4d_2)


/-- A syllogism inference from two biconditionals. (Contributed by NM, 12-Mar-1993.) -/
theorem syl5bb {ph ps ch th : wff}
  (syl5bb_1 : ⊦ wb ph ps)
  (syl5bb_2 : ⊦ wi ch (wb ps th)) :
  ⊦ wi ch (wb ph th) :=
@bitrd ch ph ps th
  (@a1i (wb ph ps) ch
    syl5bb_1)
  syl5bb_2


/-- A syllogism inference from two biconditionals. (Contributed by NM, 1-Aug-1993.) -/
theorem syl5rbb {ph ps ch th : wff}
  (syl5rbb_1 : ⊦ wb ph ps)
  (syl5rbb_2 : ⊦ wi ch (wb ps th)) :
  ⊦ wi ch (wb th ph) :=
@bicomd ch ph th
  (@syl5bb ph ps ch th
    syl5rbb_1
    syl5rbb_2)


/-- A syllogism inference from two biconditionals. (Contributed by NM, 5-Aug-1993.) -/
theorem bitr3id {ph ps ch th : wff}
  (bitr3id_1 : ⊦ wb ps ph)
  (bitr3id_2 : ⊦ wi ch (wb ps th)) :
  ⊦ wi ch (wb ph th) :=
@syl5bb ph ps ch th
  (@bicomi ps ph
    bitr3id_1)
  bitr3id_2


/-- A syllogism inference from two biconditionals. (Contributed by NM, 25-Nov-1994.) -/
theorem bitr3di {ph ps ch th : wff}
  (bitr3di_1 : ⊦ wi ph (wb ps ch))
  (bitr3di_2 : ⊦ wb ps th) :
  ⊦ wi ph (wb ch th) :=
@syl5rbb th ps ph ch
  (@bicomi ps th
    bitr3di_2)
  bitr3di_1


/-- A syllogism inference from two biconditionals. (Contributed by NM, 12-Mar-1993.) -/
theorem bitrdi {ph ps ch th : wff}
  (bitrdi_1 : ⊦ wi ph (wb ps ch))
  (bitrdi_2 : ⊦ wb ch th) :
  ⊦ wi ph (wb ps th) :=
@bitrd ph ps ch th
  bitrdi_1
  (@a1i (wb ch th) ph
    bitrdi_2)


/-- A syllogism inference from two biconditionals. (Contributed by NM, 5-Aug-1993.) -/
theorem bitr2di {ph ps ch th : wff}
  (bitr2di_1 : ⊦ wi ph (wb ps ch))
  (bitr2di_2 : ⊦ wb ch th) :
  ⊦ wi ph (wb th ps) :=
@bicomd ph ps th
  (@bitrdi ph ps ch th
    bitr2di_1
    bitr2di_2)


/-- A syllogism inference from two biconditionals. (Contributed by NM, 12-Mar-1993.) -/
theorem bitr4di {ph ps ch th : wff}
  (bitr4di_1 : ⊦ wi ph (wb ps ch))
  (bitr4di_2 : ⊦ wb th ch) :
  ⊦ wi ph (wb ps th) :=
@bitrdi ph ps ch th
  bitr4di_1
  (@bicomi th ch
    bitr4di_2)


/-- A syllogism inference from two biconditionals. (Contributed by NM, 25-Nov-1994.) -/
theorem bitr4id {ph ps ch th : wff}
  (bitr4id_2 : ⊦ wb ps ch)
  (bitr4id_1 : ⊦ wi ph (wb th ch)) :
  ⊦ wi ph (wb ps th) :=
@bitr2di ph th ch ps
  bitr4id_1
  (@bicomi ps ch
    bitr4id_2)


/-- A mixed syllogism inference, useful for removing a definition from both sides of an implication.
(Contributed by NM, 10-Aug-1994.) -/
theorem «3imtr3i» {ph ps ch th : wff}
  («3imtr3_1» : ⊦ wi ph ps)
  («3imtr3_2» : ⊦ wb ph ch)
  («3imtr3_3» : ⊦ wb ps th) :
  ⊦ wi ch th :=
@sylib ch ps th
  (@sylbir ch ph ps
    «3imtr3_2»
    «3imtr3_1»)
  «3imtr3_3»


/-- A mixed syllogism inference, useful for applying a definition to both sides of an implication.
(Contributed by NM, 3-Jan-1993.) -/
theorem «3imtr4i» {ph ps ch th : wff}
  («3imtr4_1» : ⊦ wi ph ps)
  («3imtr4_2» : ⊦ wb ch ph)
  («3imtr4_3» : ⊦ wb th ps) :
  ⊦ wi ch th :=
@sylibr ch ps th
  (@sylbi ch ph ps
    «3imtr4_2»
    «3imtr4_1»)
  «3imtr4_3»


/-- More general version of ~ 3imtr3i . Useful for converting conditional definitions in a formula.
(Contributed by NM, 8-Apr-1996.) -/
theorem «3imtr3d» {ph ps ch th ta : wff}
  («3imtr3d_1» : ⊦ wi ph (wi ps ch))
  («3imtr3d_2» : ⊦ wi ph (wb ps th))
  («3imtr3d_3» : ⊦ wi ph (wb ch ta)) :
  ⊦ wi ph (wi th ta) :=
@sylbird ph th ps ta
  «3imtr3d_2»
  (@sylibd ph ps ch ta
    «3imtr3d_1»
    «3imtr3d_3»)


/-- More general version of ~ 3imtr4i . Useful for converting conditional definitions in a formula.
(Contributed by NM, 26-Oct-1995.) -/
theorem «3imtr4d» {ph ps ch th ta : wff}
  («3imtr4d_1» : ⊦ wi ph (wi ps ch))
  («3imtr4d_2» : ⊦ wi ph (wb th ps))
  («3imtr4d_3» : ⊦ wi ph (wb ta ch)) :
  ⊦ wi ph (wi th ta) :=
@sylbid ph th ps ta
  «3imtr4d_2»
  (@sylibrd ph ps ch ta
    «3imtr4d_1»
    «3imtr4d_3»)


/-- More general version of ~ 3imtr3i . Useful for converting definitions in a formula. (Contributed
by NM, 20-May-1996.) (Proof shortened by Wolf Lammen, 20-Dec-2013.) -/
theorem «3imtr3g» {ph ps ch th ta : wff}
  («3imtr3g_1» : ⊦ wi ph (wi ps ch))
  («3imtr3g_2» : ⊦ wb ps th)
  («3imtr3g_3» : ⊦ wb ch ta) :
  ⊦ wi ph (wi th ta) :=
@syl6ib ph th ch ta
  (@syl5bir th ps ph ch
    «3imtr3g_2»
    «3imtr3g_1»)
  «3imtr3g_3»


/-- More general version of ~ 3imtr4i . Useful for converting definitions in a formula. (Contributed
by NM, 20-May-1996.) (Proof shortened by Wolf Lammen, 20-Dec-2013.) -/
theorem «3imtr4g» {ph ps ch th ta : wff}
  («3imtr4g_1» : ⊦ wi ph (wi ps ch))
  («3imtr4g_2» : ⊦ wb th ps)
  («3imtr4g_3» : ⊦ wb ta ch) :
  ⊦ wi ph (wi th ta) :=
@syl6ibr ph th ch ta
  (@syl5bi th ps ph ch
    «3imtr4g_2»
    «3imtr4g_1»)
  «3imtr4g_3»


/-- A chained inference from transitive law for logical equivalence. (Contributed by NM,
3-Jan-1993.) -/
theorem «3bitri» {ph ps ch th : wff}
  («3bitri_1» : ⊦ wb ph ps)
  («3bitri_2» : ⊦ wb ps ch)
  («3bitri_3» : ⊦ wb ch th) :
  ⊦ wb ph th :=
@bitri ph ps th
  «3bitri_1»
  (@bitri ps ch th
    «3bitri_2»
    «3bitri_3»)


/-- A chained inference from transitive law for logical equivalence. (Contributed by NM,
4-Aug-2006.) -/
theorem «3bitrri» {ph ps ch th : wff}
  («3bitri_1» : ⊦ wb ph ps)
  («3bitri_2» : ⊦ wb ps ch)
  («3bitri_3» : ⊦ wb ch th) :
  ⊦ wb th ph :=
@bitr3i th ch ph
  «3bitri_3»
  (@bitr2i ph ps ch
    «3bitri_1»
    «3bitri_2»)


/-- A chained inference from transitive law for logical equivalence. (Contributed by NM,
4-Aug-2006.) -/
theorem «3bitr2i» {ph ps ch th : wff}
  («3bitr2i_1» : ⊦ wb ph ps)
  («3bitr2i_2» : ⊦ wb ch ps)
  («3bitr2i_3» : ⊦ wb ch th) :
  ⊦ wb ph th :=
@bitri ph ch th
  (@bitr4i ph ps ch
    «3bitr2i_1»
    «3bitr2i_2»)
  «3bitr2i_3»


/-- A chained inference from transitive law for logical equivalence. (Contributed by NM,
4-Aug-2006.) -/
theorem «3bitr2ri» {ph ps ch th : wff}
  («3bitr2i_1» : ⊦ wb ph ps)
  («3bitr2i_2» : ⊦ wb ch ps)
  («3bitr2i_3» : ⊦ wb ch th) :
  ⊦ wb th ph :=
@bitr2i ph ch th
  (@bitr4i ph ps ch
    «3bitr2i_1»
    «3bitr2i_2»)
  «3bitr2i_3»


/-- A chained inference from transitive law for logical equivalence. (Contributed by NM,
19-Aug-1993.) -/
theorem «3bitr3i» {ph ps ch th : wff}
  («3bitr3i_1» : ⊦ wb ph ps)
  («3bitr3i_2» : ⊦ wb ph ch)
  («3bitr3i_3» : ⊦ wb ps th) :
  ⊦ wb ch th :=
@bitri ch ps th
  (@bitr3i ch ph ps
    «3bitr3i_2»
    «3bitr3i_1»)
  «3bitr3i_3»


/-- A chained inference from transitive law for logical equivalence. (Contributed by NM,
21-Jun-1993.) -/
theorem «3bitr3ri» {ph ps ch th : wff}
  («3bitr3i_1» : ⊦ wb ph ps)
  («3bitr3i_2» : ⊦ wb ph ch)
  («3bitr3i_3» : ⊦ wb ps th) :
  ⊦ wb th ch :=
@bitr3i th ps ch
  «3bitr3i_3»
  (@bitr3i ps ph ch
    «3bitr3i_1»
    «3bitr3i_2»)


/-- A chained inference from transitive law for logical equivalence. This inference is frequently
used to apply a definition to both sides of a logical equivalence. (Contributed by NM, 3-Jan-1993.)
-/
theorem «3bitr4i» {ph ps ch th : wff}
  («3bitr4i_1» : ⊦ wb ph ps)
  («3bitr4i_2» : ⊦ wb ch ph)
  («3bitr4i_3» : ⊦ wb th ps) :
  ⊦ wb ch th :=
@bitri ch ph th
  «3bitr4i_2»
  (@bitr4i ph ps th
    «3bitr4i_1»
    «3bitr4i_3»)


/-- A chained inference from transitive law for logical equivalence. (Contributed by NM,
2-Sep-1995.) -/
theorem «3bitr4ri» {ph ps ch th : wff}
  («3bitr4i_1» : ⊦ wb ph ps)
  («3bitr4i_2» : ⊦ wb ch ph)
  («3bitr4i_3» : ⊦ wb th ps) :
  ⊦ wb th ch :=
@bitr2i ch ph th
  «3bitr4i_2»
  (@bitr4i ph ps th
    «3bitr4i_1»
    «3bitr4i_3»)


/-- Deduction from transitivity of biconditional. (Contributed by NM, 13-Aug-1999.) -/
theorem «3bitrd» {ph ps ch th ta : wff}
  («3bitrd_1» : ⊦ wi ph (wb ps ch))
  («3bitrd_2» : ⊦ wi ph (wb ch th))
  («3bitrd_3» : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb ps ta) :=
@bitrd ph ps th ta
  (@bitrd ph ps ch th
    «3bitrd_1»
    «3bitrd_2»)
  «3bitrd_3»


/-- Deduction from transitivity of biconditional. (Contributed by NM, 4-Aug-2006.) -/
theorem «3bitrrd» {ph ps ch th ta : wff}
  («3bitrd_1» : ⊦ wi ph (wb ps ch))
  («3bitrd_2» : ⊦ wi ph (wb ch th))
  («3bitrd_3» : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb ta ps) :=
@bitr3d ph th ta ps
  «3bitrd_3»
  (@bitr2d ph ps ch th
    «3bitrd_1»
    «3bitrd_2»)


/-- Deduction from transitivity of biconditional. (Contributed by NM, 4-Aug-2006.) -/
theorem «3bitr2d» {ph ps ch th ta : wff}
  («3bitr2d_1» : ⊦ wi ph (wb ps ch))
  («3bitr2d_2» : ⊦ wi ph (wb th ch))
  («3bitr2d_3» : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb ps ta) :=
@bitrd ph ps th ta
  (@bitr4d ph ps ch th
    «3bitr2d_1»
    «3bitr2d_2»)
  «3bitr2d_3»


/-- Deduction from transitivity of biconditional. (Contributed by NM, 4-Aug-2006.) -/
theorem «3bitr2rd» {ph ps ch th ta : wff}
  («3bitr2d_1» : ⊦ wi ph (wb ps ch))
  («3bitr2d_2» : ⊦ wi ph (wb th ch))
  («3bitr2d_3» : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb ta ps) :=
@bitr2d ph ps th ta
  (@bitr4d ph ps ch th
    «3bitr2d_1»
    «3bitr2d_2»)
  «3bitr2d_3»


/-- Deduction from transitivity of biconditional. Useful for converting conditional definitions in a
formula. (Contributed by NM, 24-Apr-1996.) -/
theorem «3bitr3d» {ph ps ch th ta : wff}
  («3bitr3d_1» : ⊦ wi ph (wb ps ch))
  («3bitr3d_2» : ⊦ wi ph (wb ps th))
  («3bitr3d_3» : ⊦ wi ph (wb ch ta)) :
  ⊦ wi ph (wb th ta) :=
@bitrd ph th ch ta
  (@bitr3d ph ps th ch
    «3bitr3d_2»
    «3bitr3d_1»)
  «3bitr3d_3»


/-- Deduction from transitivity of biconditional. (Contributed by NM, 4-Aug-2006.) -/
theorem «3bitr3rd» {ph ps ch th ta : wff}
  («3bitr3d_1» : ⊦ wi ph (wb ps ch))
  («3bitr3d_2» : ⊦ wi ph (wb ps th))
  («3bitr3d_3» : ⊦ wi ph (wb ch ta)) :
  ⊦ wi ph (wb ta th) :=
@bitr3d ph ch ta th
  «3bitr3d_3»
  (@bitr3d ph ps ch th
    «3bitr3d_1»
    «3bitr3d_2»)


/-- Deduction from transitivity of biconditional. Useful for converting conditional definitions in a
formula. (Contributed by NM, 18-Oct-1995.) -/
theorem «3bitr4d» {ph ps ch th ta : wff}
  («3bitr4d_1» : ⊦ wi ph (wb ps ch))
  («3bitr4d_2» : ⊦ wi ph (wb th ps))
  («3bitr4d_3» : ⊦ wi ph (wb ta ch)) :
  ⊦ wi ph (wb th ta) :=
@bitrd ph th ps ta
  «3bitr4d_2»
  (@bitr4d ph ps ch ta
    «3bitr4d_1»
    «3bitr4d_3»)


/-- Deduction from transitivity of biconditional. (Contributed by NM, 4-Aug-2006.) -/
theorem «3bitr4rd» {ph ps ch th ta : wff}
  («3bitr4d_1» : ⊦ wi ph (wb ps ch))
  («3bitr4d_2» : ⊦ wi ph (wb th ps))
  («3bitr4d_3» : ⊦ wi ph (wb ta ch)) :
  ⊦ wi ph (wb ta th) :=
@bitr4d ph ta ps th
  (@bitr4d ph ta ch ps
    «3bitr4d_3»
    «3bitr4d_1»)
  «3bitr4d_2»


/-- More general version of ~ 3bitr3i . Useful for converting definitions in a formula. (Contributed
by NM, 4-Jun-1995.) -/
theorem «3bitr3g» {ph ps ch th ta : wff}
  («3bitr3g_1» : ⊦ wi ph (wb ps ch))
  («3bitr3g_2» : ⊦ wb ps th)
  («3bitr3g_3» : ⊦ wb ch ta) :
  ⊦ wi ph (wb th ta) :=
@bitrdi ph th ch ta
  (@bitr3id th ps ph ch
    «3bitr3g_2»
    «3bitr3g_1»)
  «3bitr3g_3»


/-- More general version of ~ 3bitr4i . Useful for converting definitions in a formula. (Contributed
by NM, 11-May-1993.) -/
theorem «3bitr4g» {ph ps ch th ta : wff}
  («3bitr4g_1» : ⊦ wi ph (wb ps ch))
  («3bitr4g_2» : ⊦ wb th ps)
  («3bitr4g_3» : ⊦ wb ta ch) :
  ⊦ wi ph (wb th ta) :=
@bitr4di ph th ch ta
  (@syl5bb th ps ph ch
    «3bitr4g_2»
    «3bitr4g_1»)
  «3bitr4g_3»


/-- Double negation. Theorem *4.13 of [WhiteheadRussell] p. 117. (Contributed by NM, 3-Jan-1993.) -/
theorem notnotb {ph : wff} :
  ⊦ wb ph (wn (wn ph)) :=
@impbii ph (wn (wn ph))
  (@notnot ph)
  (@notnotr ph)


/-- A biconditional form of contraposition. Theorem *4.1 of [WhiteheadRussell] p. 116. (Contributed
by NM, 11-May-1993.) -/
theorem con34b {ph ps : wff} :
  ⊦ wb (wi ph ps) (wi (wn ps) (wn ph)) :=
@impbii (wi ph ps) (wi (wn ps) (wn ph))
  (@con3 ph ps)
  (@con4 ps ph)


/-- A contraposition deduction. (Contributed by NM, 21-May-1994.) -/
theorem con4bid {ph ps ch : wff}
  (con4bid_1 : ⊦ wi ph (wb (wn ps) (wn ch))) :
  ⊦ wi ph (wb ps ch) :=
@impcon4bid ph ps ch
  (@con4d ph ch ps
    (@biimprd ph (wn ps) (wn ch)
      con4bid_1))
  (@biimpd ph (wn ps) (wn ch)
    con4bid_1)


/-- Deduction negating both sides of a logical equivalence. (Contributed by NM, 21-May-1994.) -/
theorem notbid {ph ps ch : wff}
  (notbid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wn ps) (wn ch)) :=
@con4bid ph (wn ps) (wn ch)
  (@«3bitr3g» ph ps ch (wn (wn ps)) (wn (wn ch))
    notbid_1
    (@notnotb ps)
    (@notnotb ch))


/-- Contraposition. Theorem *4.11 of [WhiteheadRussell] p. 117. (Contributed by NM, 21-May-1994.)
(Proof shortened by Wolf Lammen, 12-Jun-2013.) -/
theorem notbi {ph ps : wff} :
  ⊦ wb (wb ph ps) (wb (wn ph) (wn ps)) :=
@impbii (wb ph ps) (wb (wn ph) (wn ps))
  (@notbid (wb ph ps) ph ps
    (@id (wb ph ps)))
  (@con4bid (wb (wn ph) (wn ps)) ph ps
    (@id (wb (wn ph) (wn ps))))


/-- Negate both sides of a logical equivalence. (Contributed by NM, 3-Jan-1993.) (Proof shortened by
Wolf Lammen, 19-May-2013.) -/
theorem notbii {ph ps : wff}
  (notbii_1 : ⊦ wb ph ps) :
  ⊦ wb (wn ph) (wn ps) :=
@mpbi (wb ph ps) (wb (wn ph) (wn ps))
  notbii_1
  (@notbi ph ps)


/-- A contraposition inference. (Contributed by NM, 21-May-1994.) -/
theorem con4bii {ph ps : wff}
  (con4bii_1 : ⊦ wb (wn ph) (wn ps)) :
  ⊦ wb ph ps :=
@mpbir (wb ph ps) (wb (wn ph) (wn ps))
  con4bii_1
  (@notbi ph ps)


/-- An inference from a biconditional, related to modus tollens. (Contributed by NM, 15-Nov-1994.)
(Proof shortened by Wolf Lammen, 25-Oct-2012.) -/
theorem mtbi {ph ps : wff}
  (mtbi_1 : ⊦ wn ph)
  (mtbi_2 : ⊦ wb ph ps) :
  ⊦ wn ps :=
@mto ps ph
  mtbi_1
  (@biimpri ph ps
    mtbi_2)


/-- An inference from a biconditional, related to modus tollens. (Contributed by NM, 15-Nov-1994.)
(Proof shortened by Wolf Lammen, 14-Oct-2012.) -/
theorem mtbir {ph ps : wff}
  (mtbir_1 : ⊦ wn ps)
  (mtbir_2 : ⊦ wb ph ps) :
  ⊦ wn ph :=
@mtbi ps ph
  mtbir_1
  (@bicomi ph ps
    mtbir_2)


/-- A deduction from a biconditional, similar to modus tollens. (Contributed by NM, 26-Nov-1995.) -/
theorem mtbid {ph ps ch : wff}
  (mtbid_min : ⊦ wi ph (wn ps))
  (mtbid_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wn ch) :=
@mtod ph ch ps
  mtbid_min
  (@biimprd ph ps ch
    mtbid_maj)


/-- A deduction from a biconditional, similar to modus tollens. (Contributed by NM, 10-May-1994.) -/
theorem mtbird {ph ps ch : wff}
  (mtbird_min : ⊦ wi ph (wn ch))
  (mtbird_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wn ps) :=
@mtod ph ps ch
  mtbird_min
  (@biimpd ph ps ch
    mtbird_maj)


/-- An inference from a biconditional, similar to modus tollens. (Contributed by NM, 27-Nov-1995.)
-/
theorem mtbii {ph ps ch : wff}
  (mtbii_min : ⊦ wn ps)
  (mtbii_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wn ch) :=
@mtoi ph ch ps
  mtbii_min
  (@biimprd ph ps ch
    mtbii_maj)


/-- An inference from a biconditional, similar to modus tollens. (Contributed by NM, 24-Aug-1995.)
-/
theorem mtbiri {ph ps ch : wff}
  (mtbiri_min : ⊦ wn ch)
  (mtbiri_maj : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wn ps) :=
@mtoi ph ps ch
  mtbiri_min
  (@biimpd ph ps ch
    mtbiri_maj)


/-- A mixed syllogism inference from an implication and a biconditional. (Contributed by Wolf
Lammen, 16-Dec-2013.) -/
theorem sylnib {ph ps ch : wff}
  (sylnib_1 : ⊦ wi ph (wn ps))
  (sylnib_2 : ⊦ wb ps ch) :
  ⊦ wi ph (wn ch) :=
@nsyl ph ps ch
  sylnib_1
  (@biimpri ps ch
    sylnib_2)


/-- A mixed syllogism inference from an implication and a biconditional. Useful for substituting a
consequent with a definition. (Contributed by Wolf Lammen, 16-Dec-2013.) -/
theorem sylnibr {ph ps ch : wff}
  (sylnibr_1 : ⊦ wi ph (wn ps))
  (sylnibr_2 : ⊦ wb ch ps) :
  ⊦ wi ph (wn ch) :=
@sylnib ph ps ch
  sylnibr_1
  (@bicomi ch ps
    sylnibr_2)


/-- A mixed syllogism inference from a biconditional and an implication. Useful for substituting an
antecedent with a definition. (Contributed by Wolf Lammen, 16-Dec-2013.) -/
theorem sylnbi {ph ps ch : wff}
  (sylnbi_1 : ⊦ wb ph ps)
  (sylnbi_2 : ⊦ wi (wn ps) ch) :
  ⊦ wi (wn ph) ch :=
@sylbi (wn ph) (wn ps) ch
  (@notbii ph ps
    sylnbi_1)
  sylnbi_2


/-- A mixed syllogism inference from a biconditional and an implication. (Contributed by Wolf
Lammen, 16-Dec-2013.) -/
theorem sylnbir {ph ps ch : wff}
  (sylnbir_1 : ⊦ wb ps ph)
  (sylnbir_2 : ⊦ wi (wn ps) ch) :
  ⊦ wi (wn ph) ch :=
@sylnbi ph ps ch
  (@bicomi ps ph
    sylnbir_1)
  sylnbir_2


/-- Replacement of a subexpression by an equivalent one. (Contributed by Wolf Lammen, 27-Sep-2014.)
-/
theorem xchnxbi {ph ps ch : wff}
  (xchnxbi_1 : ⊦ wb (wn ph) ps)
  (xchnxbi_2 : ⊦ wb ph ch) :
  ⊦ wb (wn ch) ps :=
@bitr3i (wn ch) (wn ph) ps
  (@notbii ph ch
    xchnxbi_2)
  xchnxbi_1


/-- Replacement of a subexpression by an equivalent one. (Contributed by Wolf Lammen, 27-Sep-2014.)
-/
theorem xchnxbir {ph ps ch : wff}
  (xchnxbir_1 : ⊦ wb (wn ph) ps)
  (xchnxbir_2 : ⊦ wb ch ph) :
  ⊦ wb (wn ch) ps :=
@xchnxbi ph ps ch
  xchnxbir_1
  (@bicomi ch ph
    xchnxbir_2)


/-- Replacement of a subexpression by an equivalent one. (Contributed by Wolf Lammen, 27-Sep-2014.)
-/
theorem xchbinx {ph ps ch : wff}
  (xchbinx_1 : ⊦ wb ph (wn ps))
  (xchbinx_2 : ⊦ wb ps ch) :
  ⊦ wb ph (wn ch) :=
@bitri ph (wn ps) (wn ch)
  xchbinx_1
  (@notbii ps ch
    xchbinx_2)


/-- Replacement of a subexpression by an equivalent one. (Contributed by Wolf Lammen, 27-Sep-2014.)
-/
theorem xchbinxr {ph ps ch : wff}
  (xchbinxr_1 : ⊦ wb ph (wn ps))
  (xchbinxr_2 : ⊦ wb ch ps) :
  ⊦ wb ph (wn ch) :=
@xchbinx ph ps ch
  xchbinxr_1
  (@bicomi ch ps
    xchbinxr_2)


/-- Introduce an antecedent to both sides of a logical equivalence. This and the next three rules
are useful for building up wff's around a definition, in order to make use of the definition.
(Contributed by NM, 3-Jan-1993.) (Proof shortened by Wolf Lammen, 6-Feb-2013.) -/
theorem imbi2i {ph ps ch : wff}
  (imbi2i_1 : ⊦ wb ph ps) :
  ⊦ wb (wi ch ph) (wi ch ps) :=
@pm5_74i ch ph ps
  (@a1i (wb ph ps) ch
    imbi2i_1)


/-- Inference adding a biconditional to the left in an equivalence. (Contributed by NM,
26-May-1993.) (Proof shortened by Andrew Salmon, 7-May-2011.) (Proof shortened by Wolf Lammen,
16-May-2013.) -/
theorem bibi2i {ph ps ch : wff}
  (bibi2i_1 : ⊦ wb ph ps) :
  ⊦ wb (wb ch ph) (wb ch ps) :=
@impbii (wb ch ph) (wb ch ps)
  (@bitrdi (wb ch ph) ch ph ps
    (@id (wb ch ph))
    bibi2i_1)
  (@bitr4di (wb ch ps) ch ps ph
    (@id (wb ch ps))
    bibi2i_1)


/-- Inference adding a biconditional to the right in an equivalence. (Contributed by NM,
26-May-1993.) -/
theorem bibi1i {ph ps ch : wff}
  (bibi2i_1 : ⊦ wb ph ps) :
  ⊦ wb (wb ph ch) (wb ps ch) :=
@«3bitri» (wb ph ch) (wb ch ph) (wb ch ps) (wb ps ch)
  (@bicom ph ch)
  (@bibi2i ph ps ch
    bibi2i_1)
  (@bicom ch ps)


/-- The equivalence of two equivalences. (Contributed by NM, 26-May-1993.) -/
theorem bibi12i {ph ps ch th : wff}
  (bibi2i_1 : ⊦ wb ph ps)
  (bibi12i_2 : ⊦ wb ch th) :
  ⊦ wb (wb ph ch) (wb ps th) :=
@bitri (wb ph ch) (wb ph th) (wb ps th)
  (@bibi2i ch th ph
    bibi12i_2)
  (@bibi1i ph ps th
    bibi2i_1)


/-- Deduction adding an antecedent to both sides of a logical equivalence. (Contributed by NM,
11-May-1993.) -/
theorem imbi2d {ph ps ch th : wff}
  (imbid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wi th ps) (wi th ch)) :=
@pm5_74d ph th ps ch
  (@a1d ph (wb ps ch) th
    imbid_1)


/-- Deduction adding a consequent to both sides of a logical equivalence. (Contributed by NM,
11-May-1993.) (Proof shortened by Wolf Lammen, 17-Sep-2013.) -/
theorem imbi1d {ph ps ch th : wff}
  (imbid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wi ps th) (wi ch th)) :=
@impbid ph (wi ps th) (wi ch th)
  (@imim1d ph ch ps th
    (@biimprd ph ps ch
      imbid_1))
  (@imim1d ph ps ch th
    (@biimpd ph ps ch
      imbid_1))


/-- Deduction adding a biconditional to the left in an equivalence. (Contributed by NM,
11-May-1993.) (Proof shortened by Wolf Lammen, 19-May-2013.) -/
theorem bibi2d {ph ps ch th : wff}
  (imbid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wb th ps) (wb th ch)) :=
@pm5_74ri ph (wb th ps) (wb th ch)
  (@«3bitr4i» (wb (wi ph th) (wi ph ps)) (wb (wi ph th) (wi ph ch)) (wi ph (wb th ps)) (wi ph (wb th ch))
    (@bibi2i (wi ph ps) (wi ph ch) (wi ph th)
      (@pm5_74i ph ps ch
        imbid_1))
    (@pm5_74 ph th ps)
    (@pm5_74 ph th ch))


/-- Deduction adding a biconditional to the right in an equivalence. (Contributed by NM,
11-May-1993.) -/
theorem bibi1d {ph ps ch th : wff}
  (imbid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wb ps th) (wb ch th)) :=
@«3bitr4g» ph (wb th ps) (wb th ch) (wb ps th) (wb ch th)
  (@bibi2d ph ps ch th
    imbid_1)
  (@bicom ps th)
  (@bicom ch th)


/-- Deduction joining two equivalences to form equivalence of implications. (Contributed by NM,
16-May-1993.) -/
theorem imbi12d {ph ps ch th ta : wff}
  (imbi12d_1 : ⊦ wi ph (wb ps ch))
  (imbi12d_2 : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb (wi ps th) (wi ch ta)) :=
@bitrd ph (wi ps th) (wi ch th) (wi ch ta)
  (@imbi1d ph ps ch th
    imbi12d_1)
  (@imbi2d ph th ta ch
    imbi12d_2)


/-- Deduction joining two equivalences to form equivalence of biconditionals. (Contributed by NM,
26-May-1993.) -/
theorem bibi12d {ph ps ch th ta : wff}
  (imbi12d_1 : ⊦ wi ph (wb ps ch))
  (imbi12d_2 : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb (wb ps th) (wb ch ta)) :=
@bitrd ph (wb ps th) (wb ch th) (wb ch ta)
  (@bibi1d ph ps ch th
    imbi12d_1)
  (@bibi2d ph th ta ch
    imbi12d_2)


/-- Closed form of ~ imbi12i . Was automatically derived from its "Virtual Deduction" version and
the Metamath program "MM-PA> MINIMIZE__WITH *" command. (Contributed by Alan Sare, 18-Mar-2012.) -/
theorem imbi12 {ph ps ch th : wff} :
  ⊦ wi (wb ph ps) (wi (wb ch th) (wb (wi ph ch) (wi ps th))) :=
@expi (wb ph ps) (wb ch th) (wb (wi ph ch) (wi ps th))
  (@imbi12d (wn (wi (wb ph ps) (wn (wb ch th)))) ph ps ch th
    (@simplim (wb ph ps) (wn (wb ch th)))
    (@simprim (wb ph ps) (wb ch th)))


/-- Theorem *4.84 of [WhiteheadRussell] p. 122. (Contributed by NM, 3-Jan-2005.) -/
theorem imbi1 {ph ps ch : wff} :
  ⊦ wi (wb ph ps) (wb (wi ph ch) (wi ps ch)) :=
@imbi1d (wb ph ps) ph ps ch
  (@id (wb ph ps))


/-- Introduce a consequent to both sides of a logical equivalence. (Contributed by NM, 3-Jan-1993.)
(Proof shortened by Wolf Lammen, 17-Sep-2013.) -/
theorem imbi1i {ph ps ch : wff}
  (imbi1i_1 : ⊦ wb ph ps) :
  ⊦ wb (wi ph ch) (wi ps ch) :=
@ax_mp (wb ph ps) (wb (wi ph ch) (wi ps ch))
  imbi1i_1
  (@imbi1 ph ps ch)


/-- Join two logical equivalences to form equivalence of implications. (Contributed by NM,
1-Aug-1993.) -/
theorem imbi12i {ph ps ch th : wff}
  (imbi12i_1 : ⊦ wb ph ps)
  (imbi12i_2 : ⊦ wb ch th) :
  ⊦ wb (wi ph ch) (wi ps th) :=
@mp2 (wb ph ps) (wb ch th) (wb (wi ph ch) (wi ps th))
  imbi12i_1
  imbi12i_2
  (@imbi12 ph ps ch th)


/-- Theorem *4.86 of [WhiteheadRussell] p. 122. (Contributed by NM, 3-Jan-2005.) -/
theorem bibi1 {ph ps ch : wff} :
  ⊦ wi (wb ph ps) (wb (wb ph ch) (wb ps ch)) :=
@bibi1d (wb ph ps) ph ps ch
  (@id (wb ph ps))


/-- Contraposition. Theorem *4.12 of [WhiteheadRussell] p. 117. (Contributed by NM, 15-Apr-1995.)
(Proof shortened by Wolf Lammen, 3-Jan-2013.) -/
theorem con2bi {ph ps : wff} :
  ⊦ wb (wb ph (wn ps)) (wb ps (wn ph)) :=
@«3bitr2i» (wb ph (wn ps)) (wb (wn ph) (wn (wn ps))) (wb (wn ph) ps) (wb ps (wn ph))
  (@notbi ph (wn ps))
  (@bibi2i ps (wn (wn ps)) (wn ph)
    (@notnotb ps))
  (@bicom (wn ph) ps)


/-- A contraposition deduction. (Contributed by NM, 15-Apr-1995.) -/
theorem con2bid {ph ps ch : wff}
  (con2bid_1 : ⊦ wi ph (wb ps (wn ch))) :
  ⊦ wi ph (wb ch (wn ps)) :=
@sylibr ph (wb ps (wn ch)) (wb ch (wn ps))
  con2bid_1
  (@con2bi ch ps)


/-- A contraposition deduction. (Contributed by NM, 9-Oct-1999.) -/
theorem con1bid {ph ps ch : wff}
  (con1bid_1 : ⊦ wi ph (wb (wn ps) ch)) :
  ⊦ wi ph (wb (wn ch) ps) :=
@bicomd ph ps (wn ch)
  (@con2bid ph ch ps
    (@bicomd ph (wn ps) ch
      con1bid_1))


/-- A contraposition inference. (Contributed by NM, 12-Mar-1993.) (Proof shortened by Wolf Lammen,
13-Oct-2012.) -/
theorem con1bii {ph ps : wff}
  (con1bii_1 : ⊦ wb (wn ph) ps) :
  ⊦ wb (wn ps) ph :=
@bicomi ph (wn ps)
  (@xchbinx ph (wn ph) ps
    (@notnotb ph)
    con1bii_1)


/-- A contraposition inference. (Contributed by NM, 12-Mar-1993.) -/
theorem con2bii {ph ps : wff}
  (con2bii_1 : ⊦ wb ph (wn ps)) :
  ⊦ wb ps (wn ph) :=
@xchbinxr ps (wn ps) ph
  (@notnotb ps)
  con2bii_1


/-- Contraposition. Bidirectional version of ~ con1 . (Contributed by NM, 3-Jan-1993.) -/
theorem con1b {ph ps : wff} :
  ⊦ wb (wi (wn ph) ps) (wi (wn ps) ph) :=
@impbii (wi (wn ph) ps) (wi (wn ps) ph)
  (@con1 ph ps)
  (@con1 ps ph)


/-- Contraposition. Bidirectional version of ~ con2 . (Contributed by NM, 12-Mar-1993.) -/
theorem con2b {ph ps : wff} :
  ⊦ wb (wi ph (wn ps)) (wi ps (wn ph)) :=
@impbii (wi ph (wn ps)) (wi ps (wn ph))
  (@con2 ph ps)
  (@con2 ps ph)


/-- A wff is equivalent to itself with true antecedent. (Contributed by NM, 28-Jan-1996.) -/
theorem biimt {ph ps : wff} :
  ⊦ wi ph (wb ps (wi ph ps)) :=
@impbid2 ph ps (wi ph ps)
  (@ax_1 ps ph)
  (@pm2_27 ph ps)


/-- Theorem *5.5 of [WhiteheadRussell] p. 125. (Contributed by NM, 3-Jan-2005.) -/
theorem pm5_5 {ph ps : wff} :
  ⊦ wi ph (wb (wi ph ps) ps) :=
@bicomd ph ps (wi ph ps)
  (@biimt ph ps)


/-- Inference introducing a theorem as an antecedent. (Contributed by NM, 5-Aug-1993.) (Proof
shortened by Wolf Lammen, 11-Nov-2012.) -/
theorem a1bi {ph ps : wff}
  (a1bi_1 : ⊦ ph) :
  ⊦ wb ps (wi ph ps) :=
@ax_mp ph (wb ps (wi ph ps))
  a1bi_1
  (@biimt ph ps)


/-- Modus-tollens-like theorem. (Contributed by NM, 7-Apr-2001.) (Proof shortened by Wolf Lammen,
12-Nov-2012.) -/
theorem mtt {ph ps : wff} :
  ⊦ wi (wn ph) (wb (wn ps) (wi ps ph)) :=
@bitr4di (wn ph) (wn ps) (wi (wn ph) (wn ps)) (wi ps ph)
  (@biimt (wn ph) (wn ps))
  (@con34b ps ph)


/-- Theorem *5.501 of [WhiteheadRussell] p. 125. (Contributed by NM, 3-Jan-2005.) -/
theorem pm5_501 {ph ps : wff} :
  ⊦ wi ph (wb ps (wb ph ps)) :=
@impbid ph ps (wb ph ps)
  (@pm5_1im ph ps)
  (@com12 (wb ph ps) ph ps
    (@biimp ph ps))


/-- Implication in terms of implication and biconditional. (Contributed by NM, 29-Apr-2005.) (Proof
shortened by Wolf Lammen, 21-Dec-2013.) -/
theorem ibibr {ph ps : wff} :
  ⊦ wb (wi ph ps) (wi ph (wb ps ph)) :=
@pm5_74i ph ps (wb ps ph)
  (@bitrdi ph ps (wb ph ps) (wb ps ph)
    (@pm5_501 ph ps)
    (@bicom ph ps))


/-- A wff is equivalent to its equivalence with a truth. (Contributed by NM, 18-Aug-1993.) (Proof
shortened by Andrew Salmon, 13-May-2011.) -/
theorem tbt {ph ps : wff}
  (tbt_1 : ⊦ ph) :
  ⊦ wb ps (wb ps ph) :=
@ax_mp ph (wb ps (wb ps ph))
  tbt_1
  (@pm5_74ri ph ps (wb ps ph)
    (@ibibr ph ps))


/-- The negation of a wff is equivalent to the wff's equivalence to falsehood. (Contributed by Juha
Arpiainen, 19-Jan-2006.) (Proof shortened by Wolf Lammen, 28-Jan-2013.) -/
theorem nbn2 {ph ps : wff} :
  ⊦ wi (wn ph) (wb (wn ps) (wb ph ps)) :=
@bitr4di (wn ph) (wn ps) (wb (wn ph) (wn ps)) (wb ph ps)
  (@pm5_501 (wn ph) (wn ps))
  (@notbi ph ps)


/-- Transfer negation via an equivalence. (Contributed by NM, 3-Oct-2007.) (Proof shortened by Wolf
Lammen, 28-Jan-2013.) -/
theorem bibif {ph ps : wff} :
  ⊦ wi (wn ps) (wb (wb ph ps) (wn ph)) :=
@bitr2di (wn ps) (wn ph) (wb ps ph) (wb ph ps)
  (@nbn2 ps ph)
  (@bicom ps ph)


/-- The negation of a wff is equivalent to the wff's equivalence to falsehood. (Contributed by NM,
21-Jun-1993.) (Proof shortened by Wolf Lammen, 3-Oct-2013.) -/
theorem nbn {ph ps : wff}
  (nbn_1 : ⊦ wn ph) :
  ⊦ wb (wn ps) (wb ps ph) :=
@bicomi (wb ps ph) (wn ps)
  (@ax_mp (wn ph) (wb (wb ps ph) (wn ps))
    nbn_1
    (@bibif ps ph))


/-- Two propositions are equivalent if they are both false. Closed form of ~ 2false . Equivalent to
a ~ biimpr -like version of the xor-connective. (Contributed by Wolf Lammen, 13-May-2013.) -/
theorem pm5_21im {ph ps : wff} :
  ⊦ wi (wn ph) (wi (wn ps) (wb ph ps)) :=
@biimpd (wn ph) (wn ps) (wb ph ps)
  (@nbn2 ph ps)


/-- Two falsehoods are equivalent. (Contributed by NM, 4-Apr-2005.) (Proof shortened by Wolf Lammen,
19-May-2013.) -/
theorem «2false» {ph ps : wff}
  («2false_1» : ⊦ wn ph)
  («2false_2» : ⊦ wn ps) :
  ⊦ wb ph ps :=
@con4bii ph ps
  (@«2th» (wn ph) (wn ps)
    «2false_1»
    «2false_2»)


/-- Two falsehoods are equivalent (deduction form). (Contributed by NM, 11-Oct-2013.) (Proof
shortened by Wolf Lammen, 11-Apr-2024.) -/
theorem «2falsed» {ph ps ch : wff}
  («2falsed_1» : ⊦ wi ph (wn ps))
  («2falsed_2» : ⊦ wi ph (wn ch)) :
  ⊦ wi ph (wb ps ch) :=
@con4bid ph ps ch
  (@«2thd» ph (wn ps) (wn ch)
    «2falsed_1»
    «2falsed_2»)


/-- Two propositions implying a false one are equivalent. (Contributed by NM, 16-Feb-1996.) (Proof
shortened by Wolf Lammen, 19-May-2013.) -/
theorem pm5_21ni {ph ps ch : wff}
  (pm5_21ni_1 : ⊦ wi ph ps)
  (pm5_21ni_2 : ⊦ wi ch ps) :
  ⊦ wi (wn ps) (wb ph ch) :=
@«2falsed» (wn ps) ph ch
  (@con3i ph ps
    pm5_21ni_1)
  (@con3i ch ps
    pm5_21ni_2)


/-- Eliminate an antecedent implied by each side of a biconditional. (Contributed by NM,
21-May-1999.) -/
theorem pm5_21nii {ph ps ch : wff}
  (pm5_21ni_1 : ⊦ wi ph ps)
  (pm5_21ni_2 : ⊦ wi ch ps)
  (pm5_21nii_3 : ⊦ wi ps (wb ph ch)) :
  ⊦ wb ph ch :=
@pm2_61i ps (wb ph ch)
  pm5_21nii_3
  (@pm5_21ni ph ps ch
    pm5_21ni_1
    pm5_21ni_2)


/-- Eliminate an antecedent implied by each side of a biconditional, deduction version. (Contributed
by Paul Chapman, 21-Nov-2012.) (Proof shortened by Wolf Lammen, 6-Oct-2013.) -/
theorem pm5_21ndd {ph ps ch th : wff}
  (pm5_21ndd_1 : ⊦ wi ph (wi ch ps))
  (pm5_21ndd_2 : ⊦ wi ph (wi th ps))
  (pm5_21ndd_3 : ⊦ wi ph (wi ps (wb ch th))) :
  ⊦ wi ph (wb ch th) :=
@pm2_61d ph ps (wb ch th)
  pm5_21ndd_3
  (@syl6c ph (wn ps) (wn ch) (wn th) (wb ch th)
    (@con3d ph ch ps
      pm5_21ndd_1)
    (@con3d ph th ps
      pm5_21ndd_2)
    (@pm5_21im ch th))


/-- Combine antecedents into a single biconditional. This inference, reminiscent of ~ ja , is
reversible: The hypotheses can be deduced from the conclusion alone (see ~ pm5.1im and ~ pm5.21im ).
(Contributed by Wolf Lammen, 13-May-2013.) -/
theorem bija {ph ps ch : wff}
  (bija_1 : ⊦ wi ph (wi ps ch))
  (bija_2 : ⊦ wi (wn ph) (wi (wn ps) ch)) :
  ⊦ wi (wb ph ps) ch :=
@pm2_61d (wb ph ps) ps ch
  (@syli ps (wb ph ps) ph ch
    (@biimpr ph ps)
    bija_1)
  (@syli (wn ps) (wb ph ps) (wn ph) ch
    (@con3d (wb ph ps) ph ps
      (@biimp ph ps))
    bija_2)


/-- Theorem *5.18 of [WhiteheadRussell] p. 124. This theorem says that logical equivalence is the
same as negated "exclusive or". (Contributed by NM, 28-Jun-2002.) (Proof shortened by Andrew Salmon,
20-Jun-2011.) (Proof shortened by Wolf Lammen, 15-Oct-2013.) -/
theorem pm5_18 {ph ps : wff} :
  ⊦ wb (wb ph ps) (wn (wb ph (wn ps))) :=
@pm2_61i ph (wb (wb ph ps) (wn (wb ph (wn ps))))
  (@bitr2d ph (wn (wb ph (wn ps))) ps (wb ph ps)
    (@con1bid ph ps (wb ph (wn ps))
      (@pm5_501 ph (wn ps)))
    (@pm5_501 ph ps))
  (@bitr2d (wn ph) (wn (wb ph (wn ps))) (wn ps) (wb ph ps)
    (@con1bid (wn ph) (wn ps) (wb ph (wn ps))
      (@nbn2 ph (wn ps)))
    (@nbn2 ph ps))


/-- Two ways to express "exclusive or". (Contributed by NM, 1-Jan-2006.) -/
theorem xor3 {ph ps : wff} :
  ⊦ wb (wn (wb ph ps)) (wb ph (wn ps)) :=
@bicomi (wb ph (wn ps)) (wn (wb ph ps))
  (@con2bii (wb ph ps) (wb ph (wn ps))
    (@pm5_18 ph ps))


/-- Move negation outside of biconditional. Compare Theorem *5.18 of [WhiteheadRussell] p. 124.
(Contributed by NM, 27-Jun-2002.) (Proof shortened by Wolf Lammen, 20-Sep-2013.) -/
theorem nbbn {ph ps : wff} :
  ⊦ wb (wb (wn ph) ps) (wn (wb ph ps)) :=
@«3bitrri» (wn (wb ph ps)) (wb ph (wn ps)) (wb ps (wn ph)) (wb (wn ph) ps)
  (@xor3 ph ps)
  (@con2bi ph ps)
  (@bicom ps (wn ph))


/-- Associative law for the biconditional. An axiom of system DS in Vladimir Lifschitz, "On
calculational proofs", Annals of Pure and Applied Logic, 113:207-224, 2002, ~
http://www.cs.utexas.edu/users/ai-lab/pub-view.php?PubID=26805 . Interestingly, this law was not
included in _Principia Mathematica_ but was apparently first noted by Jan Lukasiewicz circa 1923.
(Contributed by NM, 8-Jan-2005.) (Proof shortened by Juha Arpiainen, 19-Jan-2006.) (Proof shortened
by Wolf Lammen, 21-Sep-2013.) -/
theorem biass {ph ps ch : wff} :
  ⊦ wb (wb (wb ph ps) ch) (wb ph (wb ps ch)) :=
@pm2_61i ph (wb (wb (wb ph ps) ch) (wb ph (wb ps ch)))
  (@bitr3d ph (wb ps ch) (wb (wb ph ps) ch) (wb ph (wb ps ch))
    (@bibi1d ph ps (wb ph ps) ch
      (@pm5_501 ph ps))
    (@pm5_501 ph (wb ps ch)))
  (@bitr3d (wn ph) (wn (wb ps ch)) (wb (wb ph ps) ch) (wb ph (wb ps ch))
    (@bitr3id (wn (wb ps ch)) (wb (wn ps) ch) (wn ph) (wb (wb ph ps) ch)
      (@nbbn ps ch)
      (@bibi1d (wn ph) (wn ps) (wb ph ps) ch
        (@nbn2 ph ps)))
    (@nbn2 ph (wb ps ch)))


/-- Lukasiewicz's shortest axiom for equivalential calculus. Storrs McCall, ed., _Polish Logic
1920-1939_ (Oxford, 1967), p. 96. (Contributed by NM, 10-Jan-2005.) -/
theorem biluk {ph ps ch : wff} :
  ⊦ wb (wb ph ps) (wb (wb ch ps) (wb ph ch)) :=
@bitr4i (wb ph ps) (wb ch (wb ps (wb ph ch))) (wb (wb ch ps) (wb ph ch))
  (@mpbi (wb (wb (wb ph ps) ch) (wb ps (wb ph ch))) (wb (wb ph ps) (wb ch (wb ps (wb ph ch))))
    (@bitri (wb (wb ph ps) ch) (wb (wb ps ph) ch) (wb ps (wb ph ch))
      (@bibi1i (wb ph ps) (wb ps ph) ch
        (@bicom ph ps))
      (@biass ps ph ch))
    (@biass (wb ph ps) ch (wb ps (wb ph ch))))
  (@biass ch ps (wb ph ch))


/-- Logical equivalence of commuted antecedents. Part of Theorem *4.87 of [WhiteheadRussell] p. 122.
(Contributed by NM, 11-May-1993.) -/
theorem bi2_04 {ph ps ch : wff} :
  ⊦ wb (wi ph (wi ps ch)) (wi ps (wi ph ch)) :=
@impbii (wi ph (wi ps ch)) (wi ps (wi ph ch))
  (@pm2_04 ph ps ch)
  (@pm2_04 ps ph ch)


-- /-- Extend wff definition to include conjunction ("and"). -/
-- constant wa : wff → wff → wff


-- /-- Define conjunction (logical "and"). Definition of [Margaris] p. 49. When both the left and
-- right operand are true, the result is true; when either is false, the result is false. For
-- example, it is true that ` ( 2 = 2 /\ 3 = 3 ) ` . After we define the constant true ` T. ` ( ~
-- df-tru ) and the constant false ` F. ` ( ~ df-fal ), we will be able to prove these truth table
-- values: ` ( ( T. /\ T. ) <-> T. ) ` ( ~ truantru ), ` ( ( T. /\ F. ) <-> F. ) ` ( ~ truanfal ), `
-- ( ( F. /\ T. ) <-> F. ) ` ( ~ falantru ), and ` ( ( F. /\ F. ) <-> F. ) ` ( ~ falanfal ). This is
-- our first use of the biconditional connective in a definition; we use the biconditional
-- connective in place of the traditional "<=def=>", which means the same thing, except that we can
-- manipulate the biconditional connective directly in proofs rather than having to rely on an
-- informal definition substitution rule. Note that if we mechanically substitute ` -. ( ph -> -. ps
-- ) ` for ` ( ph /\ ps ) ` , we end up with an instance of previously proved theorem ~ biid . This
-- is the justification for the definition, along with the fact that it introduces a new symbol ` /\
-- ` . Contrast with ` \/ ` ( ~ df-or ), ` -> ` ( ~ wi ), ` -/\ ` ( ~ df-nan ), and ` \/_ ` ( ~
-- df-xor ). (Contributed by NM, 5-Jan-1993.) -/
-- axiom df_an {ph ps : wff} : ⊦ wb (wa ph ps) (wn (wi ph (wn ps)))


/-- Theorem *4.63 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_63 {ph ps : wff} :
  ⊦ wb (wn (wi ph (wn ps))) (wa ph ps) :=
@bicomi (wa ph ps) (wn (wi ph (wn ps)))
  (@df_an ph ps)


/-- Express an implication in terms of a negated conjunction. (Contributed by NM, 9-Apr-1994.) -/
theorem imnan {ph ps : wff} :
  ⊦ wb (wi ph (wn ps)) (wn (wa ph ps)) :=
@con2bii (wa ph ps) (wi ph (wn ps))
  (@df_an ph ps)


/-- Infer an implication from a negated conjunction. (Contributed by Mario Carneiro, 28-Sep-2015.)
-/
theorem imnani {ph ps : wff}
  (imnani_1 : ⊦ wn (wa ph ps)) :
  ⊦ wi ph (wn ps) :=
@mpbir (wi ph (wn ps)) (wn (wa ph ps))
  imnani_1
  (@imnan ph ps)


/-- Implication in terms of conjunction and negation. Theorem 3.4(27) of [Stoll] p. 176.
(Contributed by NM, 12-Mar-1993.) (Proof shortened by Wolf Lammen, 30-Oct-2012.) -/
theorem iman {ph ps : wff} :
  ⊦ wb (wi ph ps) (wn (wa ph (wn ps))) :=
@bitri (wi ph ps) (wi ph (wn (wn ps))) (wn (wa ph (wn ps)))
  (@imbi2i ps (wn (wn ps)) ph
    (@notnotb ps))
  (@imnan ph (wn ps))


/-- Law of noncontradiction. Theorem *3.24 of [WhiteheadRussell] p. 111 (who call it the "law of
contradiction"). (Contributed by NM, 16-Sep-1993.) (Proof shortened by Wolf Lammen, 24-Nov-2012.) -/
theorem pm3_24 {ph : wff} :
  ⊦ wn (wa ph (wn ph)) :=
@mpbi (wi ph ph) (wn (wa ph (wn ph)))
  (@id ph)
  (@iman ph ph)


/-- Express a conjunction in terms of a negated implication. (Contributed by NM, 2-Aug-1994.) -/
theorem annim {ph ps : wff} :
  ⊦ wb (wa ph (wn ps)) (wn (wi ph ps)) :=
@con2bii (wi ph ps) (wa ph (wn ps))
  (@iman ph ps)


/-- Theorem *4.61 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_61 {ph ps : wff} :
  ⊦ wb (wn (wi ph ps)) (wa ph (wn ps)) :=
@bicomi (wa ph (wn ps)) (wn (wi ph ps))
  (@annim ph ps)


/-- Theorem *4.65 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_65 {ph ps : wff} :
  ⊦ wb (wn (wi (wn ph) ps)) (wa (wn ph) (wn ps)) :=
@pm4_61 (wn ph) ps


/-- Importation inference. (Contributed by NM, 3-Jan-1993.) (Proof shortened by Eric Schmidt,
22-Dec-2006.) -/
theorem imp {ph ps ch : wff}
  (imp_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wa ph ps) ch :=
@sylbi (wa ph ps) (wn (wi ph (wn ps))) ch
  (@df_an ph ps)
  (@impi ph ps ch
    imp_1)


/-- Importation inference with commuted antecedents. (Contributed by NM, 25-May-2005.) -/
theorem impcom {ph ps ch : wff}
  (imp_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wa ps ph) ch :=
@imp ps ph ch
  (@com12 ph ps ch
    imp_1)


/-- Variant of ~ con3d with importation. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem con3dimp {ph ps ch : wff}
  (con3dimp_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wa ph (wn ch)) (wn ps) :=
@imp ph (wn ch) (wn ps)
  (@con3d ph ps ch
    con3dimp_1)


/-- Importation deduction. (Contributed by NM, 31-Mar-1994.) -/
theorem impd {ph ps ch th : wff}
  (impd_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi (wa ps ch) th) :=
@com12 (wa ps ch) ph th
  (@imp ps ch (wi ph th)
    (@com3l ph ps ch th
      impd_1))


/-- Importation deduction with commuted antecedents. (Contributed by Peter Mazsa, 24-Sep-2022.)
(Proof shortened by Wolf Lammen, 22-Oct-2022.) -/
theorem impcomd {ph ps ch th : wff}
  (impd_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi (wa ch ps) th) :=
@impd ph ch ps th
  (@com23 ph ps ch th
    impd_1)


/-- Exportation inference. (This theorem used to be labeled "exp" but was changed to "ex" so as not
to conflict with the math token "exp", per the June 2006 Metamath spec change.) A translation of
natural deduction rule ` -> ` I ( ` -> ` introduction), see ~ natded . (Contributed by NM,
3-Jan-1993.) (Proof shortened by Eric Schmidt, 22-Dec-2006.) -/
theorem ex {ph ps ch : wff}
  (ex_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi ph (wi ps ch) :=
@expi ph ps ch
  (@sylbir (wn (wi ph (wn ps))) (wa ph ps) ch
    (@df_an ph ps)
    ex_1)


/-- Exportation inference with commuted antecedents. (Contributed by NM, 25-May-2005.) -/
theorem expcom {ph ps ch : wff}
  (ex_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi ps (wi ph ch) :=
@com12 ph ps ch
  (@ex ph ps ch
    ex_1)


/-- Commuted form of ~ expd . (Contributed by Alan Sare, 18-Mar-2012.) Shorten ~ expd . (Revised by
Wolf Lammen, 28-Jul-2022.) -/
theorem expdcom {ph ps ch th : wff}
  (expd_1 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ps (wi ch (wi ph th)) :=
@ex ps ch (wi ph th)
  (@com12 ph (wa ps ch) th
    expd_1)


/-- Exportation deduction. (Contributed by NM, 20-Aug-1993.) (Proof shortened by Wolf Lammen,
28-Jul-2022.) -/
theorem expd {ph ps ch th : wff}
  (expd_1 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph (wi ps (wi ch th)) :=
@com3r ps ch ph th
  (@expdcom ph ps ch th
    expd_1)


/-- Deduction form of ~ expcom . (Contributed by Alan Sare, 22-Jul-2012.) -/
theorem expcomd {ph ps ch th : wff}
  (expcomd_1 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph (wi ch (wi ps th)) :=
@com23 ph ps ch th
  (@expd ph ps ch th
    expcomd_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem imp31 {ph ps ch th : wff}
  (imp31_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi (wa (wa ph ps) ch) th :=
@imp (wa ph ps) ch th
  (@imp ph ps (wi ch th)
    imp31_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem imp32 {ph ps ch th : wff}
  (imp31_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi (wa ph (wa ps ch)) th :=
@imp ph (wa ps ch) th
  (@impd ph ps ch th
    imp31_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp31 {ph ps ch th : wff}
  (exp31_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi ph (wi ps (wi ch th)) :=
@ex ph ps (wi ch th)
  (@ex (wa ph ps) ch th
    exp31_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp32 {ph ps ch th : wff}
  (exp32_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi ph (wi ps (wi ch th)) :=
@expd ph ps ch th
  (@ex ph (wa ps ch) th
    exp32_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) Shorten ~ imp4a . (Revised by Wolf
Lammen, 19-Jul-2021.) -/
theorem imp4b {ph ps ch th ta : wff}
  (imp4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi (wa ph ps) (wi (wa ch th) ta) :=
@impd (wa ph ps) ch th ta
  (@imp ph ps (wi ch (wi th ta))
    imp4_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) (Proof shortened by Wolf Lammen,
19-Jul-2021.) -/
theorem imp4a {ph ps ch th ta : wff}
  (imp4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ph (wi ps (wi (wa ch th) ta)) :=
@ex ph ps (wi (wa ch th) ta)
  (@imp4b ph ps ch th ta
    imp4_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem imp4c {ph ps ch th ta : wff}
  (imp4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ph (wi (wa (wa ps ch) th) ta) :=
@impd ph (wa ps ch) th ta
  (@impd ph ps ch (wi th ta)
    imp4_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem imp4d {ph ps ch th ta : wff}
  (imp4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ph (wi (wa ps (wa ch th)) ta) :=
@impd ph ps (wa ch th) ta
  (@imp4a ph ps ch th ta
    imp4_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem imp41 {ph ps ch th ta : wff}
  (imp4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi (wa (wa (wa ph ps) ch) th) ta :=
@imp31 (wa ph ps) ch th ta
  (@imp ph ps (wi ch (wi th ta))
    imp4_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem imp42 {ph ps ch th ta : wff}
  (imp4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi (wa (wa ph (wa ps ch)) th) ta :=
@imp (wa ph (wa ps ch)) th ta
  (@imp32 ph ps ch (wi th ta)
    imp4_1)


/-- An importation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem imp43 {ph ps ch th ta : wff}
  (imp4_1 : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi (wa (wa ph ps) (wa ch th)) ta :=
@imp (wa ph ps) (wa ch th) ta
  (@imp4b ph ps ch th ta
    imp4_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) (Proof shortened by Wolf Lammen,
23-Nov-2012.) Shorten ~ exp4a . (Revised by Wolf Lammen, 20-Jul-2021.) -/
theorem exp4b {ph ps ch th ta : wff}
  (exp4b_1 : ⊦ wi (wa ph ps) (wi (wa ch th) ta)) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@ex ph ps (wi ch (wi th ta))
  (@expd (wa ph ps) ch th ta
    exp4b_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) (Proof shortened by Wolf Lammen,
20-Jul-2021.) -/
theorem exp4a {ph ps ch th ta : wff}
  (exp4a_1 : ⊦ wi ph (wi ps (wi (wa ch th) ta))) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@exp4b ph ps ch th ta
  (@imp ph ps (wi (wa ch th) ta)
    exp4a_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp4c {ph ps ch th ta : wff}
  (exp4c_1 : ⊦ wi ph (wi (wa (wa ps ch) th) ta)) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@expd ph ps ch (wi th ta)
  (@expd ph (wa ps ch) th ta
    exp4c_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp4d {ph ps ch th ta : wff}
  (exp4d_1 : ⊦ wi ph (wi (wa ps (wa ch th)) ta)) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@exp4a ph ps ch th ta
  (@expd ph ps (wa ch th) ta
    exp4d_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp41 {ph ps ch th ta : wff}
  (exp41_1 : ⊦ wi (wa (wa (wa ph ps) ch) th) ta) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@exp31 ph ps ch (wi th ta)
  (@ex (wa (wa ph ps) ch) th ta
    exp41_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp42 {ph ps ch th ta : wff}
  (exp42_1 : ⊦ wi (wa (wa ph (wa ps ch)) th) ta) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@expd ph ps ch (wi th ta)
  (@exp31 ph (wa ps ch) th ta
    exp42_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp43 {ph ps ch th ta : wff}
  (exp43_1 : ⊦ wi (wa (wa ph ps) (wa ch th)) ta) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@exp4b ph ps ch th ta
  (@ex (wa ph ps) (wa ch th) ta
    exp43_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp44 {ph ps ch th ta : wff}
  (exp44_1 : ⊦ wi (wa ph (wa (wa ps ch) th)) ta) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@expd ph ps ch (wi th ta)
  (@exp32 ph (wa ps ch) th ta
    exp44_1)


/-- An exportation inference. (Contributed by NM, 26-Apr-1994.) -/
theorem exp45 {ph ps ch th ta : wff}
  (exp45_1 : ⊦ wi (wa ph (wa ps (wa ch th))) ta) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@exp4a ph ps ch th ta
  (@exp32 ph ps (wa ch th) ta
    exp45_1)


/-- An exportation inference. (Contributed by Jeff Hankins, 7-Jul-2009.) -/
theorem exp5c {ph ps ch th ta et : wff}
  (exp5c_1 : ⊦ wi ph (wi (wa ps ch) (wi (wa th ta) et))) :
  ⊦ wi ph (wi ps (wi ch (wi th (wi ta et)))) :=
@expd ph ps ch (wi th (wi ta et))
  (@exp4a ph (wa ps ch) th ta et
    exp5c_1)


/-- An exportation inference. (Contributed by Jeff Hankins, 30-Aug-2009.) -/
theorem exp53 {ph ps ch th ta et : wff}
  (exp53_1 : ⊦ wi (wa (wa (wa ph ps) (wa ch th)) ta) et) :
  ⊦ wi ph (wi ps (wi ch (wi th (wi ta et)))) :=
@exp43 ph ps ch th (wi ta et)
  (@ex (wa (wa ph ps) (wa ch th)) ta et
    exp53_1)


/-- Theorem *3.3 (Exp) of [WhiteheadRussell] p. 112. (Contributed by NM, 3-Jan-2005.) (Proof
shortened by Wolf Lammen, 24-Mar-2013.) -/
theorem pm3_3 {ph ps ch : wff} :
  ⊦ wi (wi (wa ph ps) ch) (wi ph (wi ps ch)) :=
@expd (wi (wa ph ps) ch) ph ps ch
  (@id (wi (wa ph ps) ch))


/-- Theorem *3.31 (Imp) of [WhiteheadRussell] p. 112. (Contributed by NM, 3-Jan-2005.) (Proof
shortened by Wolf Lammen, 24-Mar-2013.) -/
theorem pm3_31 {ph ps ch : wff} :
  ⊦ wi (wi ph (wi ps ch)) (wi (wa ph ps) ch) :=
@impd (wi ph (wi ps ch)) ph ps ch
  (@id (wi ph (wi ps ch)))


/-- Import-export theorem. Part of Theorem *4.87 of [WhiteheadRussell] p. 122. (Contributed by NM,
10-Jan-1993.) (Proof shortened by Wolf Lammen, 24-Mar-2013.) -/
theorem impexp {ph ps ch : wff} :
  ⊦ wb (wi (wa ph ps) ch) (wi ph (wi ps ch)) :=
@impbii (wi (wa ph ps) ch) (wi ph (wi ps ch))
  (@pm3_3 ph ps ch)
  (@pm3_31 ph ps ch)


/-- Mixed importation/commutation inference. (Contributed by NM, 22-Jun-2013.) -/
theorem impancom {ph ps ch th : wff}
  (impancom_1 : ⊦ wi (wa ph ps) (wi ch th)) :
  ⊦ wi (wa ph ch) (wi ps th) :=
@imp ph ch (wi ps th)
  (@com23 ph ps ch th
    (@ex ph ps (wi ch th)
      impancom_1))


/-- A deduction version of exportation, followed by importation. (Contributed by NM, 6-Sep-2008.) -/
theorem expdimp {ph ps ch th : wff}
  (expdimp_1 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi (wa ph ps) (wi ch th) :=
@imp ph ps (wi ch th)
  (@expd ph ps ch th
    expdimp_1)


/-- Exportation followed by a deduction version of importation. (Contributed by NM, 6-Sep-2008.) -/
theorem expimpd {ph ps ch th : wff}
  (expimpd_1 : ⊦ wi (wa ph ps) (wi ch th)) :
  ⊦ wi ph (wi (wa ps ch) th) :=
@impd ph ps ch th
  (@ex ph ps (wi ch th)
    expimpd_1)


/-- Import a wff into a right conjunct. (Contributed by Jeff Hankins, 30-Aug-2009.) -/
theorem impr {ph ps ch th : wff}
  (impr_1 : ⊦ wi (wa ph ps) (wi ch th)) :
  ⊦ wi (wa ph (wa ps ch)) th :=
@imp32 ph ps ch th
  (@ex ph ps (wi ch th)
    impr_1)


/-- Export a wff from a left conjunct. (Contributed by Mario Carneiro, 9-Jul-2014.) -/
theorem impl {ph ps ch th : wff}
  (impl_1 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi (wa (wa ph ps) ch) th :=
@imp31 ph ps ch th
  (@expd ph ps ch th
    impl_1)


/-- Export a wff from a right conjunct. (Contributed by Jeff Hankins, 30-Aug-2009.) -/
theorem expr {ph ps ch th : wff}
  (expr_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph ps) (wi ch th) :=
@imp ph ps (wi ch th)
  (@exp32 ph ps ch th
    expr_1)


/-- Export a wff from a left conjunct. (Contributed by Jeff Hankins, 28-Aug-2009.) -/
theorem expl {ph ps ch th : wff}
  (expl_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi ph (wi (wa ps ch) th) :=
@impd ph ps ch th
  (@exp31 ph ps ch th
    expl_1)


/-- Inference commuting conjunction in antecedent. (Contributed by NM, 21-Apr-1994.) -/
theorem ancoms {ph ps ch : wff}
  (ancoms_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa ps ph) ch :=
@imp ps ph ch
  (@expcom ph ps ch
    ancoms_1)


/-- Theorem *3.22 of [WhiteheadRussell] p. 111. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 13-Nov-2012.) -/
theorem pm3_22 {ph ps : wff} :
  ⊦ wi (wa ph ps) (wa ps ph) :=
@ancoms ps ph (wa ps ph)
  (@id (wa ps ph))


/-- Commutative law for conjunction. Theorem *4.3 of [WhiteheadRussell] p. 118. (Contributed by NM,
25-Jun-1998.) (Proof shortened by Wolf Lammen, 4-Nov-2012.) -/
theorem ancom {ph ps : wff} :
  ⊦ wb (wa ph ps) (wa ps ph) :=
@impbii (wa ph ps) (wa ps ph)
  (@pm3_22 ph ps)
  (@pm3_22 ps ph)


/-- Commutation of conjuncts in consequent. (Contributed by Jeff Hankins, 14-Aug-2009.) -/
theorem ancomd {ph ps ch : wff}
  (ancomd_1 : ⊦ wi ph (wa ps ch)) :
  ⊦ wi ph (wa ch ps) :=
@sylib ph (wa ps ch) (wa ch ps)
  ancomd_1
  (@ancom ps ch)


/-- Commuting conjunction in a biconditional. (Contributed by Peter Mazsa, 17-Jun-2018.) -/
theorem biancomi {ph ps ch : wff}
  (biancomi_1 : ⊦ wb ph (wa ch ps)) :
  ⊦ wb ph (wa ps ch) :=
@bitr4i ph (wa ch ps) (wa ps ch)
  biancomi_1
  (@ancom ps ch)


/-- Commuting conjunction in a biconditional, deduction form. (Contributed by Peter Mazsa,
3-Oct-2018.) -/
theorem biancomd {ph ps ch th : wff}
  (biancomd_1 : ⊦ wi ph (wb ps (wa th ch))) :
  ⊦ wi ph (wb ps (wa ch th)) :=
@bitrdi ph ps (wa th ch) (wa ch th)
  biancomd_1
  (@ancom th ch)


/-- Closed form of ~ ancoms . (Contributed by Alan Sare, 31-Dec-2011.) -/
theorem ancomst {ph ps ch : wff} :
  ⊦ wb (wi (wa ph ps) ch) (wi (wa ps ph) ch) :=
@imbi1i (wa ph ps) (wa ps ph) ch
  (@ancom ph ps)


/-- Deduction commuting conjunction in antecedent. (Contributed by NM, 12-Dec-2004.) -/
theorem ancomsd {ph ps ch th : wff}
  (ancomsd_1 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph (wi (wa ch ps) th) :=
@impd ph ch ps th
  (@expcomd ph ps ch th
    ancomsd_1)


/-- Associative law for conjunction applied to antecedent (eliminates syllogism). (Contributed by
NM, 15-Nov-2002.) -/
theorem anasss {ph ps ch th : wff}
  (anasss_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa ph (wa ps ch)) th :=
@imp32 ph ps ch th
  (@exp31 ph ps ch th
    anasss_1)


/-- Associative law for conjunction applied to antecedent (eliminates syllogism). (Contributed by
NM, 15-Nov-2002.) -/
theorem anassrs {ph ps ch th : wff}
  (anassrs_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa (wa ph ps) ch) th :=
@imp31 ph ps ch th
  (@exp32 ph ps ch th
    anassrs_1)


/-- Associative law for conjunction. Theorem *4.32 of [WhiteheadRussell] p. 118. (Contributed by NM,
21-Jun-1993.) (Proof shortened by Wolf Lammen, 24-Nov-2012.) -/
theorem anass {ph ps ch : wff} :
  ⊦ wb (wa (wa ph ps) ch) (wa ph (wa ps ch)) :=
@impbii (wa (wa ph ps) ch) (wa ph (wa ps ch))
  (@anassrs ph ps ch (wa ph (wa ps ch))
    (@id (wa ph (wa ps ch))))
  (@anasss ph ps ch (wa (wa ph ps) ch)
    (@id (wa (wa ph ps) ch)))


/-- Join antecedents with conjunction ("conjunction introduction"). Theorem *3.2 of
[WhiteheadRussell] p. 111. Its associated inference is ~ pm3.2i and its associated deduction is ~
jca (and the double deduction is ~ jcad ). See ~ pm3.2im for a version using only implication and
negation. (Contributed by NM, 5-Jan-1993.) (Proof shortened by Wolf Lammen, 12-Nov-2012.) -/
theorem pm3_2 {ph ps : wff} :
  ⊦ wi ph (wi ps (wa ph ps)) :=
@ex ph ps (wa ph ps)
  (@id (wa ph ps))


/-- Infer conjunction of premises. Inference associated with ~ pm3.2 . Its associated deduction is ~
jca (and the double deduction is ~ jcad ). (Contributed by NM, 21-Jun-1993.) -/
theorem pm3_2i {ph ps : wff}
  (pm3_2i_1 : ⊦ ph)
  (pm3_2i_2 : ⊦ ps) :
  ⊦ wa ph ps :=
@mp2 ph ps (wa ph ps)
  pm3_2i_1
  pm3_2i_2
  (@pm3_2 ph ps)


/-- Join antecedents with conjunction. Theorem *3.21 of [WhiteheadRussell] p. 111. (Contributed by
NM, 5-Aug-1993.) -/
theorem pm3_21 {ph ps : wff} :
  ⊦ wi ph (wi ps (wa ps ph)) :=
@expcom ps ph (wa ps ph)
  (@id (wa ps ph))


/-- Nested conjunction of antecedents. (Contributed by NM, 4-Jan-1993.) -/
theorem pm3_43i {ph ps ch : wff} :
  ⊦ wi (wi ph ps) (wi (wi ph ch) (wi ph (wa ps ch))) :=
@imim3i ps ch (wa ps ch) ph
  (@pm3_2 ps ch)


/-- Theorem *3.43 (Comp) of [WhiteheadRussell] p. 113. (Contributed by NM, 3-Jan-2005.) -/
theorem pm3_43 {ph ps ch : wff} :
  ⊦ wi (wa (wi ph ps) (wi ph ch)) (wi ph (wa ps ch)) :=
@imp (wi ph ps) (wi ph ch) (wi ph (wa ps ch))
  (@pm3_43i ph ps ch)


/-- A theorem similar to the standard definition of the biconditional. Definition of [Margaris] p.
49. (Contributed by NM, 24-Jan-1993.) -/
theorem dfbi2 {ph ps : wff} :
  ⊦ wb (wb ph ps) (wa (wi ph ps) (wi ps ph)) :=
@bitr4i (wb ph ps) (wn (wi (wi ph ps) (wn (wi ps ph)))) (wa (wi ph ps) (wi ps ph))
  (@dfbi1 ph ps)
  (@df_an (wi ph ps) (wi ps ph))


/-- Importation inference from a logical equivalence. (Contributed by NM, 3-May-1994.) -/
theorem biimpa {ph ps ch : wff}
  (biimpa_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi (wa ph ps) ch :=
@imp ph ps ch
  (@biimpd ph ps ch
    biimpa_1)


/-- Importation inference from a logical equivalence. (Contributed by NM, 3-May-1994.) -/
theorem biimpar {ph ps ch : wff}
  (biimpa_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi (wa ph ch) ps :=
@imp ph ch ps
  (@biimprd ph ps ch
    biimpa_1)


/-- Importation inference from a logical equivalence. (Contributed by NM, 3-May-1994.) -/
theorem biimpac {ph ps ch : wff}
  (biimpa_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi (wa ps ph) ch :=
@imp ps ph ch
  (@biimpcd ph ps ch
    biimpa_1)


/-- Importation inference from a logical equivalence. (Contributed by NM, 3-May-1994.) -/
theorem biimparc {ph ps ch : wff}
  (biimpa_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi (wa ch ph) ps :=
@imp ch ph ps
  (@biimprcd ph ps ch
    biimpa_1)


/-- Inference adding a conjunct to the right of an antecedent. (Contributed by NM, 30-Aug-1993.) -/
theorem adantr {ph ps ch : wff}
  (adantr_1 : ⊦ wi ph ps) :
  ⊦ wi (wa ph ch) ps :=
@imp ph ch ps
  (@a1d ph ps ch
    adantr_1)


/-- Inference adding a conjunct to the left of an antecedent. (Contributed by NM, 30-Aug-1993.)
(Proof shortened by Wolf Lammen, 23-Nov-2012.) -/
theorem adantl {ph ps ch : wff}
  (adantl_1 : ⊦ wi ph ps) :
  ⊦ wi (wa ch ph) ps :=
@ancoms ph ch ps
  (@adantr ph ps ch
    adantl_1)


/-- Elimination of a conjunct. Theorem *3.26 (Simp) of [WhiteheadRussell] p. 112. (Contributed by
NM, 3-Jan-1993.) (Proof shortened by Wolf Lammen, 14-Jun-2022.) -/
theorem simpl {ph ps : wff} :
  ⊦ wi (wa ph ps) ph :=
@adantr ph ph ps
  (@id ph)


/-- Inference eliminating a conjunct. (Contributed by NM, 15-Jun-1994.) -/
theorem simpli {ph ps : wff}
  (simpli_1 : ⊦ wa ph ps) :
  ⊦ ph :=
@ax_mp (wa ph ps) ph
  simpli_1
  (@simpl ph ps)


/-- Elimination of a conjunct. Theorem *3.27 (Simp) of [WhiteheadRussell] p. 112. (Contributed by
NM, 3-Jan-1993.) (Proof shortened by Wolf Lammen, 14-Jun-2022.) -/
theorem simpr {ph ps : wff} :
  ⊦ wi (wa ph ps) ps :=
@adantl ps ps ph
  (@id ps)


/-- Inference eliminating a conjunct. (Contributed by NM, 15-Jun-1994.) -/
theorem simpri {ph ps : wff}
  (simpri_1 : ⊦ wa ph ps) :
  ⊦ ps :=
@ax_mp (wa ph ps) ps
  simpri_1
  (@simpr ph ps)


/-- Introduction of conjunct inside of a contradiction. (Contributed by NM, 16-Sep-1993.) -/
theorem intnan {ph ps : wff}
  (intnan_1 : ⊦ wn ph) :
  ⊦ wn (wa ps ph) :=
@mto (wa ps ph) ph
  intnan_1
  (@simpr ps ph)


/-- Introduction of conjunct inside of a contradiction. (Contributed by NM, 3-Apr-1995.) -/
theorem intnanr {ph ps : wff}
  (intnan_1 : ⊦ wn ph) :
  ⊦ wn (wa ph ps) :=
@mto (wa ph ps) ph
  intnan_1
  (@simpl ph ps)


/-- Introduction of conjunct inside of a contradiction. (Contributed by NM, 10-Jul-2005.) -/
theorem intnand {ph ps ch : wff}
  (intnand_1 : ⊦ wi ph (wn ps)) :
  ⊦ wi ph (wn (wa ch ps)) :=
@nsyl ph ps (wa ch ps)
  intnand_1
  (@simpr ch ps)


/-- Introduction of conjunct inside of a contradiction. (Contributed by NM, 10-Jul-2005.) -/
theorem intnanrd {ph ps ch : wff}
  (intnand_1 : ⊦ wi ph (wn ps)) :
  ⊦ wi ph (wn (wa ps ch)) :=
@nsyl ph ps (wa ps ch)
  intnand_1
  (@simpl ps ch)


/-- Deduction adding a conjunct to the left of an antecedent. (Contributed by NM, 4-May-1994.)
(Proof shortened by Wolf Lammen, 20-Dec-2012.) -/
theorem adantld {ph ps ch th : wff}
  (adantld_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wa th ps) ch) :=
@syl5 (wa th ps) ps ph ch
  (@simpr th ps)
  adantld_1


/-- Deduction adding a conjunct to the right of an antecedent. (Contributed by NM, 4-May-1994.) -/
theorem adantrd {ph ps ch th : wff}
  (adantrd_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wa ps th) ch) :=
@syl5 (wa ps th) ps ph ch
  (@simpl ps th)
  adantrd_1


/-- Deduction eliminating a conjunct. A translation of natural deduction rule ` /\ ` EL ( ` /\ `
elimination left), see ~ natded . (Contributed by NM, 26-May-1993.) -/
theorem simpld {ph ps ch : wff}
  (simpld_1 : ⊦ wi ph (wa ps ch)) :
  ⊦ wi ph ps :=
@syl ph (wa ps ch) ps
  simpld_1
  (@simpl ps ch)


/-- Deduction eliminating a conjunct. (Contributed by NM, 14-May-1993.) A translation of natural
deduction rule ` /\ ` ER ( ` /\ ` elimination right), see ~ natded . (Proof shortened by Wolf
Lammen, 3-Oct-2013.) -/
theorem simprd {ph ps ch : wff}
  (simprd_1 : ⊦ wi ph (wa ps ch)) :
  ⊦ wi ph ch :=
@simpld ph ch ps
  (@ancomd ph ps ch
    simprd_1)


/-- Deduction eliminating a conjunct. (Contributed by NM, 27-May-1998.) -/
theorem simprbi {ph ps ch : wff}
  (simprbi_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ph ch :=
@simprd ph ps ch
  (@biimpi ph (wa ps ch)
    simprbi_1)


/-- Deduction eliminating a conjunct. (Contributed by NM, 27-May-1998.) -/
theorem simplbi {ph ps ch : wff}
  (simplbi_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ph ps :=
@simpld ph ps ch
  (@biimpi ph (wa ps ch)
    simplbi_1)


/-- Deduction eliminating a conjunct. (Contributed by NM, 22-Oct-2007.) -/
theorem simprbda {ph ps ch th : wff}
  (pm3_26bda_1 : ⊦ wi ph (wb ps (wa ch th))) :
  ⊦ wi (wa ph ps) ch :=
@simpld (wa ph ps) ch th
  (@biimpa ph ps (wa ch th)
    pm3_26bda_1)


/-- Deduction eliminating a conjunct. (Contributed by NM, 22-Oct-2007.) -/
theorem simplbda {ph ps ch th : wff}
  (pm3_26bda_1 : ⊦ wi ph (wb ps (wa ch th))) :
  ⊦ wi (wa ph ps) th :=
@simprd (wa ph ps) ch th
  (@biimpa ph ps (wa ch th)
    pm3_26bda_1)


/-- Deduction eliminating a conjunct. (Contributed by Alan Sare, 31-Dec-2011.) -/
theorem simplbi2 {ph ps ch : wff}
  (simplbi2_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ps (wi ch ph) :=
@ex ps ch ph
  (@biimpri ph (wa ps ch)
    simplbi2_1)


/-- A deduction eliminating a conjunct, similar to ~ simplbi2 . (Contributed by Alan Sare,
22-Jul-2012.) (Proof shortened by Wolf Lammen, 10-Nov-2012.) -/
theorem simplbi2com {ph ps ch : wff}
  (simplbi2com_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ch (wi ps ph) :=
@com12 ps ch ph
  (@simplbi2 ph ps ch
    simplbi2com_1)


/-- Implication from an eliminated conjunct implied by the antecedent. (Contributed by BJ/AV,
5-Apr-2021.) (Proof shortened by Wolf Lammen, 26-Mar-2022.) -/
theorem simpl2im {ph ps ch th : wff}
  (simpl2im_1 : ⊦ wi ph (wa ps ch))
  (simpl2im_2 : ⊦ wi ch th) :
  ⊦ wi ph th :=
@syl ph ch th
  (@simprd ph ps ch
    simpl2im_1)
  simpl2im_2


/-- Implication from an eliminated conjunct equivalent to the antecedent. (Contributed by Jonathan
Ben-Naim, 3-Jun-2011.) (Proof shortened by Wolf Lammen, 26-Mar-2022.) -/
theorem simplbiim {ph ps ch th : wff}
  (simplbiim_1 : ⊦ wb ph (wa ps ch))
  (simplbiim_2 : ⊦ wi ch th) :
  ⊦ wi ph th :=
@syl ph ch th
  (@simprbi ph ps ch
    simplbiim_1)
  simplbiim_2


/-- An inference for implication elimination. (Contributed by Giovanni Mascellani, 23-May-2019.)
(Proof shortened by Wolf Lammen, 2-Sep-2020.) -/
theorem impel {ph ps ch th : wff}
  (impel_1 : ⊦ wi ph (wi ps ch))
  (impel_2 : ⊦ wi th ps) :
  ⊦ wi (wa ph th) ch :=
@imp ph th ch
  (@syl5 th ps ph ch
    impel_2
    impel_1)


/-- Modus ponens conjoining dissimilar antecedents. (Contributed by NM, 1-Feb-2008.) (Proof
shortened by Andrew Salmon, 7-May-2011.) -/
theorem mpan9 {ph ps ch th : wff}
  (mpan9_1 : ⊦ wi ph ps)
  (mpan9_2 : ⊦ wi ch (wi ps th)) :
  ⊦ wi (wa ph ch) th :=
@impcom ch ph th
  (@syl5 ph ps ch th
    mpan9_1
    mpan9_2)


/-- Nested syllogism inference conjoining dissimilar antecedents. (Contributed by NM, 14-May-1993.)
(Proof shortened by Andrew Salmon, 7-May-2011.) -/
theorem sylan9 {ph ps ch th ta : wff}
  (sylan9_1 : ⊦ wi ph (wi ps ch))
  (sylan9_2 : ⊦ wi th (wi ch ta)) :
  ⊦ wi (wa ph th) (wi ps ta) :=
@imp ph th (wi ps ta)
  (@syl9 ph ps ch th ta
    sylan9_1
    sylan9_2)


/-- Nested syllogism inference conjoining dissimilar antecedents. (Contributed by NM, 14-May-1993.)
-/
theorem sylan9r {ph ps ch th ta : wff}
  (sylan9r_1 : ⊦ wi ph (wi ps ch))
  (sylan9r_2 : ⊦ wi th (wi ch ta)) :
  ⊦ wi (wa th ph) (wi ps ta) :=
@imp th ph (wi ps ta)
  (@syl9r ph ps ch th ta
    sylan9r_1
    sylan9r_2)


/-- Nested syllogism inference conjoining dissimilar antecedents. (Contributed by NM, 4-Mar-1995.)
-/
theorem sylan9bb {ph ps ch th ta : wff}
  (sylan9bb_1 : ⊦ wi ph (wb ps ch))
  (sylan9bb_2 : ⊦ wi th (wb ch ta)) :
  ⊦ wi (wa ph th) (wb ps ta) :=
@bitrd (wa ph th) ps ch ta
  (@adantr ph (wb ps ch) th
    sylan9bb_1)
  (@adantl th (wb ch ta) ph
    sylan9bb_2)


/-- Nested syllogism inference conjoining dissimilar antecedents. (Contributed by NM, 4-Mar-1995.)
-/
theorem sylan9bbr {ph ps ch th ta : wff}
  (sylan9bbr_1 : ⊦ wi ph (wb ps ch))
  (sylan9bbr_2 : ⊦ wi th (wb ch ta)) :
  ⊦ wi (wa th ph) (wb ps ta) :=
@ancoms ph th (wb ps ta)
  (@sylan9bb ph ps ch th ta
    sylan9bbr_1
    sylan9bbr_2)


/-- Deduce conjunction of the consequents of two implications ("join consequents with 'and'").
Deduction form of ~ pm3.2 and ~ pm3.2i . Its associated deduction is ~ jcad . Equivalent to the
natural deduction rule ` /\ ` I ( ` /\ ` introduction), see ~ natded . (Contributed by NM,
3-Jan-1993.) (Proof shortened by Wolf Lammen, 25-Oct-2012.) -/
theorem jca {ph ps ch : wff}
  (jca_1 : ⊦ wi ph ps)
  (jca_2 : ⊦ wi ph ch) :
  ⊦ wi ph (wa ps ch) :=
@sylc ph ps ch (wa ps ch)
  jca_1
  jca_2
  (@pm3_2 ps ch)


/-- Deduction conjoining the consequents of two implications. Deduction form of ~ jca and double
deduction form of ~ pm3.2 and ~ pm3.2i . (Contributed by NM, 15-Jul-1993.) (Proof shortened by Wolf
Lammen, 23-Jul-2013.) -/
theorem jcad {ph ps ch th : wff}
  (jcad_1 : ⊦ wi ph (wi ps ch))
  (jcad_2 : ⊦ wi ph (wi ps th)) :
  ⊦ wi ph (wi ps (wa ch th)) :=
@syl6c ph ps ch th (wa ch th)
  jcad_1
  jcad_2
  (@pm3_2 ch th)


/-- Inference conjoining the consequents of two implications. (Contributed by Rodolfo Medina,
12-Oct-2010.) -/
theorem jca2 {ph ps ch th : wff}
  (jca2_1 : ⊦ wi ph (wi ps ch))
  (jca2_2 : ⊦ wi ps th) :
  ⊦ wi ph (wi ps (wa ch th)) :=
@jcad ph ps ch th
  jca2_1
  (@a1i (wi ps th) ph
    jca2_2)


/-- Join three consequents. (Contributed by Jeff Hankins, 1-Aug-2009.) -/
theorem jca31 {ph ps ch th : wff}
  (jca31_1 : ⊦ wi ph ps)
  (jca31_2 : ⊦ wi ph ch)
  (jca31_3 : ⊦ wi ph th) :
  ⊦ wi ph (wa (wa ps ch) th) :=
@jca ph (wa ps ch) th
  (@jca ph ps ch
    jca31_1
    jca31_2)
  jca31_3


/-- Join three consequents. (Contributed by FL, 1-Aug-2009.) -/
theorem jca32 {ph ps ch th : wff}
  (jca31_1 : ⊦ wi ph ps)
  (jca31_2 : ⊦ wi ph ch)
  (jca31_3 : ⊦ wi ph th) :
  ⊦ wi ph (wa ps (wa ch th)) :=
@jca ph ps (wa ch th)
  jca31_1
  (@jca ph ch th
    jca31_2
    jca31_3)


/-- Deduction replacing implication with conjunction. (Contributed by NM, 15-Jul-1993.) -/
theorem jcai {ph ps ch : wff}
  (jcai_1 : ⊦ wi ph ps)
  (jcai_2 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wa ps ch) :=
@jca ph ps ch
  jcai_1
  (@mpd ph ps ch
    jcai_1
    jcai_2)


/-- Distributive law for implication over conjunction. Compare Theorem *4.76 of [WhiteheadRussell]
p. 121. (Contributed by NM, 3-Apr-1994.) (Proof shortened by Wolf Lammen, 27-Nov-2013.) -/
theorem jcab {ph ps ch : wff} :
  ⊦ wb (wi ph (wa ps ch)) (wa (wi ph ps) (wi ph ch)) :=
@impbii (wi ph (wa ps ch)) (wa (wi ph ps) (wi ph ch))
  (@jca (wi ph (wa ps ch)) (wi ph ps) (wi ph ch)
    (@imim2i (wa ps ch) ps ph
      (@simpl ps ch))
    (@imim2i (wa ps ch) ch ph
      (@simpr ps ch)))
  (@pm3_43 ph ps ch)


/-- Inference conjoining a theorem to left of consequent in an implication. (Contributed by NM,
31-Dec-1993.) -/
theorem jctil {ph ps ch : wff}
  (jctil_1 : ⊦ wi ph ps)
  (jctil_2 : ⊦ ch) :
  ⊦ wi ph (wa ch ps) :=
@jca ph ch ps
  (@a1i ch ph
    jctil_2)
  jctil_1


/-- Inference conjoining a theorem to right of consequent in an implication. (Contributed by NM,
31-Dec-1993.) -/
theorem jctir {ph ps ch : wff}
  (jctil_1 : ⊦ wi ph ps)
  (jctil_2 : ⊦ ch) :
  ⊦ wi ph (wa ps ch) :=
@jca ph ps ch
  jctil_1
  (@a1i ch ph
    jctil_2)


/-- Inference conjoining a theorem to the left of a consequent. (Contributed by NM, 31-Dec-1993.)
(Proof shortened by Wolf Lammen, 24-Oct-2012.) -/
theorem jctl {ph ps : wff}
  (jctl_1 : ⊦ ps) :
  ⊦ wi ph (wa ps ph) :=
@jctil ph ph ps
  (@id ph)
  jctl_1


/-- Inference conjoining a theorem to the right of a consequent. (Contributed by NM, 18-Aug-1993.)
(Proof shortened by Wolf Lammen, 24-Oct-2012.) -/
theorem jctr {ph ps : wff}
  (jctl_1 : ⊦ ps) :
  ⊦ wi ph (wa ph ps) :=
@jctir ph ph ps
  (@id ph)
  jctl_1


/-- Deduction conjoining a theorem to left of consequent in an implication. (Contributed by NM,
21-Apr-2005.) -/
theorem jctild {ph ps ch th : wff}
  (jctild_1 : ⊦ wi ph (wi ps ch))
  (jctild_2 : ⊦ wi ph th) :
  ⊦ wi ph (wi ps (wa th ch)) :=
@jcad ph ps th ch
  (@a1d ph th ps
    jctild_2)
  jctild_1


/-- Deduction conjoining a theorem to right of consequent in an implication. (Contributed by NM,
21-Apr-2005.) -/
theorem jctird {ph ps ch th : wff}
  (jctird_1 : ⊦ wi ph (wi ps ch))
  (jctird_2 : ⊦ wi ph th) :
  ⊦ wi ph (wi ps (wa ch th)) :=
@jcad ph ps ch th
  jctird_1
  (@a1d ph th ps
    jctird_2)


/-- Introduction of antecedent as conjunct. Theorem *4.73 of [WhiteheadRussell] p. 121. (Contributed
by NM, 30-Mar-1994.) -/
theorem iba {ph ps : wff} :
  ⊦ wi ph (wb ps (wa ps ph)) :=
@impbid1 ph ps (wa ps ph)
  (@pm3_21 ph ps)
  (@simpl ps ph)


/-- Introduction of antecedent as conjunct. (Contributed by NM, 5-Dec-1995.) -/
theorem ibar {ph ps : wff} :
  ⊦ wi ph (wb ps (wa ph ps)) :=
@biancomd ph ps ph ps
  (@iba ph ps)


/-- A wff is equivalent to its conjunction with truth. (Contributed by NM, 26-May-1993.) -/
theorem biantru {ph ps : wff}
  (biantru_1 : ⊦ ph) :
  ⊦ wb ps (wa ps ph) :=
@ax_mp ph (wb ps (wa ps ph))
  biantru_1
  (@iba ph ps)


/-- A wff is equivalent to its conjunction with truth. (Contributed by NM, 3-Aug-1994.) -/
theorem biantrur {ph ps : wff}
  (biantrur_1 : ⊦ ph) :
  ⊦ wb ps (wa ph ps) :=
@biancomi ps ph ps
  (@biantru ph ps
    biantrur_1)


/-- A wff is equivalent to its conjunction with truth. (Contributed by NM, 2-Aug-1994.) (Proof
shortened by Wolf Lammen, 23-Oct-2013.) -/
theorem biantrud {ph ps ch : wff}
  (biantrud_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wb ch (wa ch ps)) :=
@syl ph ps (wb ch (wa ch ps))
  biantrud_1
  (@iba ps ch)


/-- A wff is equivalent to its conjunction with truth. (Contributed by NM, 1-May-1995.) (Proof
shortened by Andrew Salmon, 7-May-2011.) -/
theorem biantrurd {ph ps ch : wff}
  (biantrud_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wb ch (wa ps ch)) :=
@syl ph ps (wb ch (wa ps ch))
  biantrud_1
  (@ibar ps ch)


/-- A wff conjoined with falsehood is false. (Contributed by NM, 21-Jun-1993.) (Proof shortened by
Wolf Lammen, 26-Nov-2012.) -/
theorem bianfi {ph ps : wff}
  (bianfi_1 : ⊦ wn ph) :
  ⊦ wb ph (wa ps ph) :=
@«2false» ph (wa ps ph)
  bianfi_1
  (@intnan ph ps
    bianfi_1)


/-- Move conjunction outside of biconditional. (Contributed by NM, 13-May-1999.) -/
theorem baib {ph ps ch : wff}
  (baib_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ps (wb ph ch) :=
@bitr4id ps ph (wa ps ch) ch
  baib_1
  (@ibar ps ch)


/-- Move conjunction outside of biconditional. (Contributed by NM, 11-Jul-1994.) -/
theorem baibr {ph ps ch : wff}
  (baib_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ps (wb ch ph) :=
@bicomd ps ph ch
  (@baib ph ps ch
    baib_1)


/-- Move conjunction outside of biconditional. (Contributed by Mario Carneiro, 11-Sep-2015.) (Proof
shortened by Wolf Lammen, 19-Jan-2020.) -/
theorem rbaibr {ph ps ch : wff}
  (baib_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ch (wb ps ph) :=
@baibr ph ch ps
  (@biancomi ph ch ps
    baib_1)


/-- Move conjunction outside of biconditional. (Contributed by Mario Carneiro, 11-Sep-2015.) (Proof
shortened by Wolf Lammen, 19-Jan-2020.) -/
theorem rbaib {ph ps ch : wff}
  (baib_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wi ch (wb ph ps) :=
@bicomd ch ps ph
  (@rbaibr ph ps ch
    baib_1)


/-- Move conjunction outside of biconditional. (Contributed by Mario Carneiro, 11-Sep-2015.) -/
theorem baibd {ph ps ch th : wff}
  (baibd_1 : ⊦ wi ph (wb ps (wa ch th))) :
  ⊦ wi (wa ph ch) (wb ps th) :=
@sylan9bb ph ps (wa ch th) ch th
  baibd_1
  (@bicomd ch th (wa ch th)
    (@ibar ch th))


/-- Move conjunction outside of biconditional. (Contributed by Mario Carneiro, 11-Sep-2015.) -/
theorem rbaibd {ph ps ch th : wff}
  (baibd_1 : ⊦ wi ph (wb ps (wa ch th))) :
  ⊦ wi (wa ph th) (wb ps ch) :=
@baibd ph ps th ch
  (@biancomd ph ps th ch
    baibd_1)


/-- Absorb a hypothesis into the second member of a biconditional. (Contributed by FL, 15-Feb-2007.)
-/
theorem bianabs {ph ps ch : wff}
  (bianabs_1 : ⊦ wi ph (wb ps (wa ph ch))) :
  ⊦ wi ph (wb ps ch) :=
@bitr4d ph ps (wa ph ch) ch
  bianabs_1
  (@ibar ph ch)


/-- Theorem *5.44 of [WhiteheadRussell] p. 125. (Contributed by NM, 3-Jan-2005.) -/
theorem pm5_44 {ph ps ch : wff} :
  ⊦ wi (wi ph ps) (wb (wi ph ch) (wi ph (wa ps ch))) :=
@baibr (wi ph (wa ps ch)) (wi ph ps) (wi ph ch)
  (@jcab ph ps ch)


/-- Theorem *5.42 of [WhiteheadRussell] p. 125. (Contributed by NM, 3-Jan-2005.) -/
theorem pm5_42 {ph ps ch : wff} :
  ⊦ wb (wi ph (wi ps ch)) (wi ph (wi ps (wa ph ch))) :=
@pm5_74i ph (wi ps ch) (wi ps (wa ph ch))
  (@imbi2d ph ch (wa ph ch) ps
    (@ibar ph ch))


/-- Conjoin antecedent to left of consequent. (Contributed by NM, 15-Aug-1994.) -/
theorem ancl {ph ps : wff} :
  ⊦ wi (wi ph ps) (wi ph (wa ph ps)) :=
@a2i ph ps (wa ph ps)
  (@pm3_2 ph ps)


/-- Conjoin antecedent to left of consequent. Theorem *4.7 of [WhiteheadRussell] p. 120.
(Contributed by NM, 25-Jul-1999.) (Proof shortened by Wolf Lammen, 24-Mar-2013.) -/
theorem anclb {ph ps : wff} :
  ⊦ wb (wi ph ps) (wi ph (wa ph ps)) :=
@pm5_74i ph ps (wa ph ps)
  (@ibar ph ps)


/-- Conjoin antecedent to right of consequent. (Contributed by NM, 15-Aug-1994.) -/
theorem ancr {ph ps : wff} :
  ⊦ wi (wi ph ps) (wi ph (wa ps ph)) :=
@a2i ph ps (wa ps ph)
  (@pm3_21 ph ps)


/-- Deduction conjoining antecedent to left of consequent. (Contributed by NM, 12-Aug-1993.) -/
theorem ancli {ph ps : wff}
  (ancli_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wa ph ps) :=
@jca ph ph ps
  (@id ph)
  ancli_1


/-- Deduction conjoining antecedent to right of consequent. (Contributed by NM, 15-Aug-1994.) -/
theorem ancri {ph ps : wff}
  (ancri_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wa ps ph) :=
@jca ph ps ph
  ancri_1
  (@id ph)


/-- Deduction conjoining antecedent to left of consequent in nested implication. (Contributed by NM,
15-Aug-1994.) (Proof shortened by Wolf Lammen, 1-Nov-2012.) -/
theorem ancld {ph ps ch : wff}
  (ancld_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi ps (wa ps ch)) :=
@jcad ph ps ps ch
  (@idd ph ps)
  ancld_1


/-- Deduction conjoining antecedent to right of consequent in nested implication. (Contributed by
NM, 15-Aug-1994.) (Proof shortened by Wolf Lammen, 1-Nov-2012.) -/
theorem ancrd {ph ps ch : wff}
  (ancrd_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi ps (wa ch ps)) :=
@jcad ph ps ch ps
  ancrd_1
  (@idd ph ps)


/-- Importation with conjunction in consequent. (Contributed by NM, 9-Aug-1994.) -/
theorem impac {ph ps ch : wff}
  (impac_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wa ph ps) (wa ch ps) :=
@imp ph ps (wa ch ps)
  (@ancrd ph ps ch
    impac_1)


/-- Conjoin antecedent to right of consequent in nested implication. (Contributed by NM,
15-Aug-1994.) -/
theorem anc2r {ph ps ch : wff} :
  ⊦ wi (wi ph (wi ps ch)) (wi ph (wi ps (wa ch ph))) :=
@a2i ph (wi ps ch) (wi ps (wa ch ph))
  (@imim2d ph ch (wa ch ph) ps
    (@pm3_21 ph ch))


/-- Deduction conjoining antecedent to left of consequent in nested implication. (Contributed by NM,
10-Aug-1994.) (Proof shortened by Wolf Lammen, 7-Dec-2012.) -/
theorem anc2li {ph ps ch : wff}
  (anc2li_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi ps (wa ph ch)) :=
@jctild ph ps ch ph
  anc2li_1
  (@id ph)


/-- Implication in terms of biconditional and conjunction. Theorem *4.71 of [WhiteheadRussell] p.
120. (Contributed by NM, 21-Jun-1993.) (Proof shortened by Wolf Lammen, 2-Dec-2012.) -/
theorem pm4_71 {ph ps : wff} :
  ⊦ wb (wi ph ps) (wb ph (wa ph ps)) :=
@«3bitr4i» (wi ph (wa ph ps)) (wa (wi ph (wa ph ps)) (wi (wa ph ps) ph)) (wi ph ps) (wb ph (wa ph ps))
  (@biantru (wi (wa ph ps) ph) (wi ph (wa ph ps))
    (@simpl ph ps))
  (@anclb ph ps)
  (@dfbi2 ph (wa ph ps))


/-- Implication in terms of biconditional and conjunction. Theorem *4.71 of [WhiteheadRussell] p.
120 (with conjunct reversed). (Contributed by NM, 25-Jul-1999.) -/
theorem pm4_71r {ph ps : wff} :
  ⊦ wb (wi ph ps) (wb ph (wa ps ph)) :=
@bitri (wi ph ps) (wb ph (wa ph ps)) (wb ph (wa ps ph))
  (@pm4_71 ph ps)
  (@bibi2i (wa ph ps) (wa ps ph) ph
    (@ancom ph ps))


/-- Inference converting an implication to a biconditional with conjunction. Inference from Theorem
*4.71 of [WhiteheadRussell] p. 120. (Contributed by NM, 4-Jan-2004.) -/
theorem pm4_71i {ph ps : wff}
  (pm4_71i_1 : ⊦ wi ph ps) :
  ⊦ wb ph (wa ph ps) :=
@mpbi (wi ph ps) (wb ph (wa ph ps))
  pm4_71i_1
  (@pm4_71 ph ps)


/-- Inference converting an implication to a biconditional with conjunction. Inference from Theorem
*4.71 of [WhiteheadRussell] p. 120 (with conjunct reversed). (Contributed by NM, 1-Dec-2003.) -/
theorem pm4_71ri {ph ps : wff}
  (pm4_71ri_1 : ⊦ wi ph ps) :
  ⊦ wb ph (wa ps ph) :=
@biancomi ph ps ph
  (@pm4_71i ph ps
    pm4_71ri_1)


/-- Deduction converting an implication to a biconditional with conjunction. Deduction from Theorem
*4.71 of [WhiteheadRussell] p. 120. (Contributed by Mario Carneiro, 25-Dec-2016.) -/
theorem pm4_71d {ph ps ch : wff}
  (pm4_71rd_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wb ps (wa ps ch)) :=
@sylib ph (wi ps ch) (wb ps (wa ps ch))
  pm4_71rd_1
  (@pm4_71 ps ch)


/-- Deduction converting an implication to a biconditional with conjunction. Deduction from Theorem
*4.71 of [WhiteheadRussell] p. 120. (Contributed by NM, 10-Feb-2005.) -/
theorem pm4_71rd {ph ps ch : wff}
  (pm4_71rd_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wb ps (wa ch ps)) :=
@biancomd ph ps ch ps
  (@pm4_71d ph ps ch
    pm4_71rd_1)


/-- Theorem *4.24 of [WhiteheadRussell] p. 117. (Contributed by NM, 11-May-1993.) -/
theorem pm4_24 {ph : wff} :
  ⊦ wb ph (wa ph ph) :=
@pm4_71i ph ph
  (@id ph)


/-- Idempotent law for conjunction. (Contributed by NM, 8-Jan-2004.) (Proof shortened by Wolf
Lammen, 14-Mar-2014.) -/
theorem anidm {ph : wff} :
  ⊦ wb (wa ph ph) ph :=
@bicomi ph (wa ph ph)
  (@pm4_24 ph)


/-- Inference from idempotent law for conjunction. (Contributed by NM, 15-Jun-1994.) -/
theorem anidms {ph ps : wff}
  (anidms_1 : ⊦ wi (wa ph ph) ps) :
  ⊦ wi ph ps :=
@pm2_43i ph ps
  (@ex ph ph ps
    anidms_1)


/-- Distribution of implication with conjunction. (Contributed by NM, 31-May-1999.) (Proof shortened
by Wolf Lammen, 6-Dec-2012.) -/
theorem imdistan {ph ps ch : wff} :
  ⊦ wb (wi ph (wi ps ch)) (wi (wa ph ps) (wa ph ch)) :=
@bitr4i (wi ph (wi ps ch)) (wi ph (wi ps (wa ph ch))) (wi (wa ph ps) (wa ph ch))
  (@pm5_42 ph ps ch)
  (@impexp ph ps (wa ph ch))


/-- Distribution of implication with conjunction. (Contributed by NM, 1-Aug-1994.) -/
theorem imdistani {ph ps ch : wff}
  (imdistani_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi (wa ph ps) (wa ph ch) :=
@imp ph ps (wa ph ch)
  (@anc2li ph ps ch
    imdistani_1)


/-- Distribution of implication with conjunction (deduction form). (Contributed by NM, 27-Aug-2004.)
-/
theorem imdistand {ph ps ch th : wff}
  (imdistand_1 : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi ph (wi (wa ps ch) (wa ps th)) :=
@sylib ph (wi ps (wi ch th)) (wi (wa ps ch) (wa ps th))
  imdistand_1
  (@imdistan ps ch th)


/-- Distribution of implication with conjunction (deduction version with conjoined antecedent).
(Contributed by Jeff Madsen, 19-Jun-2011.) -/
theorem imdistanda {ph ps ch th : wff}
  (imdistanda_1 : ⊦ wi (wa ph ps) (wi ch th)) :
  ⊦ wi ph (wi (wa ps ch) (wa ps th)) :=
@imdistand ph ps ch th
  (@ex ph ps (wi ch th)
    imdistanda_1)


/-- Distribution of implication over biconditional. Theorem *5.32 of [WhiteheadRussell] p. 125.
(Contributed by NM, 1-Aug-1994.) -/
theorem pm5_32 {ph ps ch : wff} :
  ⊦ wb (wi ph (wb ps ch)) (wb (wa ph ps) (wa ph ch)) :=
@bitr4i (wi ph (wb ps ch)) (wb (wn (wi ph (wn ps))) (wn (wi ph (wn ch)))) (wb (wa ph ps) (wa ph ch))
  (@«3bitri» (wi ph (wb ps ch)) (wi ph (wb (wn ps) (wn ch))) (wb (wi ph (wn ps)) (wi ph (wn ch))) (wb (wn (wi ph (wn ps))) (wn (wi ph (wn ch))))
    (@imbi2i (wb ps ch) (wb (wn ps) (wn ch)) ph
      (@notbi ps ch))
    (@pm5_74 ph (wn ps) (wn ch))
    (@notbi (wi ph (wn ps)) (wi ph (wn ch))))
  (@bibi12i (wa ph ps) (wn (wi ph (wn ps))) (wa ph ch) (wn (wi ph (wn ch)))
    (@df_an ph ps)
    (@df_an ph ch))


/-- Distribution of implication over biconditional (inference form). (Contributed by NM,
1-Aug-1994.) -/
theorem pm5_32i {ph ps ch : wff}
  (pm5_32i_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wb (wa ph ps) (wa ph ch) :=
@mpbi (wi ph (wb ps ch)) (wb (wa ph ps) (wa ph ch))
  pm5_32i_1
  (@pm5_32 ph ps ch)


/-- Distribution of implication over biconditional (inference form). (Contributed by NM,
12-Mar-1995.) -/
theorem pm5_32ri {ph ps ch : wff}
  (pm5_32i_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wb (wa ps ph) (wa ch ph) :=
@«3bitr4i» (wa ph ps) (wa ph ch) (wa ps ph) (wa ch ph)
  (@pm5_32i ph ps ch
    pm5_32i_1)
  (@ancom ps ph)
  (@ancom ch ph)


/-- Distribution of implication over biconditional (deduction form). (Contributed by NM,
29-Oct-1996.) -/
theorem pm5_32d {ph ps ch th : wff}
  (pm5_32d_1 : ⊦ wi ph (wi ps (wb ch th))) :
  ⊦ wi ph (wb (wa ps ch) (wa ps th)) :=
@sylib ph (wi ps (wb ch th)) (wb (wa ps ch) (wa ps th))
  pm5_32d_1
  (@pm5_32 ps ch th)


/-- Distribution of implication over biconditional (deduction form). (Contributed by NM,
25-Dec-2004.) -/
theorem pm5_32rd {ph ps ch th : wff}
  (pm5_32d_1 : ⊦ wi ph (wi ps (wb ch th))) :
  ⊦ wi ph (wb (wa ch ps) (wa th ps)) :=
@«3bitr4g» ph (wa ps ch) (wa ps th) (wa ch ps) (wa th ps)
  (@pm5_32d ph ps ch th
    pm5_32d_1)
  (@ancom ch ps)
  (@ancom th ps)


/-- Distribution of implication over biconditional (deduction form). (Contributed by NM,
9-Dec-2006.) -/
theorem pm5_32da {ph ps ch th : wff}
  (pm5_32da_1 : ⊦ wi (wa ph ps) (wb ch th)) :
  ⊦ wi ph (wb (wa ps ch) (wa ps th)) :=
@pm5_32d ph ps ch th
  (@ex ph ps (wb ch th)
    pm5_32da_1)


/-- A syllogism inference. (Contributed by NM, 21-Apr-1994.) (Proof shortened by Wolf Lammen,
22-Nov-2012.) -/
theorem sylan {ph ps ch th : wff}
  (sylan_1 : ⊦ wi ph ps)
  (sylan_2 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ph ch) th :=
@mpan9 ph ps ch th
  sylan_1
  (@expcom ps ch th
    sylan_2)


/-- A syllogism inference. (Contributed by NM, 18-May-1994.) -/
theorem sylanb {ph ps ch th : wff}
  (sylanb_1 : ⊦ wb ph ps)
  (sylanb_2 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ph ch) th :=
@sylan ph ps ch th
  (@biimpi ph ps
    sylanb_1)
  sylanb_2


/-- A syllogism inference. (Contributed by NM, 18-May-1994.) -/
theorem sylanbr {ph ps ch th : wff}
  (sylanbr_1 : ⊦ wb ps ph)
  (sylanbr_2 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ph ch) th :=
@sylan ph ps ch th
  (@biimpri ps ph
    sylanbr_1)
  sylanbr_2


/-- Syllogism inference. (Contributed by Jeff Madsen, 2-Sep-2009.) -/
theorem sylanbrc {ph ps ch th : wff}
  (sylanbrc_1 : ⊦ wi ph ps)
  (sylanbrc_2 : ⊦ wi ph ch)
  (sylanbrc_3 : ⊦ wb th (wa ps ch)) :
  ⊦ wi ph th :=
@sylibr ph (wa ps ch) th
  (@jca ph ps ch
    sylanbrc_1
    sylanbrc_2)
  sylanbrc_3


/-- Syllogism inference combined with contraction. (Contributed by NM, 16-Mar-2012.) -/
theorem syl2anc {ph ps ch th : wff}
  (syl2anc_1 : ⊦ wi ph ps)
  (syl2anc_2 : ⊦ wi ph ch)
  (syl2anc_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi ph th :=
@sylc ph ps ch th
  syl2anc_1
  syl2anc_2
  (@ex ps ch th
    syl2anc_3)


/-- Double syllogism inference combined with contraction. (Contributed by BTernaryTau, 29-Sep-2023.)
-/
theorem syl2anc2 {ph ps ch th : wff}
  (syl2anc2_1 : ⊦ wi ph ps)
  (syl2anc2_2 : ⊦ wi ps ch)
  (syl2anc2_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi ph th :=
@syl2anc ph ps ch th
  syl2anc2_1
  (@syl ph ps ch
    syl2anc2_1
    syl2anc2_2)
  syl2anc2_3


/-- Syllogism inference combined with modus ponens. (Contributed by Jeff Madsen, 2-Sep-2009.) -/
theorem sylancl {ph ps ch th : wff}
  (sylancl_1 : ⊦ wi ph ps)
  (sylancl_2 : ⊦ ch)
  (sylancl_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi ph th :=
@syl2anc ph ps ch th
  sylancl_1
  (@a1i ch ph
    sylancl_2)
  sylancl_3


/-- Syllogism inference combined with modus ponens. (Contributed by Jeff Madsen, 2-Sep-2009.) -/
theorem sylancr {ph ps ch th : wff}
  (sylancr_1 : ⊦ ps)
  (sylancr_2 : ⊦ wi ph ch)
  (sylancr_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi ph th :=
@syl2anc ph ps ch th
  (@a1i ps ph
    sylancr_1)
  sylancr_2
  sylancr_3


/-- Syllogism inference with commutation of antecedents. (Contributed by NM, 2-Jul-2008.) -/
theorem sylancom {ph ps ch th : wff}
  (sylancom_1 : ⊦ wi (wa ph ps) ch)
  (sylancom_2 : ⊦ wi (wa ch ps) th) :
  ⊦ wi (wa ph ps) th :=
@syl2anc (wa ph ps) ch ps th
  sylancom_1
  (@simpr ph ps)
  sylancom_2


/-- Syllogism inference combined with a biconditional. (Contributed by BJ, 25-Apr-2019.) -/
theorem sylanblc {ph ps ch th : wff}
  (sylanblc_1 : ⊦ wi ph ps)
  (sylanblc_2 : ⊦ ch)
  (sylanblc_3 : ⊦ wb (wa ps ch) th) :
  ⊦ wi ph th :=
@sylancl ph ps ch th
  sylanblc_1
  sylanblc_2
  (@biimpi (wa ps ch) th
    sylanblc_3)


/-- Syllogism inference combined with a biconditional. (Contributed by BJ, 25-Apr-2019.) -/
theorem sylanblrc {ph ps ch th : wff}
  (sylanblrc_1 : ⊦ wi ph ps)
  (sylanblrc_2 : ⊦ ch)
  (sylanblrc_3 : ⊦ wb th (wa ps ch)) :
  ⊦ wi ph th :=
@sylanbrc ph ps ch th
  sylanblrc_1
  (@a1i ch ph
    sylanblrc_2)
  sylanblrc_3


/-- A syllogism deduction with conjoined antecedents. (Contributed by NM, 24-Feb-2005.) (Proof
shortened by Wolf Lammen, 6-Apr-2013.) -/
theorem syldan {ph ps ch th : wff}
  (syldan_1 : ⊦ wi (wa ph ps) ch)
  (syldan_2 : ⊦ wi (wa ph ch) th) :
  ⊦ wi (wa ph ps) th :=
@syl2anc (wa ph ps) ph ch th
  (@simpl ph ps)
  syldan_1
  syldan_2


/-- A syllogism inference. (Contributed by NM, 21-Apr-1994.) (Proof shortened by Wolf Lammen,
22-Nov-2012.) -/
theorem sylan2 {ph ps ch th : wff}
  (sylan2_1 : ⊦ wi ph ch)
  (sylan2_2 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ps ph) th :=
@syldan ps ph ch th
  (@adantl ph ch ps
    sylan2_1)
  sylan2_2


/-- A syllogism inference. (Contributed by NM, 21-Apr-1994.) -/
theorem sylan2b {ph ps ch th : wff}
  (sylan2b_1 : ⊦ wb ph ch)
  (sylan2b_2 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ps ph) th :=
@sylan2 ph ps ch th
  (@biimpi ph ch
    sylan2b_1)
  sylan2b_2


/-- A syllogism inference. (Contributed by NM, 21-Apr-1994.) -/
theorem sylan2br {ph ps ch th : wff}
  (sylan2br_1 : ⊦ wb ch ph)
  (sylan2br_2 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ps ph) th :=
@sylan2 ph ps ch th
  (@biimpri ch ph
    sylan2br_1)
  sylan2br_2


/-- A double syllogism inference. For an implication-only version, see ~ syl2im . (Contributed by
NM, 31-Jan-1997.) -/
theorem syl2an {ph ps ch th ta : wff}
  (syl2an_1 : ⊦ wi ph ps)
  (syl2an_2 : ⊦ wi ta ch)
  (syl2an_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ph ta) th :=
@sylan2 ta ph ch th
  syl2an_2
  (@sylan ph ps ch th
    syl2an_1
    syl2an_3)


/-- A double syllogism inference. For an implication-only version, see ~ syl2imc . (Contributed by
NM, 17-Sep-2013.) -/
theorem syl2anr {ph ps ch th ta : wff}
  (syl2an_1 : ⊦ wi ph ps)
  (syl2an_2 : ⊦ wi ta ch)
  (syl2an_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ta ph) th :=
@ancoms ph ta th
  (@syl2an ph ps ch th ta
    syl2an_1
    syl2an_2
    syl2an_3)


/-- A double syllogism inference. (Contributed by NM, 29-Jul-1999.) -/
theorem syl2anb {ph ps ch th ta : wff}
  (syl2anb_1 : ⊦ wb ph ps)
  (syl2anb_2 : ⊦ wb ta ch)
  (syl2anb_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ph ta) th :=
@sylan2b ta ph ch th
  syl2anb_2
  (@sylanb ph ps ch th
    syl2anb_1
    syl2anb_3)


/-- A double syllogism inference. (Contributed by NM, 29-Jul-1999.) -/
theorem syl2anbr {ph ps ch th ta : wff}
  (syl2anbr_1 : ⊦ wb ps ph)
  (syl2anbr_2 : ⊦ wb ch ta)
  (syl2anbr_3 : ⊦ wi (wa ps ch) th) :
  ⊦ wi (wa ph ta) th :=
@sylan2br ta ph ch th
  syl2anbr_2
  (@sylanbr ph ps ch th
    syl2anbr_1
    syl2anbr_3)


/-- A syllogism deduction with conjoined antecedents. (Contributed by Jeff Madsen, 20-Jun-2011.) -/
theorem syldanl {ph ps ch th ta : wff}
  (syldanl_1 : ⊦ wi (wa ph ps) ch)
  (syldanl_2 : ⊦ wi (wa (wa ph ch) th) ta) :
  ⊦ wi (wa (wa ph ps) th) ta :=
@sylan (wa ph ps) (wa ph ch) th ta
  (@imdistani ph ps ch
    (@ex ph ps ch
      syldanl_1))
  syldanl_2


/-- A syllogism deduction. (Contributed by NM, 15-Dec-2004.) -/
theorem syland {ph ps ch th ta : wff}
  (syland_1 : ⊦ wi ph (wi ps ch))
  (syland_2 : ⊦ wi ph (wi (wa ch th) ta)) :
  ⊦ wi ph (wi (wa ps th) ta) :=
@impd ph ps th ta
  (@syld ph ps ch (wi th ta)
    syland_1
    (@expd ph ch th ta
      syland_2))


/-- A syllogism inference. (Contributed by NM, 2-May-1996.) -/
theorem sylani {ph ps ch th ta : wff}
  (sylani_1 : ⊦ wi ph ch)
  (sylani_2 : ⊦ wi ps (wi (wa ch th) ta)) :
  ⊦ wi ps (wi (wa ph th) ta) :=
@syland ps ph ch th ta
  (@a1i (wi ph ch) ps
    sylani_1)
  sylani_2


/-- A syllogism deduction. (Contributed by NM, 15-Dec-2004.) -/
theorem sylan2d {ph ps ch th ta : wff}
  (sylan2d_1 : ⊦ wi ph (wi ps ch))
  (sylan2d_2 : ⊦ wi ph (wi (wa th ch) ta)) :
  ⊦ wi ph (wi (wa th ps) ta) :=
@ancomsd ph ps th ta
  (@syland ph ps ch th ta
    sylan2d_1
    (@ancomsd ph th ch ta
      sylan2d_2))


/-- A syllogism inference. (Contributed by NM, 1-Aug-1994.) -/
theorem sylan2i {ph ps ch th ta : wff}
  (sylan2i_1 : ⊦ wi ph th)
  (sylan2i_2 : ⊦ wi ps (wi (wa ch th) ta)) :
  ⊦ wi ps (wi (wa ch ph) ta) :=
@sylan2d ps ph th ch ta
  (@a1i (wi ph th) ps
    sylan2i_1)
  sylan2i_2


/-- A syllogism inference. (Contributed by NM, 3-Aug-1999.) -/
theorem syl2ani {ph ps ch th ta et : wff}
  (syl2ani_1 : ⊦ wi ph ch)
  (syl2ani_2 : ⊦ wi et th)
  (syl2ani_3 : ⊦ wi ps (wi (wa ch th) ta)) :
  ⊦ wi ps (wi (wa ph et) ta) :=
@sylani ph ps ch et ta
  syl2ani_1
  (@sylan2i et ps ch th ta
    syl2ani_2
    syl2ani_3)


/-- A syllogism deduction. (Contributed by NM, 15-Dec-2004.) -/
theorem syl2and {ph ps ch th ta et : wff}
  (syl2and_1 : ⊦ wi ph (wi ps ch))
  (syl2and_2 : ⊦ wi ph (wi th ta))
  (syl2and_3 : ⊦ wi ph (wi (wa ch ta) et)) :
  ⊦ wi ph (wi (wa ps th) et) :=
@syland ph ps ch th et
  syl2and_1
  (@sylan2d ph th ta ch et
    syl2and_2
    syl2and_3)


/-- Conjoin antecedents and consequents in a deduction. (Contributed by NM, 3-Apr-1994.) (Proof
shortened by Wolf Lammen, 18-Dec-2013.) -/
theorem anim12d {ph ps ch th ta : wff}
  (anim12d_1 : ⊦ wi ph (wi ps ch))
  (anim12d_2 : ⊦ wi ph (wi th ta)) :
  ⊦ wi ph (wi (wa ps th) (wa ch ta)) :=
@syl2and ph ps ch th ta (wa ch ta)
  anim12d_1
  anim12d_2
  (@idd ph (wa ch ta))


/-- Variant of ~ anim12d where the second implication does not depend on the antecedent.
(Contributed by Rodolfo Medina, 12-Oct-2010.) -/
theorem anim12d1 {ph ps ch th ta : wff}
  (anim12d1_1 : ⊦ wi ph (wi ps ch))
  (anim12d1_2 : ⊦ wi th ta) :
  ⊦ wi ph (wi (wa ps th) (wa ch ta)) :=
@anim12d ph ps ch th ta
  anim12d1_1
  (@a1i (wi th ta) ph
    anim12d1_2)


/-- Add a conjunct to right of antecedent and consequent in a deduction. (Contributed by NM,
3-Apr-1994.) -/
theorem anim1d {ph ps ch th : wff}
  (anim1d_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wa ps th) (wa ch th)) :=
@anim12d ph ps ch th th
  anim1d_1
  (@idd ph th)


/-- Add a conjunct to left of antecedent and consequent in a deduction. (Contributed by NM,
14-May-1993.) -/
theorem anim2d {ph ps ch th : wff}
  (anim1d_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wa th ps) (wa th ch)) :=
@anim12d ph th th ps ch
  (@idd ph th)
  anim1d_1


/-- Conjoin antecedents and consequents of two premises. (Contributed by NM, 3-Jan-1993.) (Proof
shortened by Wolf Lammen, 14-Dec-2013.) -/
theorem anim12i {ph ps ch th : wff}
  (anim12i_1 : ⊦ wi ph ps)
  (anim12i_2 : ⊦ wi ch th) :
  ⊦ wi (wa ph ch) (wa ps th) :=
@syl2an ph ps th (wa ps th) ch
  anim12i_1
  anim12i_2
  (@id (wa ps th))


/-- Variant of ~ anim12i with commutation. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem anim12ci {ph ps ch th : wff}
  (anim12i_1 : ⊦ wi ph ps)
  (anim12i_2 : ⊦ wi ch th) :
  ⊦ wi (wa ph ch) (wa th ps) :=
@ancoms ch ph (wa th ps)
  (@anim12i ch th ph ps
    anim12i_2
    anim12i_1)


/-- Introduce conjunct to both sides of an implication. (Contributed by NM, 5-Aug-1993.) -/
theorem anim1i {ph ps ch : wff}
  (anim1i_1 : ⊦ wi ph ps) :
  ⊦ wi (wa ph ch) (wa ps ch) :=
@anim12i ph ps ch ch
  anim1i_1
  (@id ch)


/-- Introduce conjunct to both sides of an implication. (Contributed by Peter Mazsa, 24-Sep-2022.)
-/
theorem anim1ci {ph ps ch : wff}
  (anim1i_1 : ⊦ wi ph ps) :
  ⊦ wi (wa ph ch) (wa ch ps) :=
@anim12ci ph ps ch ch
  anim1i_1
  (@id ch)


/-- Introduce conjunct to both sides of an implication. (Contributed by NM, 3-Jan-1993.) -/
theorem anim2i {ph ps ch : wff}
  (anim1i_1 : ⊦ wi ph ps) :
  ⊦ wi (wa ch ph) (wa ch ps) :=
@anim12i ch ch ph ps
  (@id ch)
  anim1i_1


/-- Conjoin antecedents and consequents in a deduction. (Contributed by NM, 11-Nov-2007.) (Proof
shortened by Wolf Lammen, 19-Jul-2013.) -/
theorem anim12ii {ph ps ch th ta : wff}
  (anim12ii_1 : ⊦ wi ph (wi ps ch))
  (anim12ii_2 : ⊦ wi th (wi ps ta)) :
  ⊦ wi (wa ph th) (wi ps (wa ch ta)) :=
@syl2an ph (wi ps ch) (wi ps ta) (wi ps (wa ch ta)) th
  anim12ii_1
  anim12ii_2
  (@pm3_43 ps ch ta)


/-- Conjoin antecedents and consequents in a deduction. (Contributed by Jeff Madsen, 16-Jun-2011.)
-/
theorem anim12dan {ph ps ch th ta : wff}
  (anim12dan_1 : ⊦ wi (wa ph ps) ch)
  (anim12dan_2 : ⊦ wi (wa ph th) ta) :
  ⊦ wi (wa ph (wa ps th)) (wa ch ta) :=
@imp ph (wa ps th) (wa ch ta)
  (@anim12d ph ps ch th ta
    (@ex ph ps ch
      anim12dan_1)
    (@ex ph th ta
      anim12dan_2))


/-- Deduction joining nested implications to form implication of conjunctions. (Contributed by NM,
29-Feb-1996.) -/
theorem im2anan9 {ph ps ch th ta et : wff}
  (im2an9_1 : ⊦ wi ph (wi ps ch))
  (im2an9_2 : ⊦ wi th (wi ta et)) :
  ⊦ wi (wa ph th) (wi (wa ps ta) (wa ch et)) :=
@anim12ii ph (wa ps ta) ch th et
  (@adantrd ph ps ch ta
    im2an9_1)
  (@adantld th ta et ps
    im2an9_2)


/-- Deduction joining nested implications to form implication of conjunctions. (Contributed by NM,
29-Feb-1996.) -/
theorem im2anan9r {ph ps ch th ta et : wff}
  (im2an9_1 : ⊦ wi ph (wi ps ch))
  (im2an9_2 : ⊦ wi th (wi ta et)) :
  ⊦ wi (wa th ph) (wi (wa ps ta) (wa ch et)) :=
@ancoms ph th (wi (wa ps ta) (wa ch et))
  (@im2anan9 ph ps ch th ta et
    im2an9_1
    im2an9_2)


/-- Theorem *3.45 (Fact) of [WhiteheadRussell] p. 113. (Contributed by NM, 3-Jan-2005.) -/
theorem pm3_45 {ph ps ch : wff} :
  ⊦ wi (wi ph ps) (wi (wa ph ch) (wa ps ch)) :=
@anim1d (wi ph ps) ph ps ch
  (@id (wi ph ps))


/-- Introduce a left conjunct to both sides of a logical equivalence. (Contributed by NM,
3-Jan-1993.) (Proof shortened by Wolf Lammen, 16-Nov-2013.) -/
theorem anbi2i {ph ps ch : wff}
  (anbi_1 : ⊦ wb ph ps) :
  ⊦ wb (wa ch ph) (wa ch ps) :=
@pm5_32i ch ph ps
  (@a1i (wb ph ps) ch
    anbi_1)


/-- Introduce a right conjunct to both sides of a logical equivalence. (Contributed by NM,
12-Mar-1993.) (Proof shortened by Wolf Lammen, 16-Nov-2013.) -/
theorem anbi1i {ph ps ch : wff}
  (anbi_1 : ⊦ wb ph ps) :
  ⊦ wb (wa ph ch) (wa ps ch) :=
@pm5_32ri ch ph ps
  (@a1i (wb ph ps) ch
    anbi_1)


/-- Variant of ~ anbi2i with commutation. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) (Proof
shortened by Andrew Salmon, 14-Jun-2011.) -/
theorem anbi2ci {ph ps ch : wff}
  (anbi_1 : ⊦ wb ph ps) :
  ⊦ wb (wa ph ch) (wa ch ps) :=
@biancomi (wa ph ch) ch ps
  (@anbi1i ph ps ch
    anbi_1)


/-- Variant of ~ anbi1i with commutation. (Contributed by Peter Mazsa, 7-Mar-2020.) -/
theorem anbi1ci {ph ps ch : wff}
  (anbi_1 : ⊦ wb ph ps) :
  ⊦ wb (wa ch ph) (wa ps ch) :=
@biancomi (wa ch ph) ps ch
  (@anbi2i ph ps ch
    anbi_1)


/-- Conjoin both sides of two equivalences. (Contributed by NM, 12-Mar-1993.) -/
theorem anbi12i {ph ps ch th : wff}
  (anbi12_1 : ⊦ wb ph ps)
  (anbi12_2 : ⊦ wb ch th) :
  ⊦ wb (wa ph ch) (wa ps th) :=
@bitri (wa ph ch) (wa ps ch) (wa ps th)
  (@anbi1i ph ps ch
    anbi12_1)
  (@anbi2i ch th ps
    anbi12_2)


/-- Variant of ~ anbi12i with commutation. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem anbi12ci {ph ps ch th : wff}
  (anbi12_1 : ⊦ wb ph ps)
  (anbi12_2 : ⊦ wb ch th) :
  ⊦ wb (wa ph ch) (wa th ps) :=
@biancomi (wa ph ch) th ps
  (@anbi12i ph ps ch th
    anbi12_1
    anbi12_2)


/-- Deduction adding a left conjunct to both sides of a logical equivalence. (Contributed by NM,
11-May-1993.) (Proof shortened by Wolf Lammen, 16-Nov-2013.) -/
theorem anbi2d {ph ps ch th : wff}
  (anbid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wa th ps) (wa th ch)) :=
@pm5_32d ph th ps ch
  (@a1d ph (wb ps ch) th
    anbid_1)


/-- Deduction adding a right conjunct to both sides of a logical equivalence. (Contributed by NM,
11-May-1993.) (Proof shortened by Wolf Lammen, 16-Nov-2013.) -/
theorem anbi1d {ph ps ch th : wff}
  (anbid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wa ps th) (wa ch th)) :=
@pm5_32rd ph th ps ch
  (@a1d ph (wb ps ch) th
    anbid_1)


/-- Deduction joining two equivalences to form equivalence of conjunctions. (Contributed by NM,
26-May-1993.) -/
theorem anbi12d {ph ps ch th ta : wff}
  (anbi12d_1 : ⊦ wi ph (wb ps ch))
  (anbi12d_2 : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb (wa ps th) (wa ch ta)) :=
@bitrd ph (wa ps th) (wa ch th) (wa ch ta)
  (@anbi1d ph ps ch th
    anbi12d_1)
  (@anbi2d ph th ta ch
    anbi12d_2)


/-- Introduce a left conjunct to both sides of a logical equivalence. (Contributed by NM,
16-Nov-2013.) -/
theorem anbi2 {ph ps ch : wff} :
  ⊦ wi (wb ph ps) (wb (wa ch ph) (wa ch ps)) :=
@anbi2d (wb ph ps) ph ps ch
  (@id (wb ph ps))


/-- Introduce a proposition as left conjunct on the left-hand side and right conjunct on the
right-hand side of an equivalence. Deduction form. (Contributed by Peter Mazsa, 22-May-2021.) -/
theorem anbi1cd {ph ps ch th : wff}
  (anbi1cd_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wa th ps) (wa ch th)) :=
@biancomd ph (wa th ps) ch th
  (@anbi2d ph ps ch th
    anbi1cd_1)


/-- Theorem *4.38 of [WhiteheadRussell] p. 118. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_38 {ph ps ch th : wff} :
  ⊦ wi (wa (wb ph ch) (wb ps th)) (wb (wa ph ps) (wa ch th)) :=
@anbi12d (wa (wb ph ch) (wb ps th)) ph ch ps th
  (@simpl (wb ph ch) (wb ps th))
  (@simpr (wb ph ch) (wb ps th))


/-- Deduction joining two equivalences to form equivalence of conjunctions. (Contributed by NM,
31-Jul-1995.) -/
theorem bi2anan9 {ph ps ch th ta et : wff}
  (bi2an9_1 : ⊦ wi ph (wb ps ch))
  (bi2an9_2 : ⊦ wi th (wb ta et)) :
  ⊦ wi (wa ph th) (wb (wa ps ta) (wa ch et)) :=
@syl2an ph (wb ps ch) (wb ta et) (wb (wa ps ta) (wa ch et)) th
  bi2an9_1
  bi2an9_2
  (@pm4_38 ps ta ch et)


/-- Deduction joining two equivalences to form equivalence of conjunctions. (Contributed by NM,
19-Feb-1996.) -/
theorem bi2anan9r {ph ps ch th ta et : wff}
  (bi2an9_1 : ⊦ wi ph (wb ps ch))
  (bi2an9_2 : ⊦ wi th (wb ta et)) :
  ⊦ wi (wa th ph) (wb (wa ps ta) (wa ch et)) :=
@ancoms ph th (wb (wa ps ta) (wa ch et))
  (@bi2anan9 ph ps ch th ta et
    bi2an9_1
    bi2an9_2)


/-- An inference to merge two lists of conjuncts. (Contributed by Giovanni Mascellani, 23-May-2019.)
-/
theorem bianass {ph ps ch et : wff}
  (bianass_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wb (wa et ph) (wa (wa et ps) ch) :=
@bitr4i (wa et ph) (wa et (wa ps ch)) (wa (wa et ps) ch)
  (@anbi2i ph (wa ps ch) et
    bianass_1)
  (@anass et ps ch)


/-- An inference to merge two lists of conjuncts. (Contributed by Peter Mazsa, 24-Sep-2022.) -/
theorem bianassc {ph ps ch et : wff}
  (bianass_1 : ⊦ wb ph (wa ps ch)) :
  ⊦ wb (wa et ph) (wa (wa ps et) ch) :=
@bitri (wa et ph) (wa (wa et ps) ch) (wa (wa ps et) ch)
  (@bianass ph ps ch et
    bianass_1)
  (@anbi1i (wa et ps) (wa ps et) ch
    (@ancom et ps))


/-- Swap two conjuncts. (Contributed by Peter Mazsa, 18-Sep-2022.) -/
theorem an21 {ph ps ch : wff} :
  ⊦ wb (wa (wa ph ps) ch) (wa ps (wa ph ch)) :=
@bicomi (wa ps (wa ph ch)) (wa (wa ph ps) ch)
  (@bianassc (wa ph ch) ph ch ps
    (@biid (wa ph ch)))


/-- Swap two conjuncts. Note that the first digit (1) in the label refers to the outer conjunct
position, and the next digit (2) to the inner conjunct position. (Contributed by NM, 12-Mar-1995.)
(Proof shortened by Peter Mazsa, 18-Sep-2022.) -/
theorem an12 {ph ps ch : wff} :
  ⊦ wb (wa ph (wa ps ch)) (wa ps (wa ph ch)) :=
@biancomi (wa ph (wa ps ch)) ps (wa ph ch)
  (@bianass (wa ps ch) ch ps ph
    (@ancom ps ch))


/-- A rearrangement of conjuncts. (Contributed by NM, 12-Mar-1995.) (Proof shortened by Wolf Lammen,
25-Dec-2012.) -/
theorem an32 {ph ps ch : wff} :
  ⊦ wb (wa (wa ph ps) ch) (wa (wa ph ch) ps) :=
@biancomi (wa (wa ph ps) ch) (wa ph ch) ps
  (@an21 ph ps ch)


/-- A rearrangement of conjuncts. (Contributed by NM, 24-Jun-2012.) (Proof shortened by Wolf Lammen,
31-Dec-2012.) -/
theorem an13 {ph ps ch : wff} :
  ⊦ wb (wa ph (wa ps ch)) (wa ch (wa ps ph)) :=
@bitr3i (wa ph (wa ps ch)) (wa (wa ps ph) ch) (wa ch (wa ps ph))
  (@an21 ps ph ch)
  (@ancom (wa ps ph) ch)


/-- A rearrangement of conjuncts. (Contributed by NM, 24-Jun-2012.) (Proof shortened by Wolf Lammen,
31-Dec-2012.) -/
theorem an31 {ph ps ch : wff} :
  ⊦ wb (wa (wa ph ps) ch) (wa (wa ch ps) ph) :=
@«3bitr4i» (wa ph (wa ps ch)) (wa ch (wa ps ph)) (wa (wa ph ps) ch) (wa (wa ch ps) ph)
  (@an13 ph ps ch)
  (@anass ph ps ch)
  (@anass ch ps ph)


/-- Swap two conjuncts in antecedent. The label suffix "s" means that ~ an12 is combined with ~ syl
(or a variant). (Contributed by NM, 13-Mar-1996.) -/
theorem an12s {ph ps ch th : wff}
  (an12s_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ps (wa ph ch)) th :=
@sylbi (wa ps (wa ph ch)) (wa ph (wa ps ch)) th
  (@an12 ps ph ch)
  an12s_1


/-- Inference commuting a nested conjunction in antecedent. (Contributed by NM, 24-May-2006.) (Proof
shortened by Wolf Lammen, 24-Nov-2012.) -/
theorem ancom2s {ph ps ch th : wff}
  (an12s_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (wa ch ps)) th :=
@sylan2 (wa ch ps) ph (wa ps ch) th
  (@pm3_22 ch ps)
  an12s_1


/-- Swap two conjuncts in antecedent. (Contributed by NM, 13-Mar-1996.) -/
theorem an32s {ph ps ch th : wff}
  (an32s_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (wa ph ch) ps) th :=
@sylbi (wa (wa ph ch) ps) (wa (wa ph ps) ch) th
  (@an32 ph ch ps)
  an32s_1


/-- Inference commuting a nested conjunction in antecedent. (Contributed by NM, 24-May-2006.) (Proof
shortened by Wolf Lammen, 24-Nov-2012.) -/
theorem ancom1s {ph ps ch th : wff}
  (an32s_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (wa ps ph) ch) th :=
@sylan (wa ps ph) (wa ph ps) ch th
  (@pm3_22 ps ph)
  an32s_1


/-- Commutative-associative law for conjunction in an antecedent. (Contributed by Jeff Madsen,
19-Jun-2011.) -/
theorem anass1rs {ph ps ch th : wff}
  (anass1rs_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa (wa ph ch) ps) th :=
@an32s ph ps ch th
  (@anassrs ph ps ch th
    anass1rs_1)


/-- Rearrangement of 4 conjuncts. (Contributed by NM, 10-Jul-1994.) -/
theorem an4 {ph ps ch th : wff} :
  ⊦ wb (wa (wa ph ps) (wa ch th)) (wa (wa ph ch) (wa ps th)) :=
@bitri (wa (wa ph ps) (wa ch th)) (wa ph (wa ps (wa ch th))) (wa (wa ph ch) (wa ps th))
  (@anass ph ps (wa ch th))
  (@bianass (wa ps (wa ch th)) ch (wa ps th) ph
    (@an12 ps ch th))


/-- Rearrangement of 4 conjuncts. (Contributed by NM, 7-Feb-1996.) -/
theorem an42 {ph ps ch th : wff} :
  ⊦ wb (wa (wa ph ps) (wa ch th)) (wa (wa ph ch) (wa th ps)) :=
@bitri (wa (wa ph ps) (wa ch th)) (wa (wa ph ch) (wa ps th)) (wa (wa ph ch) (wa th ps))
  (@an4 ph ps ch th)
  (@anbi2i (wa ps th) (wa th ps) (wa ph ch)
    (@ancom ps th))


/-- Rearrangement of 4 conjuncts. (Contributed by Rodolfo Medina, 24-Sep-2010.) (Proof shortened by
Andrew Salmon, 29-Jun-2011.) -/
theorem an43 {ph ps ch th : wff} :
  ⊦ wb (wa (wa ph ps) (wa ch th)) (wa (wa ph th) (wa ps ch)) :=
@bicomi (wa (wa ph th) (wa ps ch)) (wa (wa ph ps) (wa ch th))
  (@an42 ph th ps ch)


/-- Inference rearranging 4 conjuncts in antecedent. (Contributed by NM, 10-Aug-1995.) -/
theorem an4s {ph ps ch th ta : wff}
  (an4s_1 : ⊦ wi (wa (wa ph ps) (wa ch th)) ta) :
  ⊦ wi (wa (wa ph ch) (wa ps th)) ta :=
@sylbi (wa (wa ph ch) (wa ps th)) (wa (wa ph ps) (wa ch th)) ta
  (@an4 ph ch ps th)
  an4s_1


/-- Inference rearranging 4 conjuncts in antecedent. (Contributed by NM, 10-Aug-1995.) -/
theorem an42s {ph ps ch th ta : wff}
  (an41r3s_1 : ⊦ wi (wa (wa ph ps) (wa ch th)) ta) :
  ⊦ wi (wa (wa ph ch) (wa th ps)) ta :=
@ancom2s (wa ph ch) ps th ta
  (@an4s ph ps ch th ta
    an41r3s_1)


/-- Absorption into embedded conjunct. (Contributed by NM, 4-Sep-1995.) (Proof shortened by Wolf
Lammen, 16-Nov-2013.) -/
theorem anabs1 {ph ps : wff} :
  ⊦ wb (wa (wa ph ps) ph) (wa ph ps) :=
@bicomi (wa ph ps) (wa (wa ph ps) ph)
  (@pm4_71i (wa ph ps) ph
    (@simpl ph ps))


/-- Absorption of antecedent with conjunction. (Contributed by NM, 24-Mar-1996.) -/
theorem anabsan {ph ps ch : wff}
  (anabsan_1 : ⊦ wi (wa (wa ph ph) ps) ch) :
  ⊦ wi (wa ph ps) ch :=
@sylanb ph (wa ph ph) ps ch
  (@pm4_24 ph)
  anabsan_1


/-- Absorption of antecedent into conjunction. (Contributed by NM, 20-Jul-1996.) (Proof shortened by
Wolf Lammen, 31-Dec-2012.) -/
theorem anabss1 {ph ps ch : wff}
  (anabss1_1 : ⊦ wi (wa (wa ph ps) ph) ch) :
  ⊦ wi (wa ph ps) ch :=
@anabsan ph ps ch
  (@an32s ph ps ph ch
    anabss1_1)


/-- Absorption of antecedent into conjunction. (Contributed by NM, 20-Jul-1996.) -/
theorem anabss4 {ph ps ch : wff}
  (anabss4_1 : ⊦ wi (wa (wa ps ph) ps) ch) :
  ⊦ wi (wa ph ps) ch :=
@ancoms ps ph ch
  (@anabss1 ps ph ch
    anabss4_1)


/-- Absorption of antecedent into conjunction. (Contributed by NM, 10-May-1994.) (Proof shortened by
Wolf Lammen, 1-Jan-2013.) -/
theorem anabss5 {ph ps ch : wff}
  (anabss5_1 : ⊦ wi (wa ph (wa ph ps)) ch) :
  ⊦ wi (wa ph ps) ch :=
@anabsan ph ps ch
  (@anassrs ph ph ps ch
    anabss5_1)


/-- Absorption of antecedent into conjunction. (Contributed by NM, 11-Jun-1995.) (Proof shortened by
Wolf Lammen, 18-Nov-2013.) -/
theorem anabsi5 {ph ps ch : wff}
  (anabsi5_1 : ⊦ wi ph (wi (wa ph ps) ch)) :
  ⊦ wi (wa ph ps) ch :=
@mpcom ph (wa ph ps) ch
  (@simpl ph ps)
  anabsi5_1


/-- Absorption of antecedent into conjunction. (Contributed by NM, 14-Aug-2000.) -/
theorem anabsi6 {ph ps ch : wff}
  (anabsi6_1 : ⊦ wi ph (wi (wa ps ph) ch)) :
  ⊦ wi (wa ph ps) ch :=
@anabsi5 ph ps ch
  (@ancomsd ph ps ph ch
    anabsi6_1)


/-- Absorption of antecedent into conjunction. (Contributed by NM, 20-Jul-1996.) (Proof shortened by
Wolf Lammen, 18-Nov-2013.) -/
theorem anabsi7 {ph ps ch : wff}
  (anabsi7_1 : ⊦ wi ps (wi (wa ph ps) ch)) :
  ⊦ wi (wa ph ps) ch :=
@ancoms ps ph ch
  (@anabsi6 ps ph ch
    anabsi7_1)


/-- Absorption of antecedent into conjunction. (Contributed by NM, 20-Jul-1996.) (Proof shortened by
Wolf Lammen, 19-Nov-2013.) -/
theorem anabss7 {ph ps ch : wff}
  (anabss7_1 : ⊦ wi (wa ps (wa ph ps)) ch) :
  ⊦ wi (wa ph ps) ch :=
@anabss4 ph ps ch
  (@anassrs ps ph ps ch
    anabss7_1)


/-- Absorption of antecedent with conjunction. (Contributed by NM, 10-May-2004.) -/
theorem anabsan2 {ph ps ch : wff}
  (anabsan2_1 : ⊦ wi (wa ph (wa ps ps)) ch) :
  ⊦ wi (wa ph ps) ch :=
@anabss7 ph ps ch
  (@an12s ph ps ps ch
    anabsan2_1)


/-- Absorption of antecedent into conjunction. (Contributed by NM, 20-Jul-1996.) (Proof shortened by
Wolf Lammen, 1-Jan-2013.) -/
theorem anabss3 {ph ps ch : wff}
  (anabss3_1 : ⊦ wi (wa (wa ph ps) ps) ch) :
  ⊦ wi (wa ph ps) ch :=
@anabsan2 ph ps ch
  (@anasss ph ps ps ch
    anabss3_1)


/-- Distribution of conjunction over conjunction. (Contributed by NM, 14-Aug-1995.) -/
theorem anandi {ph ps ch : wff} :
  ⊦ wb (wa ph (wa ps ch)) (wa (wa ph ps) (wa ph ch)) :=
@bitr3i (wa ph (wa ps ch)) (wa (wa ph ph) (wa ps ch)) (wa (wa ph ps) (wa ph ch))
  (@anbi1i (wa ph ph) ph (wa ps ch)
    (@anidm ph))
  (@an4 ph ph ps ch)


/-- Distribution of conjunction over conjunction. (Contributed by NM, 24-Aug-1995.) -/
theorem anandir {ph ps ch : wff} :
  ⊦ wb (wa (wa ph ps) ch) (wa (wa ph ch) (wa ps ch)) :=
@bitr3i (wa (wa ph ps) ch) (wa (wa ph ps) (wa ch ch)) (wa (wa ph ch) (wa ps ch))
  (@anbi2i (wa ch ch) ch (wa ph ps)
    (@anidm ch))
  (@an4 ph ps ch ch)


/-- Inference that undistributes conjunction in the antecedent. (Contributed by NM, 7-Jun-2004.) -/
theorem anandis {ph ps ch ta : wff}
  (anandis_1 : ⊦ wi (wa (wa ph ps) (wa ph ch)) ta) :
  ⊦ wi (wa ph (wa ps ch)) ta :=
@anabsan ph (wa ps ch) ta
  (@an4s ph ps ph ch ta
    anandis_1)


/-- Inference that undistributes conjunction in the antecedent. (Contributed by NM, 7-Jun-2004.) -/
theorem anandirs {ph ps ch ta : wff}
  (anandirs_1 : ⊦ wi (wa (wa ph ch) (wa ps ch)) ta) :
  ⊦ wi (wa (wa ph ps) ch) ta :=
@anabsan2 (wa ph ps) ch ta
  (@an4s ph ch ps ch ta
    anandirs_1)


/-- A syllogism inference. (Contributed by NM, 10-Mar-2005.) -/
theorem sylanl1 {ph ps ch th ta : wff}
  (sylanl1_1 : ⊦ wi ph ps)
  (sylanl1_2 : ⊦ wi (wa (wa ps ch) th) ta) :
  ⊦ wi (wa (wa ph ch) th) ta :=
@sylan (wa ph ch) (wa ps ch) th ta
  (@anim1i ph ps ch
    sylanl1_1)
  sylanl1_2


/-- A syllogism inference. (Contributed by NM, 1-Jan-2005.) -/
theorem sylanl2 {ph ps ch th ta : wff}
  (sylanl2_1 : ⊦ wi ph ch)
  (sylanl2_2 : ⊦ wi (wa (wa ps ch) th) ta) :
  ⊦ wi (wa (wa ps ph) th) ta :=
@syldanl ps ph ch th ta
  (@adantl ph ch ps
    sylanl2_1)
  sylanl2_2


/-- A syllogism inference. (Contributed by NM, 9-Apr-2005.) -/
theorem sylanr1 {ph ps ch th ta : wff}
  (sylanr1_1 : ⊦ wi ph ch)
  (sylanr1_2 : ⊦ wi (wa ps (wa ch th)) ta) :
  ⊦ wi (wa ps (wa ph th)) ta :=
@sylan2 (wa ph th) ps (wa ch th) ta
  (@anim1i ph ch th
    sylanr1_1)
  sylanr1_2


/-- A syllogism inference. (Contributed by NM, 9-Apr-2005.) -/
theorem sylanr2 {ph ps ch th ta : wff}
  (sylanr2_1 : ⊦ wi ph th)
  (sylanr2_2 : ⊦ wi (wa ps (wa ch th)) ta) :
  ⊦ wi (wa ps (wa ch ph)) ta :=
@sylan2 (wa ch ph) ps (wa ch th) ta
  (@anim2i ph th ch
    sylanr2_1)
  sylanr2_2


/-- A syllogism deduction combined with conjoining antecedents. (Contributed by Alan Sare,
28-Oct-2011.) -/
theorem syl6an {ph ps ch th ta : wff}
  (syl6an_1 : ⊦ wi ph ps)
  (syl6an_2 : ⊦ wi ph (wi ch th))
  (syl6an_3 : ⊦ wi (wa ps th) ta) :
  ⊦ wi ph (wi ch ta) :=
@sylsyld ph ps ch th ta
  syl6an_1
  syl6an_2
  (@ex ps th ta
    syl6an_3)


/-- ~ syl2anr with antecedents in standard conjunction form. (Contributed by Alan Sare,
27-Aug-2016.) (Proof shortened by Wolf Lammen, 28-Mar-2022.) -/
theorem syl2an2r {ph ps ch th ta : wff}
  (syl2an2r_1 : ⊦ wi ph ps)
  (syl2an2r_2 : ⊦ wi (wa ph ch) th)
  (syl2an2r_3 : ⊦ wi (wa ps th) ta) :
  ⊦ wi (wa ph ch) ta :=
@syldan ph ch th ta
  syl2an2r_2
  (@sylan ph ps th ta
    syl2an2r_1
    syl2an2r_3)


/-- ~ syl2an with antecedents in standard conjunction form. (Contributed by Alan Sare, 27-Aug-2016.)
-/
theorem syl2an2 {ph ps ch th ta : wff}
  (syl2an2_1 : ⊦ wi ph ps)
  (syl2an2_2 : ⊦ wi (wa ch ph) th)
  (syl2an2_3 : ⊦ wi (wa ps th) ta) :
  ⊦ wi (wa ch ph) ta :=
@syl2anc (wa ch ph) ps th ta
  (@adantl ph ps ch
    syl2an2_1)
  syl2an2_2
  syl2an2_3


/-- An inference based on modus ponens. (Contributed by NM, 23-May-1999.) (Proof shortened by Wolf
Lammen, 22-Nov-2012.) -/
theorem mpdan {ph ps ch : wff}
  (mpdan_1 : ⊦ wi ph ps)
  (mpdan_2 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi ph ch :=
@syl2anc ph ph ps ch
  (@id ph)
  mpdan_1
  mpdan_2


/-- An inference based on modus ponens with commutation of antecedents. (Contributed by NM,
28-Oct-2003.) (Proof shortened by Wolf Lammen, 7-Apr-2013.) -/
theorem mpancom {ph ps ch : wff}
  (mpancom_1 : ⊦ wi ps ph)
  (mpancom_2 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi ps ch :=
@syl2anc ps ph ps ch
  mpancom_1
  (@id ps)
  mpancom_2


/-- A deduction which "stacks" a hypothesis. (Contributed by Stanislas Polu, 9-Mar-2020.) (Proof
shortened by Wolf Lammen, 28-Mar-2021.) -/
theorem mpidan {ph ps ch th : wff}
  (mpidan_1 : ⊦ wi ph ch)
  (mpidan_2 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa ph ps) th :=
@mpdan (wa ph ps) ch th
  (@adantr ph ch ps
    mpidan_1)
  mpidan_2


/-- An inference based on modus ponens. (Contributed by NM, 30-Aug-1993.) (Proof shortened by Wolf
Lammen, 7-Apr-2013.) -/
theorem mpan {ph ps ch : wff}
  (mpan_1 : ⊦ ph)
  (mpan_2 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi ps ch :=
@mpancom ph ps ch
  (@a1i ph ps
    mpan_1)
  mpan_2


/-- An inference based on modus ponens. (Contributed by NM, 16-Sep-1993.) (Proof shortened by Wolf
Lammen, 19-Nov-2012.) -/
theorem mpan2 {ph ps ch : wff}
  (mpan2_1 : ⊦ ps)
  (mpan2_2 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi ph ch :=
@mpdan ph ps ch
  (@a1i ps ph
    mpan2_1)
  mpan2_2


/-- An inference based on modus ponens. (Contributed by NM, 13-Apr-1995.) -/
theorem mp2an {ph ps ch : wff}
  (mp2an_1 : ⊦ ph)
  (mp2an_2 : ⊦ ps)
  (mp2an_3 : ⊦ wi (wa ph ps) ch) :
  ⊦ ch :=
@ax_mp ps ch
  mp2an_2
  (@mpan ph ps ch
    mp2an_1
    mp2an_3)


/-- An inference based on modus ponens. (Contributed by Jeff Madsen, 15-Jun-2010.) -/
theorem mp4an {ph ps ch th ta : wff}
  (mp4an_1 : ⊦ ph)
  (mp4an_2 : ⊦ ps)
  (mp4an_3 : ⊦ ch)
  (mp4an_4 : ⊦ th)
  (mp4an_5 : ⊦ wi (wa (wa ph ps) (wa ch th)) ta) :
  ⊦ ta :=
@mp2an (wa ph ps) (wa ch th) ta
  (@pm3_2i ph ps
    mp4an_1
    mp4an_2)
  (@pm3_2i ch th
    mp4an_3
    mp4an_4)
  mp4an_5


/-- A deduction based on modus ponens. (Contributed by NM, 12-Dec-2004.) -/
theorem mpan2d {ph ps ch th : wff}
  (mpan2d_1 : ⊦ wi ph ch)
  (mpan2d_2 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph (wi ps th) :=
@mpid ph ps ch th
  mpan2d_1
  (@expd ph ps ch th
    mpan2d_2)


/-- A deduction based on modus ponens. (Contributed by NM, 12-Dec-2004.) (Proof shortened by Wolf
Lammen, 7-Apr-2013.) -/
theorem mpand {ph ps ch th : wff}
  (mpand_1 : ⊦ wi ph ps)
  (mpand_2 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph (wi ch th) :=
@mpan2d ph ch ps th
  mpand_1
  (@ancomsd ph ps ch th
    mpand_2)


/-- An inference based on modus ponens. (Contributed by NM, 10-Apr-1994.) (Proof shortened by Wolf
Lammen, 19-Nov-2012.) -/
theorem mpani {ph ps ch th : wff}
  (mpani_1 : ⊦ ps)
  (mpani_2 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph (wi ch th) :=
@mpand ph ps ch th
  (@a1i ps ph
    mpani_1)
  mpani_2


/-- An inference based on modus ponens. (Contributed by NM, 10-Apr-1994.) (Proof shortened by Wolf
Lammen, 19-Nov-2012.) -/
theorem mpan2i {ph ps ch th : wff}
  (mpan2i_1 : ⊦ ch)
  (mpan2i_2 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph (wi ps th) :=
@mpan2d ph ps ch th
  (@a1i ch ph
    mpan2i_1)
  mpan2i_2


/-- An inference based on modus ponens. (Contributed by NM, 12-Dec-2004.) -/
theorem mp2ani {ph ps ch th : wff}
  (mp2ani_1 : ⊦ ps)
  (mp2ani_2 : ⊦ ch)
  (mp2ani_3 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph th :=
@mpi ph ch th
  mp2ani_2
  (@mpani ph ps ch th
    mp2ani_1
    mp2ani_3)


/-- A deduction based on modus ponens. (Contributed by NM, 12-Dec-2004.) -/
theorem mp2and {ph ps ch th : wff}
  (mp2and_1 : ⊦ wi ph ps)
  (mp2and_2 : ⊦ wi ph ch)
  (mp2and_3 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph th :=
@mpd ph ch th
  mp2and_2
  (@mpand ph ps ch th
    mp2and_1
    mp2and_3)


/-- An inference based on modus ponens. (Contributed by NM, 16-Aug-1994.) (Proof shortened by Wolf
Lammen, 7-Apr-2013.) -/
theorem mpanl1 {ph ps ch th : wff}
  (mpanl1_1 : ⊦ ph)
  (mpanl1_2 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa ps ch) th :=
@sylan ps (wa ph ps) ch th
  (@jctl ps ph
    mpanl1_1)
  mpanl1_2


/-- An inference based on modus ponens. (Contributed by NM, 16-Aug-1994.) (Proof shortened by Andrew
Salmon, 7-May-2011.) -/
theorem mpanl2 {ph ps ch th : wff}
  (mpanl2_1 : ⊦ ps)
  (mpanl2_2 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa ph ch) th :=
@sylan ph (wa ph ps) ch th
  (@jctr ph ps
    mpanl2_1)
  mpanl2_2


/-- An inference based on modus ponens. (Contributed by NM, 13-Jul-2005.) -/
theorem mpanl12 {ph ps ch th : wff}
  (mpanl12_1 : ⊦ ph)
  (mpanl12_2 : ⊦ ps)
  (mpanl12_3 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi ch th :=
@mpan ps ch th
  mpanl12_2
  (@mpanl1 ph ps ch th
    mpanl12_1
    mpanl12_3)


/-- An inference based on modus ponens. (Contributed by NM, 3-May-1994.) (Proof shortened by Andrew
Salmon, 7-May-2011.) -/
theorem mpanr1 {ph ps ch th : wff}
  (mpanr1_1 : ⊦ ps)
  (mpanr1_2 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph ch) th :=
@mpanl2 ph ps ch th
  mpanr1_1
  (@anassrs ph ps ch th
    mpanr1_2)


/-- An inference based on modus ponens. (Contributed by NM, 3-May-1994.) (Proof shortened by Andrew
Salmon, 7-May-2011.) (Proof shortened by Wolf Lammen, 7-Apr-2013.) -/
theorem mpanr2 {ph ps ch th : wff}
  (mpanr2_1 : ⊦ ch)
  (mpanr2_2 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph ps) th :=
@sylan2 ps ph (wa ps ch) th
  (@jctr ps ch
    mpanr2_1)
  mpanr2_2


/-- An inference based on modus ponens. (Contributed by NM, 24-Jul-2009.) -/
theorem mpanr12 {ph ps ch th : wff}
  (mpanr12_1 : ⊦ ps)
  (mpanr12_2 : ⊦ ch)
  (mpanr12_3 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi ph th :=
@mpan2 ph ch th
  mpanr12_2
  (@mpanr1 ph ps ch th
    mpanr12_1
    mpanr12_3)


/-- Detach truth from conjunction in biconditional. (Contributed by Glauco Siliprandi, 3-Mar-2021.)
-/
theorem mpbirand {ph ps ch th : wff}
  (mpbirand_1 : ⊦ wi ph ch)
  (mpbirand_2 : ⊦ wi ph (wb ps (wa ch th))) :
  ⊦ wi ph (wb ps th) :=
@bitr4d ph ps (wa ch th) th
  mpbirand_2
  (@biantrurd ph ch th
    mpbirand_1)


/-- Detach truth from conjunction in biconditional. Deduction form. (Contributed by Peter Mazsa,
24-Sep-2022.) -/
theorem mpbiran2d {ph ps ch th : wff}
  (mpbiran2d_1 : ⊦ wi ph th)
  (mpbiran2d_2 : ⊦ wi ph (wb ps (wa ch th))) :
  ⊦ wi ph (wb ps ch) :=
@mpbirand ph ps th ch
  mpbiran2d_1
  (@biancomd ph ps th ch
    mpbiran2d_2)


/-- Detach truth from conjunction in biconditional. (Contributed by NM, 27-Feb-1996.) -/
theorem mpbiran {ph ps ch : wff}
  (mpbiran_1 : ⊦ ps)
  (mpbiran_2 : ⊦ wb ph (wa ps ch)) :
  ⊦ wb ph ch :=
@bitr4i ph (wa ps ch) ch
  mpbiran_2
  (@biantrur ps ch
    mpbiran_1)


/-- Detach truth from conjunction in biconditional. (Contributed by NM, 22-Feb-1996.) -/
theorem mpbiran2 {ph ps ch : wff}
  (mpbiran2_1 : ⊦ ch)
  (mpbiran2_2 : ⊦ wb ph (wa ps ch)) :
  ⊦ wb ph ps :=
@mpbiran ph ch ps
  mpbiran2_1
  (@biancomi ph ch ps
    mpbiran2_2)


/-- Detach a conjunction of truths in a biconditional. (Contributed by NM, 10-May-2005.) -/
theorem mpbir2an {ph ps ch : wff}
  (mpbir2an_1 : ⊦ ps)
  (mpbir2an_2 : ⊦ ch)
  (mpbir2an_maj : ⊦ wb ph (wa ps ch)) :
  ⊦ ph :=
@mpbir ph ch
  mpbir2an_2
  (@mpbiran ph ps ch
    mpbir2an_1
    mpbir2an_maj)


/-- Detach a conjunction of truths in a biconditional. (Contributed by NM, 6-Nov-2011.) (Proof
shortened by Wolf Lammen, 24-Nov-2012.) -/
theorem mpbi2and {ph ps ch th : wff}
  (mpbi2and_1 : ⊦ wi ph ps)
  (mpbi2and_2 : ⊦ wi ph ch)
  (mpbi2and_3 : ⊦ wi ph (wb (wa ps ch) th)) :
  ⊦ wi ph th :=
@mpbid ph (wa ps ch) th
  (@jca ph ps ch
    mpbi2and_1
    mpbi2and_2)
  mpbi2and_3


/-- Detach a conjunction of truths in a biconditional. (Contributed by NM, 6-Nov-2011.) (Proof
shortened by Wolf Lammen, 24-Nov-2012.) -/
theorem mpbir2and {ph ps ch th : wff}
  (mpbir2and_1 : ⊦ wi ph ch)
  (mpbir2and_2 : ⊦ wi ph th)
  (mpbir2and_3 : ⊦ wi ph (wb ps (wa ch th))) :
  ⊦ wi ph ps :=
@mpbird ph ps (wa ch th)
  (@jca ph ch th
    mpbir2and_1
    mpbir2and_2)
  mpbir2and_3


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 4-May-1994.) (Proof shortened by
Wolf Lammen, 24-Nov-2012.) -/
theorem adantll {ph ps ch th : wff}
  (adant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa th ph) ps) ch :=
@sylan (wa th ph) ph ps ch
  (@simpr th ph)
  adant2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 4-May-1994.) (Proof shortened by
Wolf Lammen, 24-Nov-2012.) -/
theorem adantlr {ph ps ch th : wff}
  (adant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa ph th) ps) ch :=
@sylan (wa ph th) ph ps ch
  (@simpl ph th)
  adant2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 4-May-1994.) (Proof shortened by
Wolf Lammen, 24-Nov-2012.) -/
theorem adantrl {ph ps ch th : wff}
  (adant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa ph (wa th ps)) ch :=
@sylan2 (wa th ps) ph ps ch
  (@simpr th ps)
  adant2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 4-May-1994.) (Proof shortened by
Wolf Lammen, 24-Nov-2012.) -/
theorem adantrr {ph ps ch th : wff}
  (adant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa ph (wa ps th)) ch :=
@sylan2 (wa ps th) ph ps ch
  (@simpl ps th)
  adant2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 2-Dec-2012.) -/
theorem adantlll {ph ps ch th ta : wff}
  (adantl2_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (wa (wa ta ph) ps) ch) th :=
@sylanl1 (wa ta ph) ph ps ch th
  (@simpr ta ph)
  adantl2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 4-Dec-2012.) -/
theorem adantllr {ph ps ch th ta : wff}
  (adantl2_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (wa (wa ph ta) ps) ch) th :=
@sylanl1 (wa ph ta) ph ps ch th
  (@simpl ph ta)
  adantl2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 4-Dec-2012.) -/
theorem adantlrl {ph ps ch th ta : wff}
  (adantl2_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (wa ph (wa ta ps)) ch) th :=
@sylanl2 (wa ta ps) ph ps ch th
  (@simpr ta ps)
  adantl2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 4-Dec-2012.) -/
theorem adantlrr {ph ps ch th ta : wff}
  (adantl2_1 : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (wa ph (wa ps ta)) ch) th :=
@sylanl2 (wa ps ta) ph ps ch th
  (@simpl ps ta)
  adantl2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 4-Dec-2012.) -/
theorem adantrll {ph ps ch th ta : wff}
  (adantr2_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (wa (wa ta ps) ch)) th :=
@sylanr1 (wa ta ps) ph ps ch th
  (@simpr ta ps)
  adantr2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 4-Dec-2012.) -/
theorem adantrlr {ph ps ch th ta : wff}
  (adantr2_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (wa (wa ps ta) ch)) th :=
@sylanr1 (wa ps ta) ph ps ch th
  (@simpl ps ta)
  adantr2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 4-Dec-2012.) -/
theorem adantrrl {ph ps ch th ta : wff}
  (adantr2_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (wa ps (wa ta ch))) th :=
@sylanr2 (wa ta ch) ph ps ch th
  (@simpr ta ch)
  adantr2_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 26-Dec-2004.) (Proof shortened by
Wolf Lammen, 4-Dec-2012.) -/
theorem adantrrr {ph ps ch th ta : wff}
  (adantr2_1 : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (wa ps (wa ch ta))) th :=
@sylanr2 (wa ch ta) ph ps ch th
  (@simpl ch ta)
  adantr2_1


/-- Deduction adding two conjuncts to antecedent. (Contributed by NM, 19-Oct-1999.) (Proof shortened
by Wolf Lammen, 20-Nov-2012.) -/
theorem ad2antrr {ph ps ch th : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa (wa ph ch) th) ps :=
@adantlr ph th ps ch
  (@adantr ph ps th
    ad2ant_1)


/-- Deduction adding two conjuncts to antecedent. (Contributed by NM, 19-Oct-1999.) (Proof shortened
by Wolf Lammen, 20-Nov-2012.) -/
theorem ad2antlr {ph ps ch th : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa (wa ch ph) th) ps :=
@adantll ph th ps ch
  (@adantr ph ps th
    ad2ant_1)


/-- Deduction adding two conjuncts to antecedent. (Contributed by NM, 19-Oct-1999.) -/
theorem ad2antrl {ph ps ch th : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa ch (wa ph th)) ps :=
@adantrr ch ph ps th
  (@adantl ph ps ch
    ad2ant_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by NM, 19-Oct-1999.) -/
theorem ad2antll {ph ps ch th : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa ch (wa th ph)) ps :=
@adantl (wa th ph) ps ch
  (@adantl ph ps th
    ad2ant_1)


/-- Deduction adding three conjuncts to antecedent. (Contributed by NM, 28-Jul-2012.) -/
theorem ad3antrrr {ph ps ch th ta : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa (wa (wa ph ch) th) ta) ps :=
@ad2antrr (wa ph ch) ps th ta
  (@adantr ph ps ch
    ad2ant_1)


/-- Deduction adding three conjuncts to antecedent. (Contributed by Mario Carneiro, 5-Jan-2017.)
(Proof shortened by Wolf Lammen, 5-Apr-2022.) -/
theorem ad3antlr {ph ps ch th ta : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa (wa (wa ch ph) th) ta) ps :=
@ad2antrr (wa ch ph) ps th ta
  (@adantl ph ps ch
    ad2ant_1)


/-- Deduction adding 4 conjuncts to antecedent. (Contributed by Mario Carneiro, 4-Jan-2017.) (Proof
shortened by Wolf Lammen, 5-Apr-2022.) -/
theorem ad4antr {ph ps ch th ta et : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa (wa (wa (wa ph ch) th) ta) et) ps :=
@ad3antrrr (wa ph ch) ps th ta et
  (@adantr ph ps ch
    ad2ant_1)


/-- Deduction adding 4 conjuncts to antecedent. (Contributed by Mario Carneiro, 5-Jan-2017.) (Proof
shortened by Wolf Lammen, 5-Apr-2022.) -/
theorem ad4antlr {ph ps ch th ta et : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa (wa (wa (wa ch ph) th) ta) et) ps :=
@ad3antrrr (wa ch ph) ps th ta et
  (@adantl ph ps ch
    ad2ant_1)


/-- Deduction adding 5 conjuncts to antecedent. (Contributed by Mario Carneiro, 4-Jan-2017.) (Proof
shortened by Wolf Lammen, 5-Apr-2022.) -/
theorem ad5antr {ph ps ch th ta et ze : wff}
  (ad2ant_1 : ⊦ wi ph ps) :
  ⊦ wi (wa (wa (wa (wa (wa ph ch) th) ta) et) ze) ps :=
@ad4antr (wa ph ch) ps th ta et ze
  (@adantr ph ps ch
    ad2ant_1)


/-- Deduction adding two conjuncts to antecedent. (Contributed by NM, 8-Jan-2006.) -/
theorem ad2ant2l {ph ps ch th ta : wff}
  (ad2ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa th ph) (wa ta ps)) ch :=
@adantll ph (wa ta ps) ch th
  (@adantrl ph ps ch ta
    ad2ant2_1)


/-- Deduction adding two conjuncts to antecedent. (Contributed by NM, 8-Jan-2006.) -/
theorem ad2ant2r {ph ps ch th ta : wff}
  (ad2ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa ph th) (wa ps ta)) ch :=
@adantlr ph (wa ps ta) ch th
  (@adantrr ph ps ch ta
    ad2ant2_1)


/-- Deduction adding two conjuncts to antecedent. (Contributed by NM, 23-Nov-2007.) -/
theorem ad2ant2lr {ph ps ch th ta : wff}
  (ad2ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa th ph) (wa ps ta)) ch :=
@adantll ph (wa ps ta) ch th
  (@adantrr ph ps ch ta
    ad2ant2_1)


/-- Deduction adding two conjuncts to antecedent. (Contributed by NM, 24-Nov-2007.) -/
theorem ad2ant2rl {ph ps ch th ta : wff}
  (ad2ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa ph th) (wa ta ps)) ch :=
@adantlr ph (wa ta ps) ch th
  (@adantrl ph ps ch ta
    ad2ant2_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad4ant13 {ph ps ch th ta : wff}
  (ad4ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa ph th) ps) ta) ch :=
@adantllr ph ps ta ch th
  (@adantr (wa ph ps) ch ta
    ad4ant2_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad4ant14 {ph ps ch th ta : wff}
  (ad4ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa ph th) ta) ps) ch :=
@adantlr (wa ph th) ps ch ta
  (@adantlr ph ps ch th
    ad4ant2_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad4ant23 {ph ps ch th ta : wff}
  (ad4ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa th ph) ps) ta) ch :=
@adantlll ph ps ta ch th
  (@adantr (wa ph ps) ch ta
    ad4ant2_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad4ant24 {ph ps ch th ta : wff}
  (ad4ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa th ph) ta) ps) ch :=
@adantlll ph ta ps ch th
  (@adantlr ph ps ch ta
    ad4ant2_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) -/
theorem ad5ant12 {ph ps ch th ta et : wff}
  (ad5ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa (wa ph ps) th) ta) et) ch :=
@ad3antrrr (wa ph ps) ch th ta et
  ad5ant2_1


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad5ant14 {ph ps ch th ta et : wff}
  (ad5ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa (wa ph th) ta) ps) et) ch :=
@ad4ant13 (wa ph th) ps ch ta et
  (@adantlr ph ps ch th
    ad5ant2_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad5ant15 {ph ps ch th ta et : wff}
  (ad5ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa (wa ph th) ta) et) ps) ch :=
@ad4ant14 (wa ph th) ps ch ta et
  (@adantlr ph ps ch th
    ad5ant2_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad5ant24 {ph ps ch th ta et : wff}
  (ad5ant2_1 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (wa (wa (wa (wa th ph) ta) ps) et) ch :=
@ad4ant13 (wa th ph) ps ch ta et
  (@adantll ph ps ch th
    ad5ant2_1)


/-- Simplification of a conjunction. (Contributed by NM, 18-Mar-2007.) -/
theorem simpll {ph ps ch : wff} :
  ⊦ wi (wa (wa ph ps) ch) ph :=
@ad2antrr ph ph ps ch
  (@id ph)


/-- Deduction form of ~ simpll , eliminating a double conjunct. (Contributed by Glauco Siliprandi,
11-Dec-2019.) -/
theorem simplld {ph ps ch th : wff}
  (simplld_1 : ⊦ wi ph (wa (wa ps ch) th)) :
  ⊦ wi ph ps :=
@simpld ph ps ch
  (@simpld ph (wa ps ch) th
    simplld_1)


/-- Simplification of a conjunction. (Contributed by NM, 20-Mar-2007.) -/
theorem simplr {ph ps ch : wff} :
  ⊦ wi (wa (wa ph ps) ch) ps :=
@ad2antlr ps ps ph ch
  (@id ps)


/-- Simplification of a conjunction. (Contributed by NM, 21-Mar-2007.) -/
theorem simprl {ph ps ch : wff} :
  ⊦ wi (wa ph (wa ps ch)) ps :=
@ad2antrl ps ps ph ch
  (@id ps)


/-- Deduction eliminating a double conjunct. (Contributed by Glauco Siliprandi, 11-Dec-2019.) -/
theorem simprld {ph ps ch th : wff}
  (simprld_1 : ⊦ wi ph (wa ps (wa ch th))) :
  ⊦ wi ph ch :=
@simpld ph ch th
  (@simprd ph ps (wa ch th)
    simprld_1)


/-- Simplification of a conjunction. (Contributed by NM, 21-Mar-2007.) -/
theorem simprr {ph ps ch : wff} :
  ⊦ wi (wa ph (wa ps ch)) ch :=
@ad2antll ch ch ph ps
  (@id ch)


/-- Deduction form of ~ simprr , eliminating a double conjunct. (Contributed by Glauco Siliprandi,
11-Dec-2019.) -/
theorem simprrd {ph ps ch th : wff}
  (simprrd_1 : ⊦ wi ph (wa ps (wa ch th))) :
  ⊦ wi ph th :=
@simprd ph ch th
  (@simprd ph ps (wa ch th)
    simprrd_1)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) (Proof shortened by
Wolf Lammen, 6-Apr-2022.) -/
theorem simplll {ph ps ch th : wff} :
  ⊦ wi (wa (wa (wa ph ps) ch) th) ph :=
@ad3antrrr ph ph ps ch th
  (@id ph)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) (Proof shortened by
Wolf Lammen, 6-Apr-2022.) -/
theorem simpllr {ph ps ch th : wff} :
  ⊦ wi (wa (wa (wa ph ps) ch) th) ps :=
@ad3antlr ps ps ph ch th
  (@id ps)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) -/
theorem simplrl {ph ps ch th : wff} :
  ⊦ wi (wa (wa ph (wa ps ch)) th) ps :=
@ad2antlr (wa ps ch) ps ph th
  (@simpl ps ch)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) -/
theorem simplrr {ph ps ch th : wff} :
  ⊦ wi (wa (wa ph (wa ps ch)) th) ch :=
@ad2antlr (wa ps ch) ch ph th
  (@simpr ps ch)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) -/
theorem simprll {ph ps ch th : wff} :
  ⊦ wi (wa ph (wa (wa ps ch) th)) ps :=
@ad2antrl (wa ps ch) ps ph th
  (@simpl ps ch)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) -/
theorem simprlr {ph ps ch th : wff} :
  ⊦ wi (wa ph (wa (wa ps ch) th)) ch :=
@ad2antrl (wa ps ch) ch ph th
  (@simpr ps ch)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) -/
theorem simprrl {ph ps ch th : wff} :
  ⊦ wi (wa ph (wa ps (wa ch th))) ch :=
@ad2antll (wa ch th) ch ph ps
  (@simpl ch th)


/-- Simplification of a conjunction. (Contributed by Jeff Hankins, 28-Jul-2009.) -/
theorem simprrr {ph ps ch th : wff} :
  ⊦ wi (wa ph (wa ps (wa ch th))) th :=
@ad2antll (wa ch th) th ph ps
  (@simpr ch th)


/-- Simplification of a conjunction. (Contributed by Mario Carneiro, 4-Jan-2017.) (Proof shortened
by Wolf Lammen, 24-May-2022.) -/
theorem simp_4l {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa (wa (wa ph ps) ch) th) ta) ph :=
@ad4antr ph ph ps ch th ta
  (@id ph)


/-- Simplification of a conjunction. (Contributed by Mario Carneiro, 4-Jan-2017.) (Proof shortened
by Wolf Lammen, 24-May-2022.) -/
theorem simp_4r {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa (wa (wa ph ps) ch) th) ta) ps :=
@ad4antlr ps ps ph ch th ta
  (@id ps)


/-- Deduction based on reductio ad absurdum. See ~ pm2.01 . (Contributed by Mario Carneiro,
9-Feb-2017.) -/
theorem pm2_01da {ph ps : wff}
  (pm2_01da_1 : ⊦ wi (wa ph ps) (wn ps)) :
  ⊦ wi ph (wn ps) :=
@pm2_01d ph ps
  (@ex ph ps (wn ps)
    pm2_01da_1)


/-- Deduce an equivalence from two implications. Variant of ~ impbid . (Contributed by NM,
17-Feb-2007.) -/
theorem impbida {ph ps ch : wff}
  (impbida_1 : ⊦ wi (wa ph ps) ch)
  (impbida_2 : ⊦ wi (wa ph ch) ps) :
  ⊦ wi ph (wb ps ch) :=
@impbid ph ps ch
  (@ex ph ps ch
    impbida_1)
  (@ex ph ch ps
    impbida_2)


/-- Eliminate an antecedent implied by each side of a biconditional. Variant of ~ pm5.21ndd .
(Contributed by NM, 20-Nov-2005.) (Proof shortened by Wolf Lammen, 4-Nov-2013.) -/
theorem pm5_21nd {ph ps ch th : wff}
  (pm5_21nd_1 : ⊦ wi (wa ph ps) th)
  (pm5_21nd_2 : ⊦ wi (wa ph ch) th)
  (pm5_21nd_3 : ⊦ wi th (wb ps ch)) :
  ⊦ wi ph (wb ps ch) :=
@pm5_21ndd ph th ps ch
  (@ex ph ps th
    pm5_21nd_1)
  (@ex ph ch th
    pm5_21nd_2)
  (@a1i (wi th (wb ps ch)) ph
    pm5_21nd_3)


/-- Conjunctive detachment. Theorem *3.35 of [WhiteheadRussell] p. 112. Variant of ~ pm2.27 .
(Contributed by NM, 14-Dec-2002.) -/
theorem pm3_35 {ph ps : wff} :
  ⊦ wi (wa ph (wi ph ps)) ps :=
@imp ph (wi ph ps) ps
  (@pm2_27 ph ps)


/-- Distribution of implication over biconditional (deduction form). Variant of ~ pm5.74d .
(Contributed by NM, 4-May-2007.) -/
theorem pm5_74da {ph ps ch th : wff}
  (pm5_74da_1 : ⊦ wi (wa ph ps) (wb ch th)) :
  ⊦ wi ph (wb (wi ps ch) (wi ps th)) :=
@pm5_74d ph ps ch th
  (@ex ph ps (wb ch th)
    pm5_74da_1)


/-- Theorem *4.14 of [WhiteheadRussell] p. 117. Related to ~ con34b . (Contributed by NM,
3-Jan-2005.) (Proof shortened by Wolf Lammen, 23-Oct-2012.) -/
theorem pm4_14 {ph ps ch : wff} :
  ⊦ wb (wi (wa ph ps) ch) (wi (wa ph (wn ch)) (wn ps)) :=
@«3bitr4i» (wi ph (wi ps ch)) (wi ph (wi (wn ch) (wn ps))) (wi (wa ph ps) ch) (wi (wa ph (wn ch)) (wn ps))
  (@imbi2i (wi ps ch) (wi (wn ch) (wn ps)) ph
    (@con34b ps ch))
  (@impexp ph ps ch)
  (@impexp ph (wn ch) (wn ps))


/-- Conjoin antecedents and consequents of two premises. This is the closed theorem form of ~
anim12d . Theorem *3.47 of [WhiteheadRussell] p. 113. It was proved by Leibniz, and it evidently
pleased him enough to call it _praeclarum theorema_ (splendid theorem). (Contributed by NM,
12-Aug-1993.) (Proof shortened by Wolf Lammen, 7-Apr-2013.) -/
theorem anim12 {ph ps ch th : wff} :
  ⊦ wi (wa (wi ph ps) (wi ch th)) (wi (wa ph ch) (wa ps th)) :=
@im2anan9 (wi ph ps) ph ps (wi ch th) ch th
  (@id (wi ph ps))
  (@id (wi ch th))


/-- Inference form of ~ exbir . This proof is ~ exbiriVD automatically translated and minimized.
(Contributed by Alan Sare, 31-Dec-2011.) (Proof shortened by Wolf Lammen, 27-Jan-2013.) -/
theorem exbiri {ph ps ch th : wff}
  (exbiri_1 : ⊦ wi (wa ph ps) (wb ch th)) :
  ⊦ wi ph (wi ps (wi th ch)) :=
@exp31 ph ps th ch
  (@biimpar (wa ph ps) ch th
    exbiri_1)


/-- Elimination of an antecedent. (Contributed by NM, 1-Jan-2005.) -/
theorem pm2_61ian {ph ps ch : wff}
  (pm2_61ian_1 : ⊦ wi (wa ph ps) ch)
  (pm2_61ian_2 : ⊦ wi (wa (wn ph) ps) ch) :
  ⊦ wi ps ch :=
@pm2_61i ph (wi ps ch)
  (@ex ph ps ch
    pm2_61ian_1)
  (@ex (wn ph) ps ch
    pm2_61ian_2)


/-- Elimination of an antecedent. (Contributed by NM, 1-Jan-2005.) -/
theorem pm2_61dan {ph ps ch : wff}
  (pm2_61dan_1 : ⊦ wi (wa ph ps) ch)
  (pm2_61dan_2 : ⊦ wi (wa ph (wn ps)) ch) :
  ⊦ wi ph ch :=
@pm2_61d ph ps ch
  (@ex ph ps ch
    pm2_61dan_1)
  (@ex ph (wn ps) ch
    pm2_61dan_2)


/-- A modus tollens deduction. (Contributed by Jeff Hankins, 19-Aug-2009.) -/
theorem mtand {ph ps ch : wff}
  (mtand_1 : ⊦ wi ph (wn ch))
  (mtand_2 : ⊦ wi (wa ph ps) ch) :
  ⊦ wi ph (wn ps) :=
@mtod ph ps ch
  mtand_1
  (@ex ph ps ch
    mtand_2)


/-- Deduction for proof by contradiction. (Contributed by NM, 12-Jun-2014.) -/
theorem pm2_65da {ph ps ch : wff}
  (pm2_65da_1 : ⊦ wi (wa ph ps) ch)
  (pm2_65da_2 : ⊦ wi (wa ph ps) (wn ch)) :
  ⊦ wi ph (wn ps) :=
@pm2_65d ph ps ch
  (@ex ph ps ch
    pm2_65da_1)
  (@ex ph ps (wn ch)
    pm2_65da_2)


/-- Proof by contradiction. (Contributed by NM, 9-Feb-2006.) (Proof shortened by Wolf Lammen,
19-Jun-2014.) -/
theorem condan {ph ps ch : wff}
  (condan_1 : ⊦ wi (wa ph (wn ps)) ch)
  (condan_2 : ⊦ wi (wa ph (wn ps)) (wn ch)) :
  ⊦ wi ph ps :=
@notnotrd ph ps
  (@pm2_65da ph (wn ps) ch
    condan_1
    condan_2)


/-- An implication is equivalent to the equivalence of some implied equivalence and some other
equivalence involving a conjunction. A utility lemma as illustrated in ~ biadanii and ~ elelb .
(Contributed by BJ, 4-Mar-2023.) (Proof shortened by Wolf Lammen, 8-Mar-2023.) -/
theorem biadan {ph ps ch : wff} :
  ⊦ wb (wi ph ps) (wb (wi ps (wb ph ch)) (wb ph (wa ps ch))) :=
@«3bitri» (wi ph ps) (wb ph (wa ps ph)) (wb (wa ps ph) ph) (wb (wi ps (wb ph ch)) (wb ph (wa ps ch)))
  (@pm4_71r ph ps)
  (@bicom ph (wa ps ph))
  (@«3bitr4ri» (wb (wb ph (wa ps ch)) (wi ps (wb ph ch))) (wb (wb (wa ps ch) ph) (wb (wa ps ph) (wa ps ch))) (wb (wi ps (wb ph ch)) (wb ph (wa ps ch))) (wb (wa ps ph) ph)
    (@bibi12i (wb ph (wa ps ch)) (wb (wa ps ch) ph) (wi ps (wb ph ch)) (wb (wa ps ph) (wa ps ch))
      (@bicom ph (wa ps ch))
      (@pm5_32 ps ph ch))
    (@bicom (wi ps (wb ph ch)) (wb ph (wa ps ch)))
    (@biluk (wa ps ph) ph (wa ps ch)))


/-- Inference associated with ~ biadan . (Contributed by BJ, 4-Mar-2023.) -/
theorem biadani {ph ps ch : wff}
  (biadani_1 : ⊦ wi ph ps) :
  ⊦ wb (wi ps (wb ph ch)) (wb ph (wa ps ch)) :=
@mpbi (wi ph ps) (wb (wi ps (wb ph ch)) (wb ph (wa ps ch)))
  biadani_1
  (@biadan ph ps ch)


/-- Inference associated with ~ biadani . Add a conjunction to an equivalence. (Contributed by Jeff
Madsen, 20-Jun-2011.) (Proof shortened by BJ, 4-Mar-2023.) -/
theorem biadanii {ph ps ch : wff}
  (biadani_1 : ⊦ wi ph ps)
  (biadanii_2 : ⊦ wi ps (wb ph ch)) :
  ⊦ wb ph (wa ps ch) :=
@mpbi (wi ps (wb ph ch)) (wb ph (wa ps ch))
  biadanii_2
  (@biadani ph ps ch
    biadani_1)


/-- Two propositions are equivalent if they are both true. Theorem *5.1 of [WhiteheadRussell] p.
123. (Contributed by NM, 21-May-1994.) -/
theorem pm5_1 {ph ps : wff} :
  ⊦ wi (wa ph ps) (wb ph ps) :=
@biimpa ph ps (wb ph ps)
  (@pm5_501 ph ps)


/-- Introduce one conjunct as an antecedent to the other. "abai" stands for "and, biconditional,
and, implication". (Contributed by NM, 12-Aug-1993.) (Proof shortened by Wolf Lammen, 7-Dec-2012.)
-/
theorem abai {ph ps : wff} :
  ⊦ wb (wa ph ps) (wa ph (wi ph ps)) :=
@pm5_32i ph ps (wi ph ps)
  (@biimt ph ps)


/-- Conjunction with implication. Compare Theorem *4.45 of [WhiteheadRussell] p. 119. (Contributed
by NM, 17-May-1998.) -/
theorem pm4_45im {ph ps : wff} :
  ⊦ wb ph (wa ph (wi ps ph)) :=
@pm4_71i ph (wi ps ph)
  (@ax_1 ph ps)


/-- Syllogism combined with contraction. (Contributed by Jeff Hankins, 1-Aug-2009.) -/
theorem syl12anc {ph ps ch th ta : wff}
  (syl12anc_1 : ⊦ wi ph ps)
  (syl12anc_2 : ⊦ wi ph ch)
  (syl12anc_3 : ⊦ wi ph th)
  (syl12anc_4 : ⊦ wi (wa ps (wa ch th)) ta) :
  ⊦ wi ph ta :=
@syl2anc ph ps (wa ch th) ta
  syl12anc_1
  (@jca ph ch th
    syl12anc_2
    syl12anc_3)
  syl12anc_4


/-- Syllogism combined with contraction. (Contributed by Jeff Hankins, 1-Aug-2009.) -/
theorem syl21anc {ph ps ch th ta : wff}
  (syl12anc_1 : ⊦ wi ph ps)
  (syl12anc_2 : ⊦ wi ph ch)
  (syl12anc_3 : ⊦ wi ph th)
  (syl21anc_4 : ⊦ wi (wa (wa ps ch) th) ta) :
  ⊦ wi ph ta :=
@syl2anc ph (wa ps ch) th ta
  (@jca ph ps ch
    syl12anc_1
    syl12anc_2)
  syl12anc_3
  syl21anc_4


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl22anc {ph ps ch th ta et : wff}
  (syl12anc_1 : ⊦ wi ph ps)
  (syl12anc_2 : ⊦ wi ph ch)
  (syl12anc_3 : ⊦ wi ph th)
  (syl22anc_4 : ⊦ wi ph ta)
  (syl22anc_5 : ⊦ wi (wa (wa ps ch) (wa th ta)) et) :
  ⊦ wi ph et :=
@syl12anc ph (wa ps ch) th ta et
  (@jca ph ps ch
    syl12anc_1
    syl12anc_2)
  syl12anc_3
  syl22anc_4
  syl22anc_5


/-- Removal of conjunct from one side of an equivalence. (Contributed by NM, 21-Jun-1993.) -/
theorem bimsc1 {ph ps ch : wff} :
  ⊦ wi (wa (wi ph ps) (wb ch (wa ps ph))) (wb ch ph) :=
@sylan9bbr (wb ch (wa ps ph)) ch (wa ps ph) (wi ph ps) ph
  (@id (wb ch (wa ps ph)))
  (@impbid2 (wi ph ps) (wa ps ph) ph
    (@simpr ps ph)
    (@ancr ph ps))


/-- Deduction deriving nested implications from conjunctions. (Contributed by AV, 21-Aug-2022.) -/
theorem animpimp2impd {ph ps ch th ta et : wff}
  (animpimp2impd_1 : ⊦ wi (wa ps ph) (wi ch (wi th et)))
  (animpimp2impd_2 : ⊦ wi (wa ps (wa ph th)) (wi et ta)) :
  ⊦ wi ph (wi (wi ps ch) (wi ps (wi th ta))) :=
@a2d ph ps ch (wi th ta)
  (@expcom ps ph (wi ch (wi th ta))
    (@syld (wa ps ph) ch (wi th et) (wi th ta)
      animpimp2impd_1
      (@a2d (wa ps ph) th et ta
        (@expr ps ph th (wi et ta)
          animpimp2impd_2))))


-- /-- Extend wff definition to include disjunction ("or"). -/
-- constant wo : wff → wff → wff


-- /-- Define disjunction (logical "or"). Definition of [Margaris] p. 49. When the left operand,
-- right operand, or both are true, the result is true; when both sides are false, the result is
-- false. For example, it is true that ` ( 2 = 3 \/ 4 = 4 ) ` ( ~ ex-or ). After we define the
-- constant true ` T. ` ( ~ df-tru ) and the constant false ` F. ` ( ~ df-fal ), we will be able to
-- prove these truth table values: ` ( ( T. \/ T. ) <-> T. ) ` ( ~ truortru ), ` ( ( T. \/ F. ) <->
-- T. ) ` ( ~ truorfal ), ` ( ( F. \/ T. ) <-> T. ) ` ( ~ falortru ), and ` ( ( F. \/ F. ) <-> F. )
-- ` ( ~ falorfal ). Contrast with ` /\ ` ( ~ df-an ), ` -> ` ( ~ wi ), ` -/\ ` ( ~ df-nan ), and `
-- \/_ ` ( ~ df-xor ). (Contributed by NM, 27-Dec-1992.) -/
-- axiom df_or {ph ps : wff} : ⊦ wb (wo ph ps) (wi (wn ph) ps)


/-- Theorem *4.64 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_64 {ph ps : wff} :
  ⊦ wb (wi (wn ph) ps) (wo ph ps) :=
@bicomi (wo ph ps) (wi (wn ph) ps)
  (@df_or ph ps)


/-- Theorem *2.53 of [WhiteheadRussell] p. 107. (Contributed by NM, 3-Jan-2005.) -/
theorem pm2_53 {ph ps : wff} :
  ⊦ wi (wo ph ps) (wi (wn ph) ps) :=
@biimpi (wo ph ps) (wi (wn ph) ps)
  (@df_or ph ps)


/-- Theorem *2.54 of [WhiteheadRussell] p. 107. (Contributed by NM, 3-Jan-2005.) -/
theorem pm2_54 {ph ps : wff} :
  ⊦ wi (wi (wn ph) ps) (wo ph ps) :=
@biimpri (wo ph ps) (wi (wn ph) ps)
  (@df_or ph ps)


/-- Implication in terms of disjunction. Theorem *4.6 of [WhiteheadRussell] p. 120. (Contributed by
NM, 3-Jan-1993.) -/
theorem imor {ph ps : wff} :
  ⊦ wb (wi ph ps) (wo (wn ph) ps) :=
@bitr4i (wi ph ps) (wi (wn (wn ph)) ps) (wo (wn ph) ps)
  (@imbi1i ph (wn (wn ph)) ps
    (@notnotb ph))
  (@df_or (wn ph) ps)


/-- Infer disjunction from implication. (Contributed by NM, 12-Mar-2012.) -/
theorem imori {ph ps : wff}
  (imori_1 : ⊦ wi ph ps) :
  ⊦ wo (wn ph) ps :=
@mpbi (wi ph ps) (wo (wn ph) ps)
  imori_1
  (@imor ph ps)


/-- Theorem *4.62 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_62 {ph ps : wff} :
  ⊦ wb (wi ph (wn ps)) (wo (wn ph) (wn ps)) :=
@imor ph (wn ps)


/-- Inference disjoining the antecedents of two implications. (Contributed by NM, 5-Apr-1994.) -/
theorem jaoi {ph ps ch : wff}
  (jaoi_1 : ⊦ wi ph ps)
  (jaoi_2 : ⊦ wi ch ps) :
  ⊦ wi (wo ph ch) ps :=
@pm2_61d2 (wo ph ch) ph ps
  (@syl6 (wo ph ch) (wn ph) ch ps
    (@pm2_53 ph ch)
    jaoi_2)
  jaoi_1


/-- Add a disjunct in the antecedent of an implication. (Contributed by Rodolfo Medina,
24-Sep-2010.) -/
theorem jao1i {ph ps ch : wff}
  (jao1i_1 : ⊦ wi ps (wi ch ph)) :
  ⊦ wi (wo ph ps) (wi ch ph) :=
@jaoi ph (wi ch ph) ps
  (@ax_1 ph ch)
  jao1i_1


/-- Deduction disjoining the antecedents of two implications. (Contributed by NM, 18-Aug-1994.) -/
theorem jaod {ph ps ch th : wff}
  (jaod_1 : ⊦ wi ph (wi ps ch))
  (jaod_2 : ⊦ wi ph (wi th ch)) :
  ⊦ wi ph (wi (wo ps th) ch) :=
@com12 (wo ps th) ph ch
  (@jaoi ps (wi ph ch) th
    (@com12 ph ps ch
      jaod_1)
    (@com12 ph th ch
      jaod_2))


/-- Eliminate a disjunction in a deduction. (Contributed by Mario Carneiro, 29-May-2016.) -/
theorem mpjaod {ph ps ch th : wff}
  (jaod_1 : ⊦ wi ph (wi ps ch))
  (jaod_2 : ⊦ wi ph (wi th ch))
  (jaod_3 : ⊦ wi ph (wo ps th)) :
  ⊦ wi ph ch :=
@mpd ph (wo ps th) ch
  jaod_3
  (@jaod ph ps ch th
    jaod_1
    jaod_2)


/-- Infer implication from disjunction. (Contributed by NM, 11-Jun-1994.) -/
theorem ori {ph ps : wff}
  (ori_1 : ⊦ wo ph ps) :
  ⊦ wi (wn ph) ps :=
@mpbi (wo ph ps) (wi (wn ph) ps)
  ori_1
  (@df_or ph ps)


/-- Infer disjunction from implication. (Contributed by NM, 11-Jun-1994.) -/
theorem orri {ph ps : wff}
  (orri_1 : ⊦ wi (wn ph) ps) :
  ⊦ wo ph ps :=
@mpbir (wo ph ps) (wi (wn ph) ps)
  orri_1
  (@df_or ph ps)


/-- Deduce disjunction from implication. (Contributed by NM, 27-Nov-1995.) -/
theorem orrd {ph ps ch : wff}
  (orrd_1 : ⊦ wi ph (wi (wn ps) ch)) :
  ⊦ wi ph (wo ps ch) :=
@syl ph (wi (wn ps) ch) (wo ps ch)
  orrd_1
  (@pm2_54 ps ch)


/-- Deduce implication from disjunction. (Contributed by NM, 18-May-1994.) -/
theorem ord {ph ps ch : wff}
  (ord_1 : ⊦ wi ph (wo ps ch)) :
  ⊦ wi ph (wi (wn ps) ch) :=
@sylib ph (wo ps ch) (wi (wn ps) ch)
  ord_1
  (@df_or ps ch)


/-- Deduction introducing a disjunct. (Contributed by NM, 19-Jan-2008.) (Proof shortened by Wolf
Lammen, 14-Nov-2012.) -/
theorem orci {ph ps : wff}
  (orci_1 : ⊦ ph) :
  ⊦ wo ph ps :=
@orri ph ps
  (@pm2_24i ph ps
    orci_1)


/-- Deduction introducing a disjunct. (Contributed by NM, 19-Jan-2008.) (Proof shortened by Wolf
Lammen, 14-Nov-2012.) -/
theorem olci {ph ps : wff}
  (orci_1 : ⊦ ph) :
  ⊦ wo ps ph :=
@orri ps ph
  (@a1i ph (wn ps)
    orci_1)


/-- Introduction of a disjunct. Theorem *2.2 of [WhiteheadRussell] p. 104. (Contributed by NM,
30-Aug-1993.) -/
theorem orc {ph ps : wff} :
  ⊦ wi ph (wo ph ps) :=
@orrd ph ph ps
  (@pm2_24 ph ps)


/-- Introduction of a disjunct. Axiom *1.3 of [WhiteheadRussell] p. 96. (Contributed by NM,
30-Aug-1993.) -/
theorem olc {ph ps : wff} :
  ⊦ wi ph (wo ps ph) :=
@orrd ph ps ph
  (@ax_1 ph (wn ps))


/-- Axiom *1.4 of [WhiteheadRussell] p. 96. (Contributed by NM, 3-Jan-2005.) -/
theorem pm1_4 {ph ps : wff} :
  ⊦ wi (wo ph ps) (wo ps ph) :=
@jaoi ph (wo ps ph) ps
  (@olc ph ps)
  (@orc ps ph)


/-- Commutative law for disjunction. Theorem *4.31 of [WhiteheadRussell] p. 118. (Contributed by NM,
3-Jan-1993.) (Proof shortened by Wolf Lammen, 15-Nov-2012.) -/
theorem orcom {ph ps : wff} :
  ⊦ wb (wo ph ps) (wo ps ph) :=
@impbii (wo ph ps) (wo ps ph)
  (@pm1_4 ph ps)
  (@pm1_4 ps ph)


/-- Commutation of disjuncts in consequent. (Contributed by NM, 2-Dec-2010.) -/
theorem orcomd {ph ps ch : wff}
  (orcomd_1 : ⊦ wi ph (wo ps ch)) :
  ⊦ wi ph (wo ch ps) :=
@sylib ph (wo ps ch) (wo ch ps)
  orcomd_1
  (@orcom ps ch)


/-- Commutation of disjuncts in antecedent. (Contributed by NM, 2-Dec-2012.) -/
theorem orcoms {ph ps ch : wff}
  (orcoms_1 : ⊦ wi (wo ph ps) ch) :
  ⊦ wi (wo ps ph) ch :=
@syl (wo ps ph) (wo ph ps) ch
  (@pm1_4 ps ph)
  orcoms_1


/-- Deduction introducing a disjunct. A translation of natural deduction rule ` \/ ` IR ( ` \/ `
insertion right), see ~ natded . (Contributed by NM, 20-Sep-2007.) -/
theorem orcd {ph ps ch : wff}
  (orcd_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wo ps ch) :=
@syl ph ps (wo ps ch)
  orcd_1
  (@orc ps ch)


/-- Deduction introducing a disjunct. A translation of natural deduction rule ` \/ ` IL ( ` \/ `
insertion left), see ~ natded . (Contributed by NM, 11-Apr-2008.) (Proof shortened by Wolf Lammen,
3-Oct-2013.) -/
theorem olcd {ph ps ch : wff}
  (orcd_1 : ⊦ wi ph ps) :
  ⊦ wi ph (wo ch ps) :=
@orcomd ph ps ch
  (@orcd ph ps ch
    orcd_1)


/-- Deduction eliminating disjunct. _Notational convention_: We sometimes suffix with "s" the label
of an inference that manipulates an antecedent, leaving the consequent unchanged. The "s" means that
the inference eliminates the need for a syllogism ( ~ syl ) -type inference in a proof. (Contributed
by NM, 21-Jun-1994.) -/
theorem orcs {ph ps ch : wff}
  (orcs_1 : ⊦ wi (wo ph ps) ch) :
  ⊦ wi ph ch :=
@syl ph (wo ph ps) ch
  (@orc ph ps)
  orcs_1


/-- Deduction eliminating disjunct. (Contributed by NM, 21-Jun-1994.) (Proof shortened by Wolf
Lammen, 3-Oct-2013.) -/
theorem olcs {ph ps ch : wff}
  (olcs_1 : ⊦ wi (wo ph ps) ch) :
  ⊦ wi ps ch :=
@orcs ps ph ch
  (@orcoms ph ps ch
    olcs_1)


/-- Infer negated disjunction of negated premises. (Contributed by NM, 4-Apr-1995.) -/
theorem pm3_2ni {ph ps : wff}
  (pm3_2ni_1 : ⊦ wn ph)
  (pm3_2ni_2 : ⊦ wn ps) :
  ⊦ wn (wo ph ps) :=
@mto (wo ph ps) ph
  pm3_2ni_1
  (@jaoi ph ph ps
    (@id ph)
    (@pm2_21i ps ph
      pm3_2ni_2))


/-- Theorem *2.46 of [WhiteheadRussell] p. 106. (Contributed by NM, 3-Jan-2005.) -/
theorem pm2_46 {ph ps : wff} :
  ⊦ wi (wn (wo ph ps)) (wn ps) :=
@con3i ps (wo ph ps)
  (@olc ps ph)


/-- Elimination of disjunction by denial of a disjunct. Theorem *2.55 of [WhiteheadRussell] p. 107.
(Contributed by NM, 12-Aug-1994.) (Proof shortened by Wolf Lammen, 21-Jul-2012.) -/
theorem orel1 {ph ps : wff} :
  ⊦ wi (wn ph) (wi (wo ph ps) ps) :=
@com12 (wo ph ps) (wn ph) ps
  (@pm2_53 ph ps)


/-- Elimination of disjunction by denial of a disjunct. Theorem *2.56 of [WhiteheadRussell] p. 107.
(Contributed by NM, 12-Aug-1994.) (Proof shortened by Wolf Lammen, 5-Apr-2013.) -/
theorem orel2 {ph ps : wff} :
  ⊦ wi (wn ph) (wi (wo ps ph) ps) :=
@jaod (wn ph) ps ps ph
  (@idd (wn ph) ps)
  (@pm2_21 ph ps)


/-- Slight generalization of Theorem *2.67 of [WhiteheadRussell] p. 107. (Contributed by NM,
3-Jan-2005.) -/
theorem pm2_67_2 {ph ps ch : wff} :
  ⊦ wi (wi (wo ph ch) ps) (wi ph ps) :=
@imim1i ph (wo ph ch) ps
  (@orc ph ch)


/-- Law of excluded middle, also called the principle of _tertium non datur_. Theorem *2.11 of
[WhiteheadRussell] p. 101. It says that something is either true or not true; there are no
in-between values of truth. This is an essential distinction of our classical logic and is not a
theorem of intuitionistic logic. In intuitionistic logic, if this statement is true for some ` ph `
, then ` ph ` is decidable. (Contributed by NM, 29-Dec-1992.) -/
theorem exmid {ph : wff} :
  ⊦ wo ph (wn ph) :=
@orri ph (wn ph)
  (@id (wn ph))


/-- Theorem *2.1 of [WhiteheadRussell] p. 101. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 23-Nov-2012.) -/
theorem pm2_1 {ph : wff} :
  ⊦ wo (wn ph) ph :=
@imori ph ph
  (@id ph)


/-- Theorem *2.621 of [WhiteheadRussell] p. 107. (Contributed by NM, 3-Jan-2005.) -/
theorem pm2_621 {ph ps : wff} :
  ⊦ wi (wi ph ps) (wi (wo ph ps) ps) :=
@jaod (wi ph ps) ph ps ps
  (@id (wi ph ps))
  (@idd (wi ph ps) ps)


/-- Theorem *2.62 of [WhiteheadRussell] p. 107. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 13-Dec-2013.) -/
theorem pm2_62 {ph ps : wff} :
  ⊦ wi (wo ph ps) (wi (wi ph ps) ps) :=
@com12 (wi ph ps) (wo ph ps) ps
  (@pm2_621 ph ps)


/-- Theorem *2.07 of [WhiteheadRussell] p. 101. (Contributed by NM, 3-Jan-2005.) -/
theorem pm2_07 {ph : wff} :
  ⊦ wi ph (wo ph ph) :=
@olc ph ph


/-- Axiom *1.2 of [WhiteheadRussell] p. 96, which they call "Taut". (Contributed by NM, 3-Jan-2005.)
-/
theorem pm1_2 {ph : wff} :
  ⊦ wi (wo ph ph) ph :=
@jaoi ph ph ph
  (@id ph)
  (@id ph)


/-- Idempotent law for disjunction. Theorem *4.25 of [WhiteheadRussell] p. 117. (Contributed by NM,
11-May-1993.) (Proof shortened by Andrew Salmon, 16-Apr-2011.) (Proof shortened by Wolf Lammen,
10-Mar-2013.) -/
theorem oridm {ph : wff} :
  ⊦ wb (wo ph ph) ph :=
@impbii (wo ph ph) ph
  (@pm1_2 ph)
  (@pm2_07 ph)


/-- Disjoin antecedents and consequents of two premises. (Contributed by NM, 6-Jun-1994.) (Proof
shortened by Wolf Lammen, 25-Jul-2012.) -/
theorem orim12i {ph ps ch th : wff}
  (orim12i_1 : ⊦ wi ph ps)
  (orim12i_2 : ⊦ wi ch th) :
  ⊦ wi (wo ph ch) (wo ps th) :=
@jaoi ph (wo ps th) ch
  (@orcd ph ps th
    orim12i_1)
  (@olcd ch th ps
    orim12i_2)


/-- Introduce disjunct to both sides of an implication. (Contributed by NM, 6-Jun-1994.) -/
theorem orim1i {ph ps ch : wff}
  (orim1i_1 : ⊦ wi ph ps) :
  ⊦ wi (wo ph ch) (wo ps ch) :=
@orim12i ph ps ch ch
  orim1i_1
  (@id ch)


/-- Introduce disjunct to both sides of an implication. (Contributed by NM, 6-Jun-1994.) -/
theorem orim2i {ph ps ch : wff}
  (orim1i_1 : ⊦ wi ph ps) :
  ⊦ wi (wo ch ph) (wo ch ps) :=
@orim12i ch ch ph ps
  (@id ch)
  orim1i_1


/-- Inference adding a left disjunct to both sides of a logical equivalence. (Contributed by NM,
3-Jan-1993.) (Proof shortened by Wolf Lammen, 12-Dec-2012.) -/
theorem orbi2i {ph ps ch : wff}
  (orbi2i_1 : ⊦ wb ph ps) :
  ⊦ wb (wo ch ph) (wo ch ps) :=
@impbii (wo ch ph) (wo ch ps)
  (@orim2i ph ps ch
    (@biimpi ph ps
      orbi2i_1))
  (@orim2i ps ph ch
    (@biimpri ph ps
      orbi2i_1))


/-- Inference adding a right disjunct to both sides of a logical equivalence. (Contributed by NM,
3-Jan-1993.) -/
theorem orbi1i {ph ps ch : wff}
  (orbi2i_1 : ⊦ wb ph ps) :
  ⊦ wb (wo ph ch) (wo ps ch) :=
@«3bitri» (wo ph ch) (wo ch ph) (wo ch ps) (wo ps ch)
  (@orcom ph ch)
  (@orbi2i ph ps ch
    orbi2i_1)
  (@orcom ch ps)


/-- Infer the disjunction of two equivalences. (Contributed by NM, 3-Jan-1993.) -/
theorem orbi12i {ph ps ch th : wff}
  (orbi12i_1 : ⊦ wb ph ps)
  (orbi12i_2 : ⊦ wb ch th) :
  ⊦ wb (wo ph ch) (wo ps th) :=
@bitri (wo ph ch) (wo ph th) (wo ps th)
  (@orbi2i ch th ph
    orbi12i_2)
  (@orbi1i ph ps th
    orbi12i_1)


/-- Deduction adding a left disjunct to both sides of a logical equivalence. (Contributed by NM,
21-Jun-1993.) -/
theorem orbi2d {ph ps ch th : wff}
  (bid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wo th ps) (wo th ch)) :=
@«3bitr4g» ph (wi (wn th) ps) (wi (wn th) ch) (wo th ps) (wo th ch)
  (@imbi2d ph ps ch (wn th)
    bid_1)
  (@df_or th ps)
  (@df_or th ch)


/-- Deduction adding a right disjunct to both sides of a logical equivalence. (Contributed by NM,
21-Jun-1993.) -/
theorem orbi1d {ph ps ch th : wff}
  (bid_1 : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (wo ps th) (wo ch th)) :=
@«3bitr4g» ph (wo th ps) (wo th ch) (wo ps th) (wo ch th)
  (@orbi2d ph ps ch th
    bid_1)
  (@orcom ps th)
  (@orcom ch th)


/-- Theorem *4.37 of [WhiteheadRussell] p. 118. (Contributed by NM, 3-Jan-2005.) -/
theorem orbi1 {ph ps ch : wff} :
  ⊦ wi (wb ph ps) (wb (wo ph ch) (wo ps ch)) :=
@orbi1d (wb ph ps) ph ps ch
  (@id (wb ph ps))


/-- Deduction joining two equivalences to form equivalence of disjunctions. (Contributed by NM,
21-Jun-1993.) -/
theorem orbi12d {ph ps ch th ta : wff}
  (bi12d_1 : ⊦ wi ph (wb ps ch))
  (bi12d_2 : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb (wo ps th) (wo ch ta)) :=
@bitrd ph (wo ps th) (wo ch th) (wo ch ta)
  (@orbi1d ph ps ch th
    bi12d_1)
  (@orbi2d ph th ta ch
    bi12d_2)


/-- Axiom *1.5 (Assoc) of [WhiteheadRussell] p. 96. (Contributed by NM, 3-Jan-2005.) -/
theorem pm1_5 {ph ps ch : wff} :
  ⊦ wi (wo ph (wo ps ch)) (wo ps (wo ph ch)) :=
@jaoi ph (wo ps (wo ph ch)) (wo ps ch)
  (@olcd ph (wo ph ch) ps
    (@orc ph ch))
  (@orim2i ch (wo ph ch) ps
    (@olc ch ph))


/-- Swap two disjuncts. (Contributed by NM, 5-Aug-1993.) (Proof shortened by Wolf Lammen,
14-Nov-2012.) -/
theorem or12 {ph ps ch : wff} :
  ⊦ wb (wo ph (wo ps ch)) (wo ps (wo ph ch)) :=
@impbii (wo ph (wo ps ch)) (wo ps (wo ph ch))
  (@pm1_5 ph ps ch)
  (@pm1_5 ps ph ch)


/-- Associative law for disjunction. Theorem *4.33 of [WhiteheadRussell] p. 118. (Contributed by NM,
5-Aug-1993.) (Proof shortened by Andrew Salmon, 26-Jun-2011.) -/
theorem orass {ph ps ch : wff} :
  ⊦ wb (wo (wo ph ps) ch) (wo ph (wo ps ch)) :=
@«3bitri» (wo (wo ph ps) ch) (wo ch (wo ph ps)) (wo ph (wo ch ps)) (wo ph (wo ps ch))
  (@orcom (wo ph ps) ch)
  (@or12 ch ph ps)
  (@orbi2i (wo ch ps) (wo ps ch) ph
    (@orcom ch ps))


/-- A rearrangement of disjuncts. (Contributed by NM, 18-Oct-1995.) (Proof shortened by Andrew
Salmon, 26-Jun-2011.) -/
theorem or32 {ph ps ch : wff} :
  ⊦ wb (wo (wo ph ps) ch) (wo (wo ph ch) ps) :=
@«3bitri» (wo (wo ph ps) ch) (wo ph (wo ps ch)) (wo ps (wo ph ch)) (wo (wo ph ch) ps)
  (@orass ph ps ch)
  (@or12 ph ps ch)
  (@orcom ps (wo ph ch))


/-- Rearrangement of 4 disjuncts. (Contributed by NM, 12-Aug-1994.) -/
theorem or4 {ph ps ch th : wff} :
  ⊦ wb (wo (wo ph ps) (wo ch th)) (wo (wo ph ch) (wo ps th)) :=
@«3bitr4i» (wo ph (wo ps (wo ch th))) (wo ph (wo ch (wo ps th))) (wo (wo ph ps) (wo ch th)) (wo (wo ph ch) (wo ps th))
  (@orbi2i (wo ps (wo ch th)) (wo ch (wo ps th)) ph
    (@or12 ps ch th))
  (@orass ph ps (wo ch th))
  (@orass ph ch (wo ps th))


/-- Distribution of disjunction over disjunction. (Contributed by NM, 25-Feb-1995.) -/
theorem orordir {ph ps ch : wff} :
  ⊦ wb (wo (wo ph ps) ch) (wo (wo ph ch) (wo ps ch)) :=
@bitr3i (wo (wo ph ps) ch) (wo (wo ph ps) (wo ch ch)) (wo (wo ph ch) (wo ps ch))
  (@orbi2i (wo ch ch) ch (wo ph ps)
    (@oridm ch))
  (@or4 ph ps ch ch)


/-- A wff is equivalent to its disjunction with falsehood. Theorem *4.74 of [WhiteheadRussell] p.
121. (Contributed by NM, 23-Mar-1995.) (Proof shortened by Wolf Lammen, 18-Nov-2012.) -/
theorem biorf {ph ps : wff} :
  ⊦ wi (wn ph) (wb ps (wo ph ps)) :=
@impbid2 (wn ph) ps (wo ph ps)
  (@olc ps ph)
  (@orel1 ph ps)


/-- A wff is equivalent to its disjunction with falsehood. (Contributed by NM, 23-Mar-1995.) (Proof
shortened by Wolf Lammen, 16-Jul-2021.) -/
theorem biorfi {ph ps : wff}
  (biorfi_1 : ⊦ wn ph) :
  ⊦ wb ps (wo ps ph) :=
@impbii ps (wo ps ph)
  (@orc ps ph)
  (@mt3i (wo ps ph) ps ph
    biorfi_1
    (@pm2_53 ps ph))


/-- Implication in terms of biconditional and disjunction. Theorem *4.72 of [WhiteheadRussell] p.
121. (Contributed by NM, 30-Aug-1993.) (Proof shortened by Wolf Lammen, 30-Jan-2013.) -/
theorem pm4_72 {ph ps : wff} :
  ⊦ wb (wi ph ps) (wb ps (wo ph ps)) :=
@impbii (wi ph ps) (wb ps (wo ph ps))
  (@impbid2 (wi ph ps) ps (wo ph ps)
    (@olc ps ph)
    (@pm2_621 ph ps))
  (@syl5 ph (wo ph ps) (wb ps (wo ph ps)) ps
    (@orc ph ps)
    (@biimpr ps (wo ph ps)))


/-- Inference conjoining and disjoining the antecedents of two implications. (Contributed by NM,
30-Sep-1999.) -/
theorem jaao {ph ps ch th ta : wff}
  (jaao_1 : ⊦ wi ph (wi ps ch))
  (jaao_2 : ⊦ wi th (wi ta ch)) :
  ⊦ wi (wa ph th) (wi (wo ps ta) ch) :=
@jaod (wa ph th) ps ch ta
  (@adantr ph (wi ps ch) th
    jaao_1)
  (@adantl th (wi ta ch) ph
    jaao_2)


/-- Inference disjoining and conjoining the antecedents of two implications. (Contributed by Stefan
Allan, 1-Nov-2008.) -/
theorem jaoa {ph ps ch th ta : wff}
  (jaao_1 : ⊦ wi ph (wi ps ch))
  (jaao_2 : ⊦ wi th (wi ta ch)) :
  ⊦ wi (wo ph th) (wi (wa ps ta) ch) :=
@jaoi ph (wi (wa ps ta) ch) th
  (@adantrd ph ps ch ta
    jaao_1)
  (@adantld th ta ch ps
    jaao_2)


/-- Inference disjoining the antecedents of two implications. (Contributed by NM, 23-Oct-2005.) -/
theorem jaoian {ph ps ch th : wff}
  (jaoian_1 : ⊦ wi (wa ph ps) ch)
  (jaoian_2 : ⊦ wi (wa th ps) ch) :
  ⊦ wi (wa (wo ph th) ps) ch :=
@imp (wo ph th) ps ch
  (@jaoi ph (wi ps ch) th
    (@ex ph ps ch
      jaoian_1)
    (@ex th ps ch
      jaoian_2))


/-- Deduction disjoining the antecedents of two implications. (Contributed by NM, 14-Oct-2005.) -/
theorem jaodan {ph ps ch th : wff}
  (jaodan_1 : ⊦ wi (wa ph ps) ch)
  (jaodan_2 : ⊦ wi (wa ph th) ch) :
  ⊦ wi (wa ph (wo ps th)) ch :=
@imp ph (wo ps th) ch
  (@jaod ph ps ch th
    (@ex ph ps ch
      jaodan_1)
    (@ex ph th ch
      jaodan_2))


/-- Eliminate a disjunction in a deduction. A translation of natural deduction rule ` \/ ` E ( ` \/
` elimination), see ~ natded . (Contributed by Mario Carneiro, 29-May-2016.) -/
theorem mpjaodan {ph ps ch th : wff}
  (jaodan_1 : ⊦ wi (wa ph ps) ch)
  (jaodan_2 : ⊦ wi (wa ph th) ch)
  (jaodan_3 : ⊦ wi ph (wo ps th)) :
  ⊦ wi ph ch :=
@mpdan ph (wo ps th) ch
  jaodan_3
  (@jaodan ph ps ch th
    jaodan_1
    jaodan_2)


/-- Theorem *3.44 of [WhiteheadRussell] p. 113. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 3-Oct-2013.) -/
theorem pm3_44 {ph ps ch : wff} :
  ⊦ wi (wa (wi ps ph) (wi ch ph)) (wi (wo ps ch) ph) :=
@jaao (wi ps ph) ps ph (wi ch ph) ch
  (@id (wi ps ph))
  (@id (wi ch ph))


/-- Disjunction of antecedents. Compare Theorem *3.44 of [WhiteheadRussell] p. 113. (Contributed by
NM, 5-Apr-1994.) (Proof shortened by Wolf Lammen, 4-Apr-2013.) -/
theorem jao {ph ps ch : wff} :
  ⊦ wi (wi ph ps) (wi (wi ch ps) (wi (wo ph ch) ps)) :=
@ex (wi ph ps) (wi ch ps) (wi (wo ph ch) ps)
  (@pm3_44 ps ph ch)


/-- Disjunction of antecedents. Compare Theorem *4.77 of [WhiteheadRussell] p. 121. (Contributed by
NM, 30-May-1994.) (Proof shortened by Wolf Lammen, 9-Dec-2012.) -/
theorem jaob {ph ps ch : wff} :
  ⊦ wb (wi (wo ph ch) ps) (wa (wi ph ps) (wi ch ps)) :=
@impbii (wi (wo ph ch) ps) (wa (wi ph ps) (wi ch ps))
  (@jca (wi (wo ph ch) ps) (wi ph ps) (wi ch ps)
    (@pm2_67_2 ph ps ch)
    (@imim1i ch (wo ph ch) ps
      (@olc ch ph)))
  (@pm3_44 ps ph ch)


/-- Theorem *3.48 of [WhiteheadRussell] p. 114. (Contributed by NM, 28-Jan-1997.) -/
theorem pm3_48 {ph ps ch th : wff} :
  ⊦ wi (wa (wi ph ps) (wi ch th)) (wi (wo ph ch) (wo ps th)) :=
@jaao (wi ph ps) ph (wo ps th) (wi ch th) ch
  (@imim2i ps (wo ps th) ph
    (@orc ps th))
  (@imim2i th (wo ps th) ch
    (@olc th ps))


/-- Disjoin antecedents and consequents in a deduction. See ~ orim12dALT for a proof which does not
depend on ~ df-an . (Contributed by NM, 10-May-1994.) -/
theorem orim12d {ph ps ch th ta : wff}
  (orim12d_1 : ⊦ wi ph (wi ps ch))
  (orim12d_2 : ⊦ wi ph (wi th ta)) :
  ⊦ wi ph (wi (wo ps th) (wo ch ta)) :=
@syl2anc ph (wi ps ch) (wi th ta) (wi (wo ps th) (wo ch ta))
  orim12d_1
  orim12d_2
  (@pm3_48 ps ch th ta)


/-- Disjoin antecedents and consequents in a deduction. (Contributed by NM, 23-Apr-1995.) -/
theorem orim1d {ph ps ch th : wff}
  (orim1d_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wo ps th) (wo ch th)) :=
@orim12d ph ps ch th th
  orim1d_1
  (@idd ph th)


/-- Disjoin antecedents and consequents in a deduction. (Contributed by NM, 23-Apr-1995.) -/
theorem orim2d {ph ps ch th : wff}
  (orim1d_1 : ⊦ wi ph (wi ps ch)) :
  ⊦ wi ph (wi (wo th ps) (wo th ch)) :=
@orim12d ph th th ps ch
  (@idd ph th)
  orim1d_1


/-- Conjunction implies disjunction with one common formula (3/4). (Contributed by BJ, 4-Oct-2019.)
-/
theorem animorlr {ph ps ch : wff} :
  ⊦ wi (wa ph ps) (wo ch ph) :=
@olcd (wa ph ps) ph ch
  (@simpl ph ps)


/-- Negated conjunction in terms of disjunction (De Morgan's law). Theorem *4.51 of
[WhiteheadRussell] p. 120. (Contributed by NM, 14-May-1993.) (Proof shortened by Andrew Salmon,
13-May-2011.) -/
theorem ianor {ph ps : wff} :
  ⊦ wb (wn (wa ph ps)) (wo (wn ph) (wn ps)) :=
@bitr3i (wn (wa ph ps)) (wi ph (wn ps)) (wo (wn ph) (wn ps))
  (@imnan ph ps)
  (@pm4_62 ph ps)


/-- Conjunction in terms of disjunction (De Morgan's law). Theorem *4.5 of [WhiteheadRussell] p.
120. (Contributed by NM, 3-Jan-1993.) (Proof shortened by Wolf Lammen, 3-Nov-2012.) -/
theorem anor {ph ps : wff} :
  ⊦ wb (wa ph ps) (wn (wo (wn ph) (wn ps))) :=
@xchbinx (wa ph ps) (wn (wa ph ps)) (wo (wn ph) (wn ps))
  (@notnotb (wa ph ps))
  (@ianor ph ps)


/-- Negated disjunction in terms of conjunction (De Morgan's law). Compare Theorem *4.56 of
[WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-1993.) (Proof shortened by Andrew Salmon,
7-May-2011.) -/
theorem ioran {ph ps : wff} :
  ⊦ wb (wn (wo ph ps)) (wa (wn ph) (wn ps)) :=
@xchnxbi (wi (wn ph) ps) (wa (wn ph) (wn ps)) (wo ph ps)
  (@pm4_65 ph ps)
  (@pm4_64 ph ps)


/-- Theorem *4.52 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 5-Nov-2012.) -/
theorem pm4_52 {ph ps : wff} :
  ⊦ wb (wa ph (wn ps)) (wn (wo (wn ph) ps)) :=
@xchbinx (wa ph (wn ps)) (wi ph ps) (wo (wn ph) ps)
  (@annim ph ps)
  (@imor ph ps)


/-- Theorem *4.56 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_56 {ph ps : wff} :
  ⊦ wb (wa (wn ph) (wn ps)) (wn (wo ph ps)) :=
@bicomi (wn (wo ph ps)) (wa (wn ph) (wn ps))
  (@ioran ph ps)


/-- Disjunction in terms of conjunction (De Morgan's law). Compare Theorem *4.57 of
[WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-1993.) (Proof shortened by Andrew Salmon,
7-May-2011.) -/
theorem oran {ph ps : wff} :
  ⊦ wb (wo ph ps) (wn (wa (wn ph) (wn ps))) :=
@con2bii (wa (wn ph) (wn ps)) (wo ph ps)
  (@pm4_56 ph ps)


/-- Theorem *4.57 of [WhiteheadRussell] p. 120. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_57 {ph ps : wff} :
  ⊦ wb (wn (wa (wn ph) (wn ps))) (wo ph ps) :=
@bicomi (wo ph ps) (wn (wa (wn ph) (wn ps)))
  (@oran ph ps)


/-- Theorem *3.11 of [WhiteheadRussell] p. 111. (Contributed by NM, 3-Jan-2005.) -/
theorem pm3_11 {ph ps : wff} :
  ⊦ wi (wn (wo (wn ph) (wn ps))) (wa ph ps) :=
@biimpri (wa ph ps) (wn (wo (wn ph) (wn ps)))
  (@anor ph ps)


/-- Theorem *3.13 of [WhiteheadRussell] p. 111. (Contributed by NM, 3-Jan-2005.) -/
theorem pm3_13 {ph ps : wff} :
  ⊦ wi (wn (wa ph ps)) (wo (wn ph) (wn ps)) :=
@con1i (wo (wn ph) (wn ps)) (wa ph ps)
  (@pm3_11 ph ps)


/-- Theorem *5.61 of [WhiteheadRussell] p. 125. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 30-Jun-2013.) -/
theorem pm5_61 {ph ps : wff} :
  ⊦ wb (wa (wo ph ps) (wn ps)) (wa ph (wn ps)) :=
@pm5_32ri (wn ps) (wo ph ps) ph
  (@impbid1 (wn ps) (wo ph ps) ph
    (@orel2 ps ph)
    (@orc ph ps))


/-- Conjunction in antecedent versus disjunction in consequent. Theorem *5.6 of [WhiteheadRussell]
p. 125. (Contributed by NM, 8-Jun-1994.) -/
theorem pm5_6 {ph ps ch : wff} :
  ⊦ wb (wi (wa ph (wn ps)) ch) (wi ph (wo ps ch)) :=
@bitr4i (wi (wa ph (wn ps)) ch) (wi ph (wi (wn ps) ch)) (wi ph (wo ps ch))
  (@impexp ph (wn ps) ch)
  (@imbi2i (wo ps ch) (wi (wn ps) ch) ph
    (@df_or ps ch))


/-- Change disjunction in consequent to conjunction in antecedent. (Contributed by NM, 8-Jun-1994.)
-/
theorem orcanai {ph ps ch : wff}
  (orcanai_1 : ⊦ wi ph (wo ps ch)) :
  ⊦ wi (wa ph (wn ps)) ch :=
@imp ph (wn ps) ch
  (@ord ph ps ch
    orcanai_1)


/-- Distributive law for disjunction. Theorem *4.41 of [WhiteheadRussell] p. 119. (Contributed by
NM, 5-Jan-1993.) (Proof shortened by Andrew Salmon, 7-May-2011.) (Proof shortened by Wolf Lammen,
28-Nov-2013.) -/
theorem ordi {ph ps ch : wff} :
  ⊦ wb (wo ph (wa ps ch)) (wa (wo ph ps) (wo ph ch)) :=
@«3bitr4i» (wi (wn ph) (wa ps ch)) (wa (wi (wn ph) ps) (wi (wn ph) ch)) (wo ph (wa ps ch)) (wa (wo ph ps) (wo ph ch))
  (@jcab (wn ph) ps ch)
  (@df_or ph (wa ps ch))
  (@anbi12i (wo ph ps) (wi (wn ph) ps) (wo ph ch) (wi (wn ph) ch)
    (@df_or ph ps)
    (@df_or ph ch))


/-- Distributive law for disjunction. (Contributed by NM, 12-Aug-1994.) -/
theorem ordir {ph ps ch : wff} :
  ⊦ wb (wo (wa ph ps) ch) (wa (wo ph ch) (wo ps ch)) :=
@«3bitr4i» (wo ch (wa ph ps)) (wa (wo ch ph) (wo ch ps)) (wo (wa ph ps) ch) (wa (wo ph ch) (wo ps ch))
  (@ordi ch ph ps)
  (@orcom (wa ph ps) ch)
  (@anbi12i (wo ph ch) (wo ch ph) (wo ps ch) (wo ch ps)
    (@orcom ph ch)
    (@orcom ps ch))


/-- Distributive law for conjunction. Theorem *4.4 of [WhiteheadRussell] p. 118. (Contributed by NM,
21-Jun-1993.) (Proof shortened by Wolf Lammen, 5-Jan-2013.) -/
theorem andi {ph ps ch : wff} :
  ⊦ wb (wa ph (wo ps ch)) (wo (wa ph ps) (wa ph ch)) :=
@impbii (wa ph (wo ps ch)) (wo (wa ph ps) (wa ph ch))
  (@jaodan ph ps (wo (wa ph ps) (wa ph ch)) ch
    (@orc (wa ph ps) (wa ph ch))
    (@olc (wa ph ch) (wa ph ps)))
  (@jaoi (wa ph ps) (wa ph (wo ps ch)) (wa ph ch)
    (@anim2i ps (wo ps ch) ph
      (@orc ps ch))
    (@anim2i ch (wo ps ch) ph
      (@olc ch ps)))


/-- Distributive law for conjunction. (Contributed by NM, 12-Aug-1994.) -/
theorem andir {ph ps ch : wff} :
  ⊦ wb (wa (wo ph ps) ch) (wo (wa ph ch) (wa ps ch)) :=
@«3bitr4i» (wa ch (wo ph ps)) (wo (wa ch ph) (wa ch ps)) (wa (wo ph ps) ch) (wo (wa ph ch) (wa ps ch))
  (@andi ch ph ps)
  (@ancom (wo ph ps) ch)
  (@orbi12i (wa ph ch) (wa ch ph) (wa ps ch) (wa ch ps)
    (@ancom ph ch)
    (@ancom ps ch))


/-- Double distributive law for conjunction. (Contributed by NM, 12-Aug-1994.) -/
theorem anddi {ph ps ch th : wff} :
  ⊦ wb (wa (wo ph ps) (wo ch th)) (wo (wo (wa ph ch) (wa ph th)) (wo (wa ps ch) (wa ps th))) :=
@bitri (wa (wo ph ps) (wo ch th)) (wo (wa ph (wo ch th)) (wa ps (wo ch th))) (wo (wo (wa ph ch) (wa ph th)) (wo (wa ps ch) (wa ps th)))
  (@andir ph ps (wo ch th))
  (@orbi12i (wa ph (wo ch th)) (wo (wa ph ch) (wa ph th)) (wa ps (wo ch th)) (wo (wa ps ch) (wa ps th))
    (@andi ph ch th)
    (@andi ps ch th))


/-- Theorem *5.17 of [WhiteheadRussell] p. 124. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 3-Jan-2013.) -/
theorem pm5_17 {ph ps : wff} :
  ⊦ wb (wa (wo ph ps) (wn (wa ph ps))) (wb ph (wn ps)) :=
@«3bitrri» (wb ph (wn ps)) (wb (wn ps) ph) (wa (wi (wn ps) ph) (wi ph (wn ps))) (wa (wo ph ps) (wn (wa ph ps)))
  (@bicom ph (wn ps))
  (@dfbi2 (wn ps) ph)
  (@anbi12i (wi (wn ps) ph) (wo ph ps) (wi ph (wn ps)) (wn (wa ph ps))
    (@bitr2i (wo ph ps) (wo ps ph) (wi (wn ps) ph)
      (@orcom ph ps)
      (@df_or ps ph))
    (@imnan ph ps))


/-- Theorem *5.63 of [WhiteheadRussell] p. 125. (Contributed by NM, 3-Jan-2005.) (Proof shortened by
Wolf Lammen, 25-Dec-2012.) -/
theorem pm5_63 {ph ps : wff} :
  ⊦ wb (wo ph ps) (wo ph (wa (wn ph) ps)) :=
@bicomi (wo ph (wa (wn ph) ps)) (wo ph ps)
  (@mpbiran (wo ph (wa (wn ph) ps)) (wo ph (wn ph)) (wo ph ps)
    (@exmid ph)
    (@ordi ph (wn ph) ps))


/-- Theorem *4.83 of [WhiteheadRussell] p. 122. (Contributed by NM, 3-Jan-2005.) -/
theorem pm4_83 {ph ps : wff} :
  ⊦ wb (wa (wi ph ps) (wi (wn ph) ps)) ps :=
@bitr2i ps (wi (wo ph (wn ph)) ps) (wa (wi ph ps) (wi (wn ph) ps))
  (@a1bi (wo ph (wn ph)) ps
    (@exmid ph))
  (@jaob ph ps (wn ph))


/-- Negation inferred from embedded conjunct. (Contributed by NM, 20-Aug-1993.) (Proof shortened by
Wolf Lammen, 25-Nov-2012.) -/
theorem pclem6 {ph ps : wff} :
  ⊦ wi (wb ph (wa ps (wn ph))) (wn ps) :=
@con2i ps (wb ph (wa ps (wn ph)))
  (@sylib ps (wb (wn ph) (wa ps (wn ph))) (wn (wb ph (wa ps (wn ph))))
    (@ibar ps (wn ph))
    (@nbbn ph (wa ps (wn ph))))


/-- Deduction for elimination by cases. (Contributed by NM, 2-May-1996.) (Proof shortened by Andrew
Salmon, 7-May-2011.) -/
theorem ecase3d {ph ps ch th : wff}
  (ecase3d_1 : ⊦ wi ph (wi ps th))
  (ecase3d_2 : ⊦ wi ph (wi ch th))
  (ecase3d_3 : ⊦ wi ph (wi (wn (wo ps ch)) th)) :
  ⊦ wi ph th :=
@pm2_61d ph (wo ps ch) th
  (@jaod ph ps th ch
    ecase3d_1
    ecase3d_2)
  ecase3d_3


/-- Deduction for elimination by cases. (Contributed by NM, 8-Oct-2012.) -/
theorem ecased {ph ps ch th : wff}
  (ecased_1 : ⊦ wi ph (wi (wn ps) th))
  (ecased_2 : ⊦ wi ph (wi (wn ch) th))
  (ecased_3 : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi ph th :=
@ecase3d ph (wn ps) (wn ch) th
  ecased_1
  ecased_2
  (@syl5 (wn (wo (wn ps) (wn ch))) (wa ps ch) ph th
    (@pm3_11 ps ch)
    ecased_3)


/-- Inference for combining cases. (Contributed by NM, 29-Jul-1999.) (Proof shortened by Wolf
Lammen, 6-Jan-2013.) -/
theorem ccase {ph ps ch th ta : wff}
  (ccase_1 : ⊦ wi (wa ph ps) ta)
  (ccase_2 : ⊦ wi (wa ch ps) ta)
  (ccase_3 : ⊦ wi (wa ph th) ta)
  (ccase_4 : ⊦ wi (wa ch th) ta) :
  ⊦ wi (wa (wo ph ch) (wo ps th)) ta :=
@jaodan (wo ph ch) ps ta th
  (@jaoian ph ps ta ch
    ccase_1
    ccase_2)
  (@jaoian ph th ta ch
    ccase_3
    ccase_4)


/-- Deduction for combining cases. (Contributed by NM, 9-May-2004.) -/
theorem ccased {ph ps ch th ta et : wff}
  (ccased_1 : ⊦ wi ph (wi (wa ps ch) et))
  (ccased_2 : ⊦ wi ph (wi (wa th ch) et))
  (ccased_3 : ⊦ wi ph (wi (wa ps ta) et))
  (ccased_4 : ⊦ wi ph (wi (wa th ta) et)) :
  ⊦ wi ph (wi (wa (wo ps th) (wo ch ta)) et) :=
@com12 (wa (wo ps th) (wo ch ta)) ph et
  (@ccase ps ch th ta (wi ph et)
    (@com12 ph (wa ps ch) et
      ccased_1)
    (@com12 ph (wa th ch) et
      ccased_2)
    (@com12 ph (wa ps ta) et
      ccased_3)
    (@com12 ph (wa th ta) et
      ccased_4))


/-- Inference eliminating two antecedents from the four possible cases that result from their
true/false combinations. (Contributed by NM, 25-Oct-2003.) -/
theorem «4cases» {ph ps ch : wff}
  («4cases_1» : ⊦ wi (wa ph ps) ch)
  («4cases_2» : ⊦ wi (wa ph (wn ps)) ch)
  («4cases_3» : ⊦ wi (wa (wn ph) ps) ch)
  («4cases_4» : ⊦ wi (wa (wn ph) (wn ps)) ch) :
  ⊦ ch :=
@pm2_61i ps ch
  (@pm2_61ian ph ps ch
    «4cases_1»
    «4cases_3»)
  (@pm2_61ian ph (wn ps) ch
    «4cases_2»
    «4cases_4»)


/-- Case disjunction according to the value of ` ph ` . (Contributed by NM, 25-Apr-2019.) -/
theorem cases {ph ps ch th : wff}
  (cases_1 : ⊦ wi ph (wb ps ch))
  (cases_2 : ⊦ wi (wn ph) (wb ps th)) :
  ⊦ wb ps (wo (wa ph ch) (wa (wn ph) th)) :=
@«3bitri» ps (wa (wo ph (wn ph)) ps) (wo (wa ph ps) (wa (wn ph) ps)) (wo (wa ph ch) (wa (wn ph) th))
  (@biantrur (wo ph (wn ph)) ps
    (@exmid ph))
  (@andir ph (wn ph) ps)
  (@orbi12i (wa ph ps) (wa ph ch) (wa (wn ph) ps) (wa (wn ph) th)
    (@pm5_32i ph ps ch
      cases_1)
    (@pm5_32i (wn ph) ps th
      cases_2))


/-- Lemma for an alternate version of weak deduction theorem. (Contributed by NM, 2-Apr-1994.)
(Proof shortened by Andrew Salmon, 7-May-2011.) (Proof shortened by Wolf Lammen, 4-Dec-2012.) -/
theorem dedlem0a {ph ps ch : wff} :
  ⊦ wi ph (wb ps (wi (wi ch ph) (wa ps ph))) :=
@bitrd ph ps (wa ps ph) (wi (wi ch ph) (wa ps ph))
  (@iba ph ps)
  (@jarri ch ph (wb (wa ps ph) (wi (wi ch ph) (wa ps ph)))
    (@biimt (wi ch ph) (wa ps ph)))


/-- Lemma for weak deduction theorem. See also ~ ifptru . (Contributed by NM, 26-Jun-2002.) (Proof
shortened by Andrew Salmon, 7-May-2011.) -/
theorem dedlema {ph ps ch : wff} :
  ⊦ wi ph (wb ps (wo (wa ps ph) (wa ch (wn ph)))) :=
@impbid ph ps (wo (wa ps ph) (wa ch (wn ph)))
  (@expcom ps ph (wo (wa ps ph) (wa ch (wn ph)))
    (@orc (wa ps ph) (wa ch (wn ph))))
  (@jaod ph (wa ps ph) ps (wa ch (wn ph))
    (@a1i (wi (wa ps ph) ps) ph
      (@simpl ps ph))
    (@adantld ph (wn ph) ps ch
      (@pm2_24 ph ps)))


/-- Lemma for weak deduction theorem. See also ~ ifpfal . (Contributed by NM, 15-May-1999.) (Proof
shortened by Andrew Salmon, 7-May-2011.) -/
theorem dedlemb {ph ps ch : wff} :
  ⊦ wi (wn ph) (wb ch (wo (wa ps ph) (wa ch (wn ph)))) :=
@impbid (wn ph) ch (wo (wa ps ph) (wa ch (wn ph)))
  (@expcom ch (wn ph) (wo (wa ps ph) (wa ch (wn ph)))
    (@olc (wa ch (wn ph)) (wa ps ph)))
  (@jaod (wn ph) (wa ps ph) ch (wa ch (wn ph))
    (@adantld (wn ph) ph ch ps
      (@pm2_21 ph ch))
    (@a1i (wi (wa ch (wn ph)) ch) (wn ph)
      (@simpl ch (wn ph))))


/-- Case disjunction according to the value of ` ph ` . (Contributed by BJ, 6-Apr-2019.) (Proof
shortened by Wolf Lammen, 28-Feb-2022.) -/
theorem cases2 {ph ps ch : wff} :
  ⊦ wb (wo (wa ph ps) (wa (wn ph) ch)) (wa (wi ph ps) (wi (wn ph) ch)) :=
@«3bitr4ri» (wa (wi ph (wo (wa ps ph) (wa ch (wn ph)))) (wi (wn ph) (wo (wa ps ph) (wa ch (wn ph))))) (wo (wa ps ph) (wa ch (wn ph))) (wa (wi ph ps) (wi (wn ph) ch)) (wo (wa ph ps) (wa (wn ph) ch))
  (@pm4_83 ph (wo (wa ps ph) (wa ch (wn ph))))
  (@anbi12i (wi ph ps) (wi ph (wo (wa ps ph) (wa ch (wn ph)))) (wi (wn ph) ch) (wi (wn ph) (wo (wa ps ph) (wa ch (wn ph))))
    (@pm5_74i ph ps (wo (wa ps ph) (wa ch (wn ph)))
      (@dedlema ph ps ch))
    (@pm5_74i (wn ph) ch (wo (wa ps ph) (wa ch (wn ph)))
      (@dedlemb ph ps ch)))
  (@orbi12i (wa ph ps) (wa ps ph) (wa (wn ph) ch) (wa ch (wn ph))
    (@ancom ph ps)
    (@ancom (wn ph) ch))


/-- An alternate definition of the biconditional. Theorem *5.23 of [WhiteheadRussell] p. 124.
(Contributed by NM, 27-Jun-2002.) (Proof shortened by Wolf Lammen, 3-Nov-2013.) (Proof shortened by
NM, 29-Oct-2021.) -/
theorem dfbi3 {ph ps : wff} :
  ⊦ wb (wb ph ps) (wo (wa ph ps) (wa (wn ph) (wn ps))) :=
@«3bitr4i» (wa (wi ph ps) (wi ps ph)) (wa (wi ph ps) (wi (wn ph) (wn ps))) (wb ph ps) (wo (wa ph ps) (wa (wn ph) (wn ps)))
  (@anbi2i (wi ps ph) (wi (wn ph) (wn ps)) (wi ph ps)
    (@con34b ps ph))
  (@dfbi2 ph ps)
  (@cases2 ph ps (wn ps))


/-- Theorem *4.42 of [WhiteheadRussell] p. 119. See also ~ ifpid . (Contributed by Roy F. Longton,
21-Jun-2005.) -/
theorem pm4_42 {ph ps : wff} :
  ⊦ wb ph (wo (wa ph ps) (wa ph (wn ps))) :=
@pm2_61i ps (wb ph (wo (wa ph ps) (wa ph (wn ps))))
  (@dedlema ps ph ph)
  (@dedlemb ps ph ph)


/-- A specialized lemma for set theory (ordered pair theorem). (Contributed by NM, 18-Oct-1995.)
(Proof shortened by Wolf Lammen, 8-Dec-2012.) -/
theorem oplem1 {ph ps ch th ta : wff}
  (oplem1_1 : ⊦ wi ph (wo ps ch))
  (oplem1_2 : ⊦ wi ph (wo th ta))
  (oplem1_3 : ⊦ wb ps th)
  (oplem1_4 : ⊦ wi ch (wb th ta)) :
  ⊦ wi ph ps :=
@sylibr ph th ps
  (@pm2_18d ph th
    (@syl6 ph (wn th) (wa ch ta) th
      (@jcad ph (wn th) ch ta
        (@syl5bir (wn th) (wn ps) ph ch
          (@notbii ps th
            oplem1_3)
          (@ord ph ps ch
            oplem1_1))
        (@ord ph th ta
          oplem1_2))
      (@biimpar ch th ta
        oplem1_4)))
  oplem1_3


/-- A closed form of ~ mpbir , analogous to ~ pm2.27 (assertion). (Contributed by Jonathan Ben-Naim,
3-Jun-2011.) (Proof shortened by Roger Witte, 17-Aug-2020.) -/
theorem bianir {ph ps : wff} :
  ⊦ wi (wa ph (wb ps ph)) ps :=
@impcom (wb ps ph) ph ps
  (@biimpr ps ph)


-- /-- Extend wff notation to include the conditional operator for propositions. -/
-- constant wif : wff → wff → wff → wff


-- /-- Definition of the conditional operator for propositions. The expression ` if- ( ph , ps , ch
-- ) ` is read "if ` ph ` then ` ps ` else ` ch ` ". See ~ dfifp2 , ~ dfifp3 , ~ dfifp4 , ~ dfifp5 ,
-- ~ dfifp6 and ~ dfifp7 for alternate definitions. This definition (in the form of ~ dfifp2 )
-- appears in Section II.24 of [Church] p. 129 (Definition D12 page 132), where it is called
-- "conditioned disjunction". Church's ` [ ps , ph , ch ] ` corresponds to our ` if- ( ph , ps , ch
-- ) ` (note the permutation of the first two variables). This form was chosen as the definition
-- rather than ~ dfifp2 for compatibility with intuitionistic logic development: with this form, it
-- is clear that ` if- ( ph , ps , ch ) ` implies decidability of ` ph ` , which is most often what
-- is wanted. Church uses the conditional operator as an intermediate step to prove completeness of
-- some systems of connectives. The first result is that the system ` { if- , T. , F. } ` is
-- complete: for the induction step, consider a formula of n+1 variables; single out one variable,
-- say ` ph ` ; when one sets ` ph ` to True (resp. False), then what remains is a formula of n
-- variables, so by the induction hypothesis it is equivalent to a formula using only the
-- connectives ` if- , T. , F. ` , say ` ps ` (resp. ` ch ` ); therefore, the formula ` if- ( ph ,
-- ps , ch ) ` is equivalent to the initial formula of n+1 variables. Now, since ` { -> , -. } ` and
-- similar systems suffice to express the connectives ` if- , T. , F. ` , they are also complete.
-- (Contributed by BJ, 22-Jun-2019.) -/
-- axiom df_ifp {ph ps ch : wff} : ⊦ wb (wif ph ps ch) (wo (wa ph ps) (wa (wn ph) ch))


/-- Alternate definition of the conditional operator for propositions. The value of ` if- ( ph , ps
, ch ) ` is "if ` ph ` then ` ps ` , and if not ` ph ` then ` ch ` ". This is the definition used in
Section II.24 of [Church] p. 129 (Definition D12 page 132) (see comment of ~ df-ifp ). (Contributed
by BJ, 22-Jun-2019.) -/
theorem dfifp2 {ph ps ch : wff} :
  ⊦ wb (wif ph ps ch) (wa (wi ph ps) (wi (wn ph) ch)) :=
@bitri (wif ph ps ch) (wo (wa ph ps) (wa (wn ph) ch)) (wa (wi ph ps) (wi (wn ph) ch))
  (@df_ifp ph ps ch)
  (@cases2 ph ps ch)


/-- Alternate definition of the conditional operator for propositions. (Contributed by BJ,
30-Sep-2019.) -/
theorem dfifp3 {ph ps ch : wff} :
  ⊦ wb (wif ph ps ch) (wa (wi ph ps) (wo ph ch)) :=
@bitri (wif ph ps ch) (wa (wi ph ps) (wi (wn ph) ch)) (wa (wi ph ps) (wo ph ch))
  (@dfifp2 ph ps ch)
  (@anbi2i (wi (wn ph) ch) (wo ph ch) (wi ph ps)
    (@pm4_64 ph ch))


/-- Alternate definition of the conditional operator for propositions. (Contributed by BJ,
2-Oct-2019.) -/
theorem dfifp5 {ph ps ch : wff} :
  ⊦ wb (wif ph ps ch) (wa (wo (wn ph) ps) (wi (wn ph) ch)) :=
@bitri (wif ph ps ch) (wa (wi ph ps) (wi (wn ph) ch)) (wa (wo (wn ph) ps) (wi (wn ph) ch))
  (@dfifp2 ph ps ch)
  (@anbi1i (wi ph ps) (wo (wn ph) ps) (wi (wn ph) ch)
    (@imor ph ps))


/-- Conditional operator for the negation of a proposition. (Contributed by BJ, 30-Sep-2019.) (Proof
shortened by Wolf Lammen, 5-May-2024.) -/
theorem ifpn {ph ps ch : wff} :
  ⊦ wb (wif ph ps ch) (wif (wn ph) ch ps) :=
@«3bitr4i» (wa (wo (wn ph) ps) (wi (wn ph) ch)) (wa (wi (wn ph) ch) (wo (wn ph) ps)) (wif ph ps ch) (wif (wn ph) ch ps)
  (@ancom (wo (wn ph) ps) (wi (wn ph) ch))
  (@dfifp5 ph ps ch)
  (@dfifp3 (wn ph) ch ps)


/-- Value of the conditional operator for propositions when its first argument is true. Analogue for
propositions of ~ iftrue . This is essentially ~ dedlema . (Contributed by BJ, 20-Sep-2019.) (Proof
shortened by Wolf Lammen, 10-Jul-2020.) -/
theorem ifptru {ph ps ch : wff} :
  ⊦ wi ph (wb (wif ph ps ch) ps) :=
@bitr2d ph ps (wi ph ps) (wif ph ps ch)
  (@biimt ph ps)
  (@bitr4di ph (wi ph ps) (wa (wi ph ps) (wo ph ch)) (wif ph ps ch)
    (@biantrud ph (wo ph ch) (wi ph ps)
      (@orc ph ch))
    (@dfifp3 ph ps ch))


/-- Value of the conditional operator for propositions when its first argument is false. Analogue
for propositions of ~ iffalse . This is essentially ~ dedlemb . (Contributed by BJ, 20-Sep-2019.)
(Proof shortened by Wolf Lammen, 25-Jun-2020.) -/
theorem ifpfal {ph ps ch : wff} :
  ⊦ wi (wn ph) (wb (wif ph ps ch) ch) :=
@syl5bb (wif ph ps ch) (wif (wn ph) ch ps) (wn ph) ch
  (@ifpn ph ps ch)
  (@ifptru (wn ph) ch ps)


-- /-- Extend wff definition to include three-way disjunction ('or'). -/
-- constant w3o : wff → wff → wff → wff


-- /-- Extend wff definition to include three-way conjunction ('and'). -/
-- constant w3a : wff → wff → wff → wff


-- /-- Define disjunction ('or') of three wff's. Definition *2.33 of [WhiteheadRussell] p. 105. This
-- abbreviation reduces the number of parentheses and emphasizes that the order of bracketing is not
-- important by virtue of the associative law ~ orass . (Contributed by NM, 8-Apr-1994.) -/
-- axiom df_3or {ph ps ch : wff} : ⊦ wb (w3o ph ps ch) (wo (wo ph ps) ch)


-- /-- Define conjunction ('and') of three wff's. Definition *4.34 of [WhiteheadRussell] p. 118.
-- This abbreviation reduces the number of parentheses and emphasizes that the order of bracketing
-- is not important by virtue of the associative law ~ anass . (Contributed by NM, 8-Apr-1994.) -/
-- axiom df_3an {ph ps ch : wff} : ⊦ wb (w3a ph ps ch) (wa (wa ph ps) ch)


/-- Associative law for triple disjunction. (Contributed by NM, 8-Apr-1994.) -/
theorem «3orass» {ph ps ch : wff} :
  ⊦ wb (w3o ph ps ch) (wo ph (wo ps ch)) :=
@bitri (w3o ph ps ch) (wo (wo ph ps) ch) (wo ph (wo ps ch))
  (@df_3or ph ps ch)
  (@orass ph ps ch)


/-- Rotation law for triple disjunction. (Contributed by NM, 4-Apr-1995.) -/
theorem «3orrot» {ph ps ch : wff} :
  ⊦ wb (w3o ph ps ch) (w3o ps ch ph) :=
@«3bitr4i» (wo ph (wo ps ch)) (wo (wo ps ch) ph) (w3o ph ps ch) (w3o ps ch ph)
  (@orcom ph (wo ps ch))
  (@«3orass» ph ps ch)
  (@df_3or ps ch ph)


/-- Associative law for triple conjunction. (Contributed by NM, 8-Apr-1994.) -/
theorem «3anass» {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (wa ph (wa ps ch)) :=
@bitri (w3a ph ps ch) (wa (wa ph ps) ch) (wa ph (wa ps ch))
  (@df_3an ph ps ch)
  (@anass ph ps ch)


/-- Convert triple conjunction to conjunction, then commute. (Contributed by Jonathan Ben-Naim,
3-Jun-2011.) (Proof shortened by Andrew Salmon, 14-Jun-2011.) (Revised to shorten ~ 3ancoma by Wolf
Lammen, 5-Jun-2022.) -/
theorem «3anan12» {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (wa ps (wa ph ch)) :=
@bitri (w3a ph ps ch) (wa ph (wa ps ch)) (wa ps (wa ph ch))
  (@«3anass» ph ps ch)
  (@an12 ph ps ch)


/-- Convert triple conjunction to conjunction, then commute. (Contributed by Jonathan Ben-Naim,
3-Jun-2011.) -/
theorem «3anan32» {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (wa (wa ph ch) ps) :=
@bitri (w3a ph ps ch) (wa (wa ph ps) ch) (wa (wa ph ch) ps)
  (@df_3an ph ps ch)
  (@an32 ph ps ch)


/-- Commutation law for triple conjunction. (Contributed by NM, 21-Apr-1994.) (Proof shortened by
Wolf Lammen, 5-Jun-2022.) -/
theorem «3ancoma» {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (w3a ps ph ch) :=
@bitr4i (w3a ph ps ch) (wa ps (wa ph ch)) (w3a ps ph ch)
  (@«3anan12» ph ps ch)
  (@«3anass» ps ph ch)


/-- Commutation law for triple conjunction. (Contributed by NM, 21-Apr-1994.) (Revised to shorten ~
3anrot by Wolf Lammen, 9-Jun-2022.) -/
theorem «3ancomb» {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (w3a ph ch ps) :=
@bitr4i (w3a ph ps ch) (wa (wa ph ps) ch) (w3a ph ch ps)
  (@df_3an ph ps ch)
  (@«3anan32» ph ch ps)


/-- Rotation law for triple conjunction. (Contributed by NM, 8-Apr-1994.) (Proof shortened by Wolf
Lammen, 9-Jun-2022.) -/
theorem «3anrot» {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (w3a ps ch ph) :=
@bitri (w3a ph ps ch) (w3a ps ph ch) (w3a ps ch ph)
  (@«3ancoma» ph ps ch)
  (@«3ancomb» ps ph ch)


/-- Reversal law for triple conjunction. (Contributed by NM, 21-Apr-1994.) -/
theorem «3anrev» {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (w3a ch ps ph) :=
@bitr4i (w3a ph ps ch) (w3a ps ph ch) (w3a ch ps ph)
  (@«3ancoma» ph ps ch)
  (@«3anrot» ch ps ph)


/-- Distribution of triple conjunction over conjunction. (Contributed by David A. Wheeler,
4-Nov-2018.) -/
theorem anandi3 {ph ps ch : wff} :
  ⊦ wb (w3a ph ps ch) (wa (wa ph ps) (wa ph ch)) :=
@bitri (w3a ph ps ch) (wa ph (wa ps ch)) (wa (wa ph ps) (wa ph ch))
  (@«3anass» ph ps ch)
  (@anandi ph ps ch)


/-- Negated triple conjunction expressed in terms of triple disjunction. (Contributed by Jeff
Hankins, 15-Aug-2009.) (Proof shortened by Andrew Salmon, 13-May-2011.) (Revised by Wolf Lammen,
8-Apr-2022.) -/
theorem «3ianor» {ph ps ch : wff} :
  ⊦ wb (wn (w3a ph ps ch)) (w3o (wn ph) (wn ps) (wn ch)) :=
@«3bitr4i» (wo (wn (wa ph ps)) (wn ch)) (wo (wo (wn ph) (wn ps)) (wn ch)) (wn (w3a ph ps ch)) (w3o (wn ph) (wn ps) (wn ch))
  (@orbi1i (wn (wa ph ps)) (wo (wn ph) (wn ps)) (wn ch)
    (@ianor ph ps))
  (@xchnxbir (wa (wa ph ps) ch) (wo (wn (wa ph ps)) (wn ch)) (w3a ph ps ch)
    (@ianor (wa ph ps) ch)
    (@df_3an ph ps ch))
  (@df_3or (wn ph) (wn ps) (wn ch))


/-- Importation from double to triple conjunction. (Contributed by NM, 20-Aug-1995.) (Revised to
shorten ~ 3imp by Wolf Lammen, 20-Jun-2022.) -/
theorem «3impa» {ph ps ch th : wff}
  («3impa_1» : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (w3a ph ps ch) th :=
@sylbi (w3a ph ps ch) (wa (wa ph ps) ch) th
  (@df_3an ph ps ch)
  «3impa_1»


/-- Importation inference. (Contributed by NM, 8-Apr-1994.) (Proof shortened by Wolf Lammen,
20-Jun-2022.) -/
theorem «3imp» {ph ps ch th : wff}
  («3imp_1» : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi (w3a ph ps ch) th :=
@«3impa» ph ps ch th
  (@imp31 ph ps ch th
    «3imp_1»)


/-- The importation inference ~ 3imp with commutation of the first and third conjuncts of the
assertion relative to the hypothesis. (Contributed by Alan Sare, 11-Sep-2016.) -/
theorem «3imp31» {ph ps ch th : wff}
  («3imp_1» : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi (w3a ch ps ph) th :=
@«3imp» ch ps ph th
  (@com13 ph ps ch th
    «3imp_1»)


/-- Importation inference. (Contributed by Alan Sare, 17-Oct-2017.) -/
theorem «3imp231» {ph ps ch th : wff}
  («3imp_1» : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi (w3a ps ch ph) th :=
@«3imp» ps ch ph th
  (@com3l ph ps ch th
    «3imp_1»)


/-- The importation inference ~ 3imp with commutation of the first and second conjuncts of the
assertion relative to the hypothesis. (Contributed by Alan Sare, 11-Sep-2016.) (Revised to shorten ~
3com12 by Wolf Lammen, 23-Jun-2022.) -/
theorem «3imp21» {ph ps ch th : wff}
  («3imp_1» : ⊦ wi ph (wi ps (wi ch th))) :
  ⊦ wi (w3a ps ph ch) th :=
@«3imp231» ch ps ph th
  (@com13 ph ps ch th
    «3imp_1»)


/-- Importation from double to triple conjunction. (Contributed by NM, 20-Aug-1995.) -/
theorem «3impb» {ph ps ch th : wff}
  («3impb_1» : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (w3a ph ps ch) th :=
@«3imp» ph ps ch th
  (@exp32 ph ps ch th
    «3impb_1»)


/-- Importation to triple conjunction. (Contributed by NM, 13-Jun-2006.) -/
theorem «3impib» {ph ps ch th : wff}
  («3impib_1» : ⊦ wi ph (wi (wa ps ch) th)) :
  ⊦ wi (w3a ph ps ch) th :=
@«3imp» ph ps ch th
  (@expd ph ps ch th
    «3impib_1»)


/-- Importation to triple conjunction. (Contributed by NM, 13-Jun-2006.) (Proof shortened by Wolf
Lammen, 21-Jun-2022.) -/
theorem «3impia» {ph ps ch th : wff}
  («3impia_1» : ⊦ wi (wa ph ps) (wi ch th)) :
  ⊦ wi (w3a ph ps ch) th :=
@«3impib» ph ps ch th
  (@expimpd ph ps ch th
    «3impia_1»)


/-- Exportation from triple to double conjunction. (Contributed by NM, 20-Aug-1995.) (Revised to
shorten ~ 3exp and ~ pm3.2an3 by Wolf Lammen, 22-Jun-2022.) -/
theorem «3expa» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa (wa ph ps) ch) th :=
@sylbir (wa (wa ph ps) ch) (w3a ph ps ch) th
  (@df_3an ph ps ch)
  «3exp_1»


/-- Exportation inference. (Contributed by NM, 30-May-1994.) (Proof shortened by Wolf Lammen,
22-Jun-2022.) -/
theorem «3exp» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi ph (wi ps (wi ch th)) :=
@exp31 ph ps ch th
  (@«3expa» ph ps ch th
    «3exp_1»)


/-- Exportation from triple to double conjunction. (Contributed by NM, 20-Aug-1995.) -/
theorem «3expb» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph (wa ps ch)) th :=
@imp32 ph ps ch th
  (@«3exp» ph ps ch th
    «3exp_1»)


/-- Exportation from triple conjunction. (Contributed by NM, 19-May-2007.) (Proof shortened by Wolf
Lammen, 22-Jun-2022.) -/
theorem «3expia» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph ps) (wi ch th) :=
@expr ph ps ch th
  (@«3expb» ph ps ch th
    «3exp_1»)


/-- Exportation from triple conjunction. (Contributed by NM, 19-May-2007.) -/
theorem «3expib» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi ph (wi (wa ps ch) th) :=
@impd ph ps ch th
  (@«3exp» ph ps ch th
    «3exp_1»)


/-- Commutation in antecedent. Swap 1st and 2nd. (Contributed by NM, 28-Jan-1996.) (Proof shortened
by Andrew Salmon, 13-May-2011.) (Proof shortened by Wolf Lammen, 22-Jun-2022.) -/
theorem «3com12» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ps ph ch) th :=
@«3imp21» ph ps ch th
  (@«3exp» ph ps ch th
    «3exp_1»)


/-- Commutation in antecedent. Swap 1st and 3rd. (Contributed by NM, 28-Jan-1996.) (Proof shortened
by Wolf Lammen, 22-Jun-2022.) -/
theorem «3com13» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ch ps ph) th :=
@«3imp31» ph ps ch th
  (@«3exp» ph ps ch th
    «3exp_1»)


/-- Commutation in antecedent. Rotate right. (Contributed by NM, 28-Jan-1996.) (Revised by Wolf
Lammen, 9-Apr-2022.) -/
theorem «3comr» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ch ph ps) th :=
@«3com13» ps ph ch th
  (@«3com12» ph ps ch th
    «3exp_1»)


/-- Commutation in antecedent. Swap 2nd and 3rd. (Contributed by NM, 28-Jan-1996.) (Proof shortened
by Wolf Lammen, 9-Apr-2022.) -/
theorem «3com23» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ph ch ps) th :=
@«3com12» ch ph ps th
  (@«3comr» ph ps ch th
    «3exp_1»)


/-- Commutation in antecedent. Rotate left. (Contributed by NM, 28-Jan-1996.) -/
theorem «3coml» {ph ps ch th : wff}
  («3exp_1» : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ps ch ph) th :=
@«3com13» ph ch ps th
  (@«3com23» ph ps ch th
    «3exp_1»)


/-- Join consequents with conjunction. (Contributed by NM, 9-Apr-1994.) -/
theorem «3jca» {ph ps ch th : wff}
  («3jca_1» : ⊦ wi ph ps)
  («3jca_2» : ⊦ wi ph ch)
  («3jca_3» : ⊦ wi ph th) :
  ⊦ wi ph (w3a ps ch th) :=
@sylibr ph (wa (wa ps ch) th) (w3a ps ch th)
  (@jca31 ph ps ch th
    «3jca_1»
    «3jca_2»
    «3jca_3»)
  (@df_3an ps ch th)


/-- Deduction conjoining the consequents of three implications. (Contributed by NM, 25-Sep-2005.) -/
theorem «3jcad» {ph ps ch th ta : wff}
  («3jcad_1» : ⊦ wi ph (wi ps ch))
  («3jcad_2» : ⊦ wi ph (wi ps th))
  («3jcad_3» : ⊦ wi ph (wi ps ta)) :
  ⊦ wi ph (wi ps (w3a ch th ta)) :=
@ex ph ps (w3a ch th ta)
  (@«3jca» (wa ph ps) ch th ta
    (@imp ph ps ch
      «3jcad_1»)
    (@imp ph ps th
      «3jcad_2»)
    (@imp ph ps ta
      «3jcad_3»))


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 16-Jul-1995.) (Proof shortened by
Wolf Lammen, 21-Jun-2022.) -/
theorem «3adant1» {ph ps ch th : wff}
  («3adant_1» : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (w3a th ph ps) ch :=
@«3impa» th ph ps ch
  (@adantll ph ps ch th
    «3adant_1»)


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 16-Jul-1995.) -/
theorem «3adant2» {ph ps ch th : wff}
  («3adant_1» : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (w3a ph th ps) ch :=
@«3impa» ph th ps ch
  (@adantlr ph ps ch th
    «3adant_1»)


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 16-Jul-1995.) (Proof shortened by
Wolf Lammen, 21-Jun-2022.) -/
theorem «3adant3» {ph ps ch th : wff}
  («3adant_1» : ⊦ wi (wa ph ps) ch) :
  ⊦ wi (w3a ph ps th) ch :=
@«3impb» ph ps th ch
  (@adantrr ph ps ch th
    «3adant_1»)


/-- Deduction adding conjuncts to an antecedent. (Contributed by NM, 21-Apr-2005.) -/
theorem «3ad2ant1» {ph ps ch th : wff}
  («3ad2ant_1» : ⊦ wi ph ch) :
  ⊦ wi (w3a ph ps th) ch :=
@«3adant2» ph th ch ps
  (@adantr ph ch th
    «3ad2ant_1»)


/-- Deduction adding conjuncts to an antecedent. (Contributed by NM, 21-Apr-2005.) -/
theorem «3ad2ant2» {ph ps ch th : wff}
  («3ad2ant_1» : ⊦ wi ph ch) :
  ⊦ wi (w3a ps ph th) ch :=
@«3adant1» ph th ch ps
  (@adantr ph ch th
    «3ad2ant_1»)


/-- Deduction adding conjuncts to an antecedent. (Contributed by NM, 21-Apr-2005.) -/
theorem «3ad2ant3» {ph ps ch th : wff}
  («3ad2ant_1» : ⊦ wi ph ch) :
  ⊦ wi (w3a ps th ph) ch :=
@«3adant1» th ph ch ps
  (@adantl ph ch th
    «3ad2ant_1»)


/-- Simplification of triple conjunction. (Contributed by NM, 21-Apr-1994.) (Proof shortened by Wolf
Lammen, 22-Jun-2022.) -/
theorem simp1 {ph ps ch : wff} :
  ⊦ wi (w3a ph ps ch) ph :=
@«3ad2ant1» ph ps ph ch
  (@id ph)


/-- Simplification of triple conjunction. (Contributed by NM, 21-Apr-1994.) (Proof shortened by Wolf
Lammen, 22-Jun-2022.) -/
theorem simp2 {ph ps ch : wff} :
  ⊦ wi (w3a ph ps ch) ps :=
@«3ad2ant2» ps ph ps ch
  (@id ps)


/-- Simplification of triple conjunction. (Contributed by NM, 21-Apr-1994.) (Proof shortened by Wolf
Lammen, 22-Jun-2022.) -/
theorem simp3 {ph ps ch : wff} :
  ⊦ wi (w3a ph ps ch) ch :=
@«3ad2ant3» ch ph ch ps
  (@id ch)


/-- Infer a conjunct from a triple conjunction. (Contributed by NM, 19-Apr-2005.) -/
theorem simp1i {ph ps ch : wff}
  («3simp1i_1» : ⊦ w3a ph ps ch) :
  ⊦ ph :=
@ax_mp (w3a ph ps ch) ph
  «3simp1i_1»
  (@simp1 ph ps ch)


/-- Infer a conjunct from a triple conjunction. (Contributed by NM, 19-Apr-2005.) -/
theorem simp2i {ph ps ch : wff}
  («3simp1i_1» : ⊦ w3a ph ps ch) :
  ⊦ ps :=
@ax_mp (w3a ph ps ch) ps
  «3simp1i_1»
  (@simp2 ph ps ch)


/-- Infer a conjunct from a triple conjunction. (Contributed by NM, 19-Apr-2005.) -/
theorem simp3i {ph ps ch : wff}
  («3simp1i_1» : ⊦ w3a ph ps ch) :
  ⊦ ch :=
@ax_mp (w3a ph ps ch) ch
  «3simp1i_1»
  (@simp3 ph ps ch)


/-- Deduce a conjunct from a triple conjunction. (Contributed by NM, 4-Sep-2005.) -/
theorem simp1d {ph ps ch th : wff}
  («3simp1d_1» : ⊦ wi ph (w3a ps ch th)) :
  ⊦ wi ph ps :=
@syl ph (w3a ps ch th) ps
  «3simp1d_1»
  (@simp1 ps ch th)


/-- Deduce a conjunct from a triple conjunction. (Contributed by NM, 4-Sep-2005.) -/
theorem simp2d {ph ps ch th : wff}
  («3simp1d_1» : ⊦ wi ph (w3a ps ch th)) :
  ⊦ wi ph ch :=
@syl ph (w3a ps ch th) ch
  «3simp1d_1»
  (@simp2 ps ch th)


/-- Deduce a conjunct from a triple conjunction. (Contributed by NM, 4-Sep-2005.) -/
theorem simp3d {ph ps ch th : wff}
  («3simp1d_1» : ⊦ wi ph (w3a ps ch th)) :
  ⊦ wi ph th :=
@syl ph (w3a ps ch th) th
  «3simp1d_1»
  (@simp3 ps ch th)


/-- Deduce a conjunct from a triple conjunction. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem simp1bi {ph ps ch th : wff}
  («3simp1bi_1» : ⊦ wb ph (w3a ps ch th)) :
  ⊦ wi ph ps :=
@simp1d ph ps ch th
  (@biimpi ph (w3a ps ch th)
    «3simp1bi_1»)


/-- Deduce a conjunct from a triple conjunction. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem simp2bi {ph ps ch th : wff}
  («3simp1bi_1» : ⊦ wb ph (w3a ps ch th)) :
  ⊦ wi ph ch :=
@simp2d ph ps ch th
  (@biimpi ph (w3a ps ch th)
    «3simp1bi_1»)


/-- Deduce a conjunct from a triple conjunction. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem simp3bi {ph ps ch th : wff}
  («3simp1bi_1» : ⊦ wb ph (w3a ps ch th)) :
  ⊦ wi ph th :=
@simp3d ph ps ch th
  (@biimpi ph (w3a ps ch th)
    «3simp1bi_1»)


/-- Simplification of triple conjunction. (Contributed by NM, 21-Apr-1994.) (Proof shortened by Wolf
Lammen, 21-Jun-2022.) -/
theorem «3simpa» {ph ps ch : wff} :
  ⊦ wi (w3a ph ps ch) (wa ph ps) :=
@«3adant3» ph ps (wa ph ps) ch
  (@id (wa ph ps))


/-- Simplification of triple conjunction. (Contributed by NM, 21-Apr-1994.) (Proof shortened by Wolf
Lammen, 21-Jun-2022.) -/
theorem «3simpb» {ph ps ch : wff} :
  ⊦ wi (w3a ph ps ch) (wa ph ch) :=
@«3adant2» ph ch (wa ph ch) ps
  (@id (wa ph ch))


/-- Simplification of triple conjunction. (Contributed by NM, 21-Apr-1994.) (Proof shortened by
Andrew Salmon, 13-May-2011.) (Proof shortened by Wolf Lammen, 21-Jun-2022.) -/
theorem «3simpc» {ph ps ch : wff} :
  ⊦ wi (w3a ph ps ch) (wa ps ch) :=
@«3adant1» ps ch (wa ps ch) ph
  (@id (wa ps ch))


/-- Join antecedents and consequents with conjunction. (Contributed by NM, 8-Apr-1994.) -/
theorem «3anim123i» {ph ps ch th ta et : wff}
  («3anim123i_1» : ⊦ wi ph ps)
  («3anim123i_2» : ⊦ wi ch th)
  («3anim123i_3» : ⊦ wi ta et) :
  ⊦ wi (w3a ph ch ta) (w3a ps th et) :=
@«3jca» (w3a ph ch ta) ps th et
  (@«3ad2ant1» ph ch ps ta
    «3anim123i_1»)
  (@«3ad2ant2» ch ph th ta
    «3anim123i_2»)
  (@«3ad2ant3» ta ph et ch
    «3anim123i_3»)


/-- Add two conjuncts to antecedent and consequent. (Contributed by Jeff Hankins, 16-Aug-2009.) -/
theorem «3anim1i» {ph ps ch th : wff}
  («3animi_1» : ⊦ wi ph ps) :
  ⊦ wi (w3a ph ch th) (w3a ps ch th) :=
@«3anim123i» ph ps ch ch th th
  «3animi_1»
  (@id ch)
  (@id th)


/-- Add two conjuncts to antecedent and consequent. (Contributed by AV, 21-Nov-2019.) -/
theorem «3anim2i» {ph ps ch th : wff}
  («3animi_1» : ⊦ wi ph ps) :
  ⊦ wi (w3a ch ph th) (w3a ch ps th) :=
@«3anim123i» ch ch ph ps th th
  (@id ch)
  «3animi_1»
  (@id th)


/-- Add two conjuncts to antecedent and consequent. (Contributed by Jeff Hankins, 19-Aug-2009.) -/
theorem «3anim3i» {ph ps ch th : wff}
  («3animi_1» : ⊦ wi ph ps) :
  ⊦ wi (w3a ch th ph) (w3a ch th ps) :=
@«3anim123i» ch ch th th ph ps
  (@id ch)
  (@id th)
  «3animi_1»


/-- Join 3 biconditionals with conjunction. (Contributed by NM, 21-Apr-1994.) -/
theorem «3anbi123i» {ph ps ch th ta et : wff}
  (bi3_1 : ⊦ wb ph ps)
  (bi3_2 : ⊦ wb ch th)
  (bi3_3 : ⊦ wb ta et) :
  ⊦ wb (w3a ph ch ta) (w3a ps th et) :=
@«3bitr4i» (wa (wa ph ch) ta) (wa (wa ps th) et) (w3a ph ch ta) (w3a ps th et)
  (@anbi12i (wa ph ch) (wa ps th) ta et
    (@anbi12i ph ps ch th
      bi3_1
      bi3_2)
    bi3_3)
  (@df_3an ph ch ta)
  (@df_3an ps th et)


/-- Join 3 biconditionals with disjunction. (Contributed by NM, 17-May-1994.) -/
theorem «3orbi123i» {ph ps ch th ta et : wff}
  (bi3_1 : ⊦ wb ph ps)
  (bi3_2 : ⊦ wb ch th)
  (bi3_3 : ⊦ wb ta et) :
  ⊦ wb (w3o ph ch ta) (w3o ps th et) :=
@«3bitr4i» (wo (wo ph ch) ta) (wo (wo ps th) et) (w3o ph ch ta) (w3o ps th et)
  (@orbi12i (wo ph ch) (wo ps th) ta et
    (@orbi12i ph ps ch th
      bi3_1
      bi3_2)
    bi3_3)
  (@df_3or ph ch ta)
  (@df_3or ps th et)


/-- Inference adding two conjuncts to each side of a biconditional. (Contributed by NM, 8-Sep-2006.)
-/
theorem «3anbi1i» {ph ps ch th : wff}
  («3anbi1i_1» : ⊦ wb ph ps) :
  ⊦ wb (w3a ph ch th) (w3a ps ch th) :=
@«3anbi123i» ph ps ch ch th th
  «3anbi1i_1»
  (@biid ch)
  (@biid th)


/-- Inference adding two conjuncts to each side of a biconditional. (Contributed by NM, 8-Sep-2006.)
-/
theorem «3anbi3i» {ph ps ch th : wff}
  («3anbi1i_1» : ⊦ wb ph ps) :
  ⊦ wb (w3a ch th ph) (w3a ch th ps) :=
@«3anbi123i» ch ch th th ph ps
  (@biid ch)
  (@biid th)
  «3anbi1i_1»


/-- A triple syllogism inference. (Contributed by NM, 13-May-2004.) -/
theorem syl3an {ph ps ch th ta et ze : wff}
  (syl3an_1 : ⊦ wi ph ps)
  (syl3an_2 : ⊦ wi ch th)
  (syl3an_3 : ⊦ wi ta et)
  (syl3an_4 : ⊦ wi (w3a ps th et) ze) :
  ⊦ wi (w3a ph ch ta) ze :=
@syl (w3a ph ch ta) (w3a ps th et) ze
  (@«3anim123i» ph ps ch th ta et
    syl3an_1
    syl3an_2
    syl3an_3)
  syl3an_4


/-- A triple syllogism inference. (Contributed by NM, 15-Oct-2005.) -/
theorem syl3anb {ph ps ch th ta et ze : wff}
  (syl3anb_1 : ⊦ wb ph ps)
  (syl3anb_2 : ⊦ wb ch th)
  (syl3anb_3 : ⊦ wb ta et)
  (syl3anb_4 : ⊦ wi (w3a ps th et) ze) :
  ⊦ wi (w3a ph ch ta) ze :=
@sylbi (w3a ph ch ta) (w3a ps th et) ze
  (@«3anbi123i» ph ps ch th ta et
    syl3anb_1
    syl3anb_2
    syl3anb_3)
  syl3anb_4


/-- A syllogism inference. (Contributed by NM, 22-Aug-1995.) -/
theorem syl3an1 {ph ps ch th ta : wff}
  (syl3an1_1 : ⊦ wi ph ps)
  (syl3an1_2 : ⊦ wi (w3a ps ch th) ta) :
  ⊦ wi (w3a ph ch th) ta :=
@syl (w3a ph ch th) (w3a ps ch th) ta
  (@«3anim1i» ph ps ch th
    syl3an1_1)
  syl3an1_2


/-- A syllogism inference. (Contributed by NM, 22-Aug-1995.) (Proof shortened by Wolf Lammen,
26-Jun-2022.) -/
theorem syl3an2 {ph ps ch th ta : wff}
  (syl3an2_1 : ⊦ wi ph ch)
  (syl3an2_2 : ⊦ wi (w3a ps ch th) ta) :
  ⊦ wi (w3a ps ph th) ta :=
@syl (w3a ps ph th) (w3a ps ch th) ta
  (@«3anim2i» ph ch ps th
    syl3an2_1)
  syl3an2_2


/-- A syllogism inference. (Contributed by NM, 22-Aug-1995.) (Proof shortened by Wolf Lammen,
26-Jun-2022.) -/
theorem syl3an3 {ph ps ch th ta : wff}
  (syl3an3_1 : ⊦ wi ph th)
  (syl3an3_2 : ⊦ wi (w3a ps ch th) ta) :
  ⊦ wi (w3a ps ch ph) ta :=
@syl (w3a ps ch ph) (w3a ps ch th) ta
  (@«3anim3i» ph th ps ch
    syl3an3_1)
  syl3an3_2


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 24-Feb-2005.) -/
theorem «3adantl1» {ph ps ch th ta : wff}
  («3adantl_1» : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (w3a ta ph ps) ch) th :=
@sylan (w3a ta ph ps) (wa ph ps) ch th
  (@«3simpc» ta ph ps)
  «3adantl_1»


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 24-Feb-2005.) -/
theorem «3adantl2» {ph ps ch th ta : wff}
  («3adantl_1» : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (w3a ph ta ps) ch) th :=
@sylan (w3a ph ta ps) (wa ph ps) ch th
  (@«3simpb» ph ta ps)
  «3adantl_1»


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 24-Feb-2005.) -/
theorem «3adantl3» {ph ps ch th ta : wff}
  («3adantl_1» : ⊦ wi (wa (wa ph ps) ch) th) :
  ⊦ wi (wa (w3a ph ps ta) ch) th :=
@sylan (w3a ph ps ta) (wa ph ps) ch th
  (@«3simpa» ph ps ta)
  «3adantl_1»


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 27-Apr-2005.) -/
theorem «3adantr1» {ph ps ch th ta : wff}
  («3adantr_1» : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (w3a ta ps ch)) th :=
@sylan2 (w3a ta ps ch) ph (wa ps ch) th
  (@«3simpc» ta ps ch)
  «3adantr_1»


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 27-Apr-2005.) -/
theorem «3adantr2» {ph ps ch th ta : wff}
  («3adantr_1» : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (w3a ps ta ch)) th :=
@sylan2 (w3a ps ta ch) ph (wa ps ch) th
  (@«3simpb» ps ta ch)
  «3adantr_1»


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 27-Apr-2005.) -/
theorem «3adantr3» {ph ps ch th ta : wff}
  («3adantr_1» : ⊦ wi (wa ph (wa ps ch)) th) :
  ⊦ wi (wa ph (w3a ps ch ta)) th :=
@sylan2 (w3a ps ch ta) ph (wa ps ch) th
  (@«3simpa» ps ch ta)
  «3adantr_1»


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad4ant124 {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa (wa (wa ph ps) ta) ch) th :=
@adantlr (wa ph ps) ch th ta
  (@«3expa» ph ps ch th
    ad4ant3_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad4ant134 {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa (wa (wa ph ta) ps) ch) th :=
@adantllr ph ps ch th ta
  (@«3expa» ph ps ch th
    ad4ant3_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by Alan Sare, 17-Oct-2017.) (Proof
shortened by Wolf Lammen, 14-Apr-2022.) -/
theorem ad4ant234 {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa (wa (wa ta ph) ps) ch) th :=
@adantlll ph ps ch th ta
  (@«3expa» ph ps ch th
    ad4ant3_1)


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 8-Jan-2006.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem «3adant1l» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a (wa ta ph) ps ch) th :=
@syl3an1 (wa ta ph) ph ps ch th
  (@simpr ta ph)
  ad4ant3_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 8-Jan-2006.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem «3adant1r» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a (wa ph ta) ps ch) th :=
@syl3an1 (wa ph ta) ph ps ch th
  (@simpl ph ta)
  ad4ant3_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 8-Jan-2006.) (Proof shortened by
Wolf Lammen, 25-Jun-2022.) -/
theorem «3adant2r» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ph (wa ps ta) ch) th :=
@syl3an2 (wa ps ta) ph ps ch th
  (@simpl ps ta)
  ad4ant3_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 8-Jan-2006.) (Proof shortened by
Wolf Lammen, 25-Jun-2022.) -/
theorem «3adant3l» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ph ps (wa ta ch)) th :=
@syl3an3 (wa ta ch) ph ps ch th
  (@simpr ta ch)
  ad4ant3_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 8-Jan-2006.) (Proof shortened by
Wolf Lammen, 25-Jun-2022.) -/
theorem «3adant3r» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (w3a ph ps (wa ch ta)) th :=
@syl3an3 (wa ch ta) ph ps ch th
  (@simpl ch ta)
  ad4ant3_1


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 16-Feb-2008.) -/
theorem «3adant3r1» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph (w3a ta ps ch)) th :=
@«3adantr1» ph ps ch th ta
  (@«3expb» ph ps ch th
    ad4ant3_1)


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 17-Feb-2008.) -/
theorem «3adant3r2» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph (w3a ps ta ch)) th :=
@«3adantr2» ph ps ch th ta
  (@«3expb» ph ps ch th
    ad4ant3_1)


/-- Deduction adding a conjunct to antecedent. (Contributed by NM, 18-Feb-2008.) -/
theorem «3adant3r3» {ph ps ch th ta : wff}
  (ad4ant3_1 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph (w3a ps ch ta)) th :=
@«3adantr3» ph ps ch th ta
  (@«3expb» ph ps ch th
    ad4ant3_1)


/-- Deduction adding conjuncts to antecedent. (Contributed by NM, 4-Aug-2007.) -/
theorem «3ad2antl1» {ph ps ch th ta : wff}
  («3ad2antl_1» : ⊦ wi (wa ph ch) th) :
  ⊦ wi (wa (w3a ph ps ta) ch) th :=
@«3adantl2» ph ta ch th ps
  (@adantlr ph ch th ta
    «3ad2antl_1»)


/-- Deduction adding conjuncts to antecedent. (Contributed by NM, 4-Aug-2007.) -/
theorem «3ad2antl2» {ph ps ch th ta : wff}
  («3ad2antl_1» : ⊦ wi (wa ph ch) th) :
  ⊦ wi (wa (w3a ps ph ta) ch) th :=
@«3adantl1» ph ta ch th ps
  (@adantlr ph ch th ta
    «3ad2antl_1»)


/-- Deduction adding conjuncts to antecedent. (Contributed by NM, 4-Aug-2007.) -/
theorem «3ad2antl3» {ph ps ch th ta : wff}
  («3ad2antl_1» : ⊦ wi (wa ph ch) th) :
  ⊦ wi (wa (w3a ps ta ph) ch) th :=
@«3adantl1» ta ph ch th ps
  (@adantll ph ch th ta
    «3ad2antl_1»)


/-- Deduction adding conjuncts to antecedent. (Contributed by NM, 25-Dec-2007.) -/
theorem «3ad2antr1» {ph ps ch th ta : wff}
  («3ad2antl_1» : ⊦ wi (wa ph ch) th) :
  ⊦ wi (wa ph (w3a ch ps ta)) th :=
@«3adantr3» ph ch ps th ta
  (@adantrr ph ch th ps
    «3ad2antl_1»)


/-- Deduction adding conjuncts to antecedent. (Contributed by NM, 27-Dec-2007.) -/
theorem «3ad2antr2» {ph ps ch th ta : wff}
  («3ad2antl_1» : ⊦ wi (wa ph ch) th) :
  ⊦ wi (wa ph (w3a ps ch ta)) th :=
@«3adantr3» ph ps ch th ta
  (@adantrl ph ch th ps
    «3ad2antl_1»)


/-- Deduction adding conjuncts to antecedent. (Contributed by NM, 30-Dec-2007.) -/
theorem «3ad2antr3» {ph ps ch th ta : wff}
  («3ad2antl_1» : ⊦ wi (wa ph ch) th) :
  ⊦ wi (wa ph (w3a ps ta ch)) th :=
@«3adantr1» ph ta ch th ps
  (@adantrl ph ch th ta
    «3ad2antl_1»)


/-- Simplification of conjunction. (Contributed by Jeff Hankins, 17-Nov-2009.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem simpl1 {ph ps ch th : wff} :
  ⊦ wi (wa (w3a ph ps ch) th) ph :=
@«3ad2antl1» ph ps th ph ch
  (@simpl ph th)


/-- Simplification of conjunction. (Contributed by Jeff Hankins, 17-Nov-2009.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem simpl2 {ph ps ch th : wff} :
  ⊦ wi (wa (w3a ph ps ch) th) ps :=
@«3ad2antl2» ps ph th ps ch
  (@simpl ps th)


/-- Simplification of conjunction. (Contributed by Jeff Hankins, 17-Nov-2009.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem simpl3 {ph ps ch th : wff} :
  ⊦ wi (wa (w3a ph ps ch) th) ch :=
@«3ad2antl3» ch ph th ch ps
  (@simpl ch th)


/-- Simplification of conjunction. (Contributed by Jeff Hankins, 17-Nov-2009.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem simpr1 {ph ps ch th : wff} :
  ⊦ wi (wa ph (w3a ps ch th)) ps :=
@«3ad2antr1» ph ch ps ps th
  (@simpr ph ps)


/-- Simplification of conjunction. (Contributed by Jeff Hankins, 17-Nov-2009.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem simpr2 {ph ps ch th : wff} :
  ⊦ wi (wa ph (w3a ps ch th)) ch :=
@«3ad2antr2» ph ps ch ch th
  (@simpr ph ch)


/-- Simplification of conjunction. (Contributed by Jeff Hankins, 17-Nov-2009.) (Proof shortened by
Wolf Lammen, 23-Jun-2022.) -/
theorem simpr3 {ph ps ch th : wff} :
  ⊦ wi (wa ph (w3a ps ch th)) th :=
@«3ad2antr3» ph ps th th ch
  (@simpr ph th)


/-- Simplification of triple conjunction. (Contributed by NM, 9-Nov-2011.) -/
theorem simp1l {ph ps ch th : wff} :
  ⊦ wi (w3a (wa ph ps) ch th) ph :=
@«3ad2ant1» (wa ph ps) ch ph th
  (@simpl ph ps)


/-- Simplification of triple conjunction. (Contributed by NM, 9-Nov-2011.) -/
theorem simp1r {ph ps ch th : wff} :
  ⊦ wi (w3a (wa ph ps) ch th) ps :=
@«3ad2ant1» (wa ph ps) ch ps th
  (@simpr ph ps)


/-- Simplification of triple conjunction. (Contributed by NM, 9-Nov-2011.) -/
theorem simp2l {ph ps ch th : wff} :
  ⊦ wi (w3a ph (wa ps ch) th) ps :=
@«3ad2ant2» (wa ps ch) ph ps th
  (@simpl ps ch)


/-- Simplification of triple conjunction. (Contributed by NM, 9-Nov-2011.) -/
theorem simp2r {ph ps ch th : wff} :
  ⊦ wi (w3a ph (wa ps ch) th) ch :=
@«3ad2ant2» (wa ps ch) ph ch th
  (@simpr ps ch)


/-- Simplification of triple conjunction. (Contributed by NM, 9-Nov-2011.) -/
theorem simp3l {ph ps ch th : wff} :
  ⊦ wi (w3a ph ps (wa ch th)) ch :=
@«3ad2ant3» (wa ch th) ph ch ps
  (@simpl ch th)


/-- Simplification of triple conjunction. (Contributed by NM, 9-Nov-2011.) -/
theorem simp3r {ph ps ch th : wff} :
  ⊦ wi (w3a ph ps (wa ch th)) th :=
@«3ad2ant3» (wa ch th) ph th ps
  (@simpr ch th)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp11 {ph ps ch th ta : wff} :
  ⊦ wi (w3a (w3a ph ps ch) th ta) ph :=
@«3ad2ant1» (w3a ph ps ch) th ph ta
  (@simp1 ph ps ch)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp12 {ph ps ch th ta : wff} :
  ⊦ wi (w3a (w3a ph ps ch) th ta) ps :=
@«3ad2ant1» (w3a ph ps ch) th ps ta
  (@simp2 ph ps ch)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp13 {ph ps ch th ta : wff} :
  ⊦ wi (w3a (w3a ph ps ch) th ta) ch :=
@«3ad2ant1» (w3a ph ps ch) th ch ta
  (@simp3 ph ps ch)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp21 {ph ps ch th ta : wff} :
  ⊦ wi (w3a ph (w3a ps ch th) ta) ps :=
@«3ad2ant2» (w3a ps ch th) ph ps ta
  (@simp1 ps ch th)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp22 {ph ps ch th ta : wff} :
  ⊦ wi (w3a ph (w3a ps ch th) ta) ch :=
@«3ad2ant2» (w3a ps ch th) ph ch ta
  (@simp2 ps ch th)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp23 {ph ps ch th ta : wff} :
  ⊦ wi (w3a ph (w3a ps ch th) ta) th :=
@«3ad2ant2» (w3a ps ch th) ph th ta
  (@simp3 ps ch th)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp32 {ph ps ch th ta : wff} :
  ⊦ wi (w3a ph ps (w3a ch th ta)) th :=
@«3ad2ant3» (w3a ch th ta) ph th ps
  (@simp2 ch th ta)


/-- Simplification of doubly triple conjunction. (Contributed by NM, 17-Nov-2011.) -/
theorem simp33 {ph ps ch th ta : wff} :
  ⊦ wi (w3a ph ps (w3a ch th ta)) ta :=
@«3ad2ant3» (w3a ch th ta) ph ta ps
  (@simp3 ch th ta)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpll1 {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa (w3a ph ps ch) th) ta) ph :=
@ad2antrr (w3a ph ps ch) ph th ta
  (@simp1 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpll2 {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa (w3a ph ps ch) th) ta) ps :=
@ad2antrr (w3a ph ps ch) ps th ta
  (@simp2 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpll3 {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa (w3a ph ps ch) th) ta) ch :=
@ad2antrr (w3a ph ps ch) ch th ta
  (@simp3 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simplr1 {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa th (w3a ph ps ch)) ta) ph :=
@ad2antlr (w3a ph ps ch) ph th ta
  (@simp1 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simplr2 {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa th (w3a ph ps ch)) ta) ps :=
@ad2antlr (w3a ph ps ch) ps th ta
  (@simp2 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simplr3 {ph ps ch th ta : wff} :
  ⊦ wi (wa (wa th (w3a ph ps ch)) ta) ch :=
@ad2antlr (w3a ph ps ch) ch th ta
  (@simp3 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simprl1 {ph ps ch th ta : wff} :
  ⊦ wi (wa ta (wa (w3a ph ps ch) th)) ph :=
@ad2antrl (w3a ph ps ch) ph ta th
  (@simp1 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simprl3 {ph ps ch th ta : wff} :
  ⊦ wi (wa ta (wa (w3a ph ps ch) th)) ch :=
@ad2antrl (w3a ph ps ch) ch ta th
  (@simp3 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simprr1 {ph ps ch th ta : wff} :
  ⊦ wi (wa ta (wa th (w3a ph ps ch))) ph :=
@ad2antll (w3a ph ps ch) ph ta th
  (@simp1 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simprr2 {ph ps ch th ta : wff} :
  ⊦ wi (wa ta (wa th (w3a ph ps ch))) ps :=
@ad2antll (w3a ph ps ch) ps ta th
  (@simp2 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simprr3 {ph ps ch th ta : wff} :
  ⊦ wi (wa ta (wa th (w3a ph ps ch))) ch :=
@ad2antll (w3a ph ps ch) ch ta th
  (@simp3 ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpl1l {ph ps ch th ta : wff} :
  ⊦ wi (wa (w3a (wa ph ps) ch th) ta) ph :=
@«3ad2antl1» (wa ph ps) ch ta ph th
  (@simpll ph ps ta)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpl1r {ph ps ch th ta : wff} :
  ⊦ wi (wa (w3a (wa ph ps) ch th) ta) ps :=
@«3ad2antl1» (wa ph ps) ch ta ps th
  (@simplr ph ps ta)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpl2l {ph ps ch th ta : wff} :
  ⊦ wi (wa (w3a ch (wa ph ps) th) ta) ph :=
@«3ad2antl2» (wa ph ps) ch ta ph th
  (@simpll ph ps ta)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpl2r {ph ps ch th ta : wff} :
  ⊦ wi (wa (w3a ch (wa ph ps) th) ta) ps :=
@«3ad2antl2» (wa ph ps) ch ta ps th
  (@simplr ph ps ta)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpl3l {ph ps ch th ta : wff} :
  ⊦ wi (wa (w3a ch th (wa ph ps)) ta) ph :=
@«3ad2antl3» (wa ph ps) ch ta ph th
  (@simpll ph ps ta)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
23-Jun-2022.) -/
theorem simpl3r {ph ps ch th ta : wff} :
  ⊦ wi (wa (w3a ch th (wa ph ps)) ta) ps :=
@«3ad2antl3» (wa ph ps) ch ta ps th
  (@simplr ph ps ta)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
24-Jun-2022.) -/
theorem simpr1l {ph ps ch th ta : wff} :
  ⊦ wi (wa ta (w3a (wa ph ps) ch th)) ph :=
@«3ad2antr1» ta ch (wa ph ps) ph th
  (@simprl ta ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
24-Jun-2022.) -/
theorem simpr1r {ph ps ch th ta : wff} :
  ⊦ wi (wa ta (w3a (wa ph ps) ch th)) ps :=
@«3ad2antr1» ta ch (wa ph ps) ps th
  (@simprr ta ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp1rl {ph ps ch th ta : wff} :
  ⊦ wi (w3a (wa ch (wa ph ps)) th ta) ph :=
@«3ad2ant1» (wa ch (wa ph ps)) th ph ta
  (@simprl ch ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp1rr {ph ps ch th ta : wff} :
  ⊦ wi (w3a (wa ch (wa ph ps)) th ta) ps :=
@«3ad2ant1» (wa ch (wa ph ps)) th ps ta
  (@simprr ch ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp2ll {ph ps ch th ta : wff} :
  ⊦ wi (w3a th (wa (wa ph ps) ch) ta) ph :=
@«3ad2ant2» (wa (wa ph ps) ch) th ph ta
  (@simpll ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp2lr {ph ps ch th ta : wff} :
  ⊦ wi (w3a th (wa (wa ph ps) ch) ta) ps :=
@«3ad2ant2» (wa (wa ph ps) ch) th ps ta
  (@simplr ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp2rl {ph ps ch th ta : wff} :
  ⊦ wi (w3a th (wa ch (wa ph ps)) ta) ph :=
@«3ad2ant2» (wa ch (wa ph ps)) th ph ta
  (@simprl ch ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp2rr {ph ps ch th ta : wff} :
  ⊦ wi (w3a th (wa ch (wa ph ps)) ta) ps :=
@«3ad2ant2» (wa ch (wa ph ps)) th ps ta
  (@simprr ch ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp3ll {ph ps ch th ta : wff} :
  ⊦ wi (w3a th ta (wa (wa ph ps) ch)) ph :=
@«3ad2ant3» (wa (wa ph ps) ch) th ph ta
  (@simpll ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp3lr {ph ps ch th ta : wff} :
  ⊦ wi (w3a th ta (wa (wa ph ps) ch)) ps :=
@«3ad2ant3» (wa (wa ph ps) ch) th ps ta
  (@simplr ph ps ch)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp3rl {ph ps ch th ta : wff} :
  ⊦ wi (w3a th ta (wa ch (wa ph ps))) ph :=
@«3ad2ant3» (wa ch (wa ph ps)) th ph ta
  (@simprl ch ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp3rr {ph ps ch th ta : wff} :
  ⊦ wi (w3a th ta (wa ch (wa ph ps))) ps :=
@«3ad2ant3» (wa ch (wa ph ps)) th ps ta
  (@simprr ch ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) (Proof shortened by Wolf Lammen,
24-Jun-2022.) -/
theorem simpl23 {ph ps ch th ta et : wff} :
  ⊦ wi (wa (w3a th (w3a ph ps ch) ta) et) ch :=
@«3ad2antl2» (w3a ph ps ch) th et ch ta
  (@simpl3 ph ps ch et)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp11l {ph ps ch th ta et : wff} :
  ⊦ wi (w3a (w3a (wa ph ps) ch th) ta et) ph :=
@«3ad2ant1» (w3a (wa ph ps) ch th) ta ph et
  (@simp1l ph ps ch th)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp11r {ph ps ch th ta et : wff} :
  ⊦ wi (w3a (w3a (wa ph ps) ch th) ta et) ps :=
@«3ad2ant1» (w3a (wa ph ps) ch th) ta ps et
  (@simp1r ph ps ch th)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp13l {ph ps ch th ta et : wff} :
  ⊦ wi (w3a (w3a ch th (wa ph ps)) ta et) ph :=
@«3ad2ant1» (w3a ch th (wa ph ps)) ta ph et
  (@simp3l ch th ph ps)


/-- Simplification of conjunction. (Contributed by NM, 9-Mar-2012.) -/
theorem simp13r {ph ps ch th ta et : wff} :
  ⊦ wi (w3a (w3a ch th (wa ph ps)) ta et) ps :=
@«3ad2ant1» (w3a ch th (wa ph ps)) ta ps et
  (@simp3r ch th ph ps)


/-- Remove a hypothesis from the second member of a biconditional. (Contributed by FL, 22-Jul-2008.)
-/
theorem «3anibar» {ph ps ch th ta : wff}
  («3anibar_1» : ⊦ wi (w3a ph ps ch) (wb th (wa ch ta))) :
  ⊦ wi (w3a ph ps ch) (wb th ta) :=
@mpbirand (w3a ph ps ch) th ch ta
  (@simp3 ph ps ch)
  «3anibar_1»


/-- Introduction in triple disjunction. (Contributed by NM, 4-Apr-1995.) -/
theorem «3mix1» {ph ps ch : wff} :
  ⊦ wi ph (w3o ph ps ch) :=
@sylibr ph (wo ph (wo ps ch)) (w3o ph ps ch)
  (@orc ph (wo ps ch))
  (@«3orass» ph ps ch)


/-- Introduction in triple disjunction. (Contributed by NM, 4-Apr-1995.) -/
theorem «3mix2» {ph ps ch : wff} :
  ⊦ wi ph (w3o ps ph ch) :=
@sylibr ph (w3o ph ch ps) (w3o ps ph ch)
  (@«3mix1» ph ch ps)
  (@«3orrot» ps ph ch)


/-- Introduction in triple disjunction. (Contributed by NM, 4-Apr-1995.) -/
theorem «3mix3» {ph ps ch : wff} :
  ⊦ wi ph (w3o ps ch ph) :=
@sylib ph (w3o ph ps ch) (w3o ps ch ph)
  (@«3mix1» ph ps ch)
  (@«3orrot» ph ps ch)


/-- Introduction in triple disjunction. (Contributed by Mario Carneiro, 6-Oct-2014.) -/
theorem «3mix1i» {ph ps ch : wff}
  («3mixi_1» : ⊦ ph) :
  ⊦ w3o ph ps ch :=
@ax_mp ph (w3o ph ps ch)
  «3mixi_1»
  (@«3mix1» ph ps ch)


/-- Deduction introducing triple disjunction. (Contributed by Scott Fenton, 8-Jun-2011.) -/
theorem «3mix3d» {ph ps ch th : wff}
  («3mixd_1» : ⊦ wi ph ps) :
  ⊦ wi ph (w3o ch th ps) :=
@syl ph ps (w3o ch th ps)
  «3mixd_1»
  (@«3mix3» ps ch th)


/-- Infer conjunction of premises. (Contributed by NM, 10-Feb-1995.) -/
theorem «3pm3_2i» {ph ps ch : wff}
  («3pm3_2i_1» : ⊦ ph)
  («3pm3_2i_2» : ⊦ ps)
  («3pm3_2i_3» : ⊦ ch) :
  ⊦ w3a ph ps ch :=
@mpbir2an (w3a ph ps ch) (wa ph ps) ch
  (@pm3_2i ph ps
    «3pm3_2i_1»
    «3pm3_2i_2»)
  «3pm3_2i_3»
  (@df_3an ph ps ch)


/-- Detach a conjunction of truths in a biconditional. (Contributed by NM, 16-Sep-2011.) -/
theorem mpbir3an {ph ps ch th : wff}
  (mpbir3an_1 : ⊦ ps)
  (mpbir3an_2 : ⊦ ch)
  (mpbir3an_3 : ⊦ th)
  (mpbir3an_4 : ⊦ wb ph (w3a ps ch th)) :
  ⊦ ph :=
@mpbir ph (w3a ps ch th)
  (@«3pm3_2i» ps ch th
    mpbir3an_1
    mpbir3an_2
    mpbir3an_3)
  mpbir3an_4


/-- Detach a conjunction of truths in a biconditional. (Contributed by Mario Carneiro, 11-May-2014.)
(Revised by Mario Carneiro, 9-Jan-2015.) -/
theorem mpbir3and {ph ps ch th ta : wff}
  (mpbir3and_1 : ⊦ wi ph ch)
  (mpbir3and_2 : ⊦ wi ph th)
  (mpbir3and_3 : ⊦ wi ph ta)
  (mpbir3and_4 : ⊦ wi ph (wb ps (w3a ch th ta))) :
  ⊦ wi ph ps :=
@mpbird ph ps (w3a ch th ta)
  (@«3jca» ph ch th ta
    mpbir3and_1
    mpbir3and_2
    mpbir3and_3)
  mpbir3and_4


/-- Syllogism inference. (Contributed by Mario Carneiro, 11-May-2014.) -/
theorem syl3anbrc {ph ps ch th ta : wff}
  (syl3anbrc_1 : ⊦ wi ph ps)
  (syl3anbrc_2 : ⊦ wi ph ch)
  (syl3anbrc_3 : ⊦ wi ph th)
  (syl3anbrc_4 : ⊦ wb ta (w3a ps ch th)) :
  ⊦ wi ph ta :=
@sylibr ph (w3a ps ch th) ta
  (@«3jca» ph ps ch th
    syl3anbrc_1
    syl3anbrc_2
    syl3anbrc_3)
  syl3anbrc_4


/-- Syllogism inference. (Contributed by Peter Mazsa, 18-Sep-2022.) -/
theorem syl21anbrc {ph ps ch th ta : wff}
  (syl21anbrc_1 : ⊦ wi ph ps)
  (syl21anbrc_2 : ⊦ wi ph ch)
  (syl21anbrc_3 : ⊦ wi ph th)
  (syl21anbrc_4 : ⊦ wb ta (wa (wa ps ch) th)) :
  ⊦ wi ph ta :=
@sylibr ph (wa (wa ps ch) th) ta
  (@jca31 ph ps ch th
    syl21anbrc_1
    syl21anbrc_2
    syl21anbrc_3)
  syl21anbrc_4


/-- An elimination deduction. (Contributed by Alan Sare, 17-Oct-2017.) (Proof shortened by Wolf
Lammen, 13-Apr-2022.) -/
theorem «3imp3i2an» {ph ps ch th ta et : wff}
  («3imp3i2an_1» : ⊦ wi (w3a ph ps ch) th)
  («3imp3i2an_2» : ⊦ wi (wa ph ch) ta)
  («3imp3i2an_3» : ⊦ wi (wa th ta) et) :
  ⊦ wi (w3a ph ps ch) et :=
@syl2anc (w3a ph ps ch) th ta et
  «3imp3i2an_1»
  (@«3adant2» ph ch ta ps
    «3imp3i2an_2»)
  «3imp3i2an_3»


/-- Importation to left triple conjunction. (Contributed by NM, 24-Feb-2005.) -/
theorem «3imp1» {ph ps ch th ta : wff}
  («3imp1_1» : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi (wa (w3a ph ps ch) th) ta :=
@imp (w3a ph ps ch) th ta
  (@«3imp» ph ps ch (wi th ta)
    «3imp1_1»)


/-- Importation deduction for triple conjunction. (Contributed by NM, 26-Oct-2006.) -/
theorem «3impd» {ph ps ch th ta : wff}
  («3imp1_1» : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi ph (wi (w3a ps ch th) ta) :=
@com12 (w3a ps ch th) ph ta
  (@«3imp» ps ch th (wi ph ta)
    (@com4l ph ps ch th ta
      «3imp1_1»))


/-- Importation to right triple conjunction. (Contributed by NM, 26-Oct-2006.) -/
theorem «3imp2» {ph ps ch th ta : wff}
  («3imp1_1» : ⊦ wi ph (wi ps (wi ch (wi th ta)))) :
  ⊦ wi (wa ph (w3a ps ch th)) ta :=
@imp ph (w3a ps ch th) ta
  (@«3impd» ph ps ch th ta
    «3imp1_1»)


/-- Importation inference (undistribute conjunction). (Contributed by NM, 14-Aug-1995.) -/
theorem «3impdi» {ph ps ch th : wff}
  («3impdi_1» : ⊦ wi (wa (wa ph ps) (wa ph ch)) th) :
  ⊦ wi (w3a ph ps ch) th :=
@«3impb» ph ps ch th
  (@anandis ph ps ch th
    «3impdi_1»)


/-- Importation inference (undistribute conjunction). (Contributed by NM, 20-Aug-1995.) -/
theorem «3impdir» {ph ps ch th : wff}
  («3impdir_1» : ⊦ wi (wa (wa ph ps) (wa ch ps)) th) :
  ⊦ wi (w3a ph ch ps) th :=
@«3impa» ph ch ps th
  (@anandirs ph ch ps th
    «3impdir_1»)


/-- Exportation from left triple conjunction. (Contributed by NM, 24-Feb-2005.) -/
theorem «3exp1» {ph ps ch th ta : wff}
  («3exp1_1» : ⊦ wi (wa (w3a ph ps ch) th) ta) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@«3exp» ph ps ch (wi th ta)
  (@ex (w3a ph ps ch) th ta
    «3exp1_1»)


/-- Exportation deduction for triple conjunction. (Contributed by NM, 26-Oct-2006.) -/
theorem «3expd» {ph ps ch th ta : wff}
  («3expd_1» : ⊦ wi ph (wi (w3a ps ch th) ta)) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@com4r ps ch th ph ta
  (@«3exp» ps ch th (wi ph ta)
    (@com12 ph (w3a ps ch th) ta
      «3expd_1»))


/-- Exportation from right triple conjunction. (Contributed by NM, 26-Oct-2006.) -/
theorem «3exp2» {ph ps ch th ta : wff}
  («3exp2_1» : ⊦ wi (wa ph (w3a ps ch th)) ta) :
  ⊦ wi ph (wi ps (wi ch (wi th ta))) :=
@«3expd» ph ps ch th ta
  (@ex ph (w3a ps ch th) ta
    «3exp2_1»)


/-- A triple exportation inference. (Contributed by Jeff Hankins, 8-Jul-2009.) -/
theorem exp5o {ph ps ch th ta et : wff}
  (exp5o_1 : ⊦ wi (w3a ph ps ch) (wi (wa th ta) et)) :
  ⊦ wi ph (wi ps (wi ch (wi th (wi ta et)))) :=
@«3exp» ph ps ch (wi th (wi ta et))
  (@expd (w3a ph ps ch) th ta et
    exp5o_1)


/-- A triple exportation inference. (Contributed by Jeff Hankins, 8-Jul-2009.) -/
theorem exp520 {ph ps ch th ta et : wff}
  (exp520_1 : ⊦ wi (wa (w3a ph ps ch) (wa th ta)) et) :
  ⊦ wi ph (wi ps (wi ch (wi th (wi ta et)))) :=
@exp5o ph ps ch th ta et
  (@ex (w3a ph ps ch) (wa th ta) et
    exp520_1)


/-- Associative law for conjunction applied to antecedent (eliminates syllogism). (Contributed by
Mario Carneiro, 4-Jan-2017.) -/
theorem «3anassrs» {ph ps ch th ta : wff}
  («3anassrs_1» : ⊦ wi (wa ph (w3a ps ch th)) ta) :
  ⊦ wi (wa (wa (wa ph ps) ch) th) ta :=
@imp41 ph ps ch th ta
  (@«3exp2» ph ps ch th ta
    «3anassrs_1»)


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl3anc {ph ps ch th ta : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3anc_4 : ⊦ wi (w3a ps ch th) ta) :
  ⊦ wi ph ta :=
@syl ph (w3a ps ch th) ta
  (@«3jca» ph ps ch th
    syl3anc_1
    syl3anc_2
    syl3anc_3)
  syl3anc_4


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl13anc {ph ps ch th ta et : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl13anc_5 : ⊦ wi (wa ps (w3a ch th ta)) et) :
  ⊦ wi ph et :=
@syl2anc ph ps (w3a ch th ta) et
  syl3anc_1
  (@«3jca» ph ch th ta
    syl3anc_2
    syl3anc_3
    syl3Xanc_4)
  syl13anc_5


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl31anc {ph ps ch th ta et : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl31anc_5 : ⊦ wi (wa (w3a ps ch th) ta) et) :
  ⊦ wi ph et :=
@syl2anc ph (w3a ps ch th) ta et
  (@«3jca» ph ps ch th
    syl3anc_1
    syl3anc_2
    syl3anc_3)
  syl3Xanc_4
  syl31anc_5


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl112anc {ph ps ch th ta et : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl112anc_5 : ⊦ wi (w3a ps ch (wa th ta)) et) :
  ⊦ wi ph et :=
@syl3anc ph ps ch (wa th ta) et
  syl3anc_1
  syl3anc_2
  (@jca ph th ta
    syl3anc_3
    syl3Xanc_4)
  syl112anc_5


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl121anc {ph ps ch th ta et : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl121anc_5 : ⊦ wi (w3a ps (wa ch th) ta) et) :
  ⊦ wi ph et :=
@syl3anc ph ps (wa ch th) ta et
  syl3anc_1
  (@jca ph ch th
    syl3anc_2
    syl3anc_3)
  syl3Xanc_4
  syl121anc_5


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl211anc {ph ps ch th ta et : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl211anc_5 : ⊦ wi (w3a (wa ps ch) th ta) et) :
  ⊦ wi ph et :=
@syl3anc ph (wa ps ch) th ta et
  (@jca ph ps ch
    syl3anc_1
    syl3anc_2)
  syl3anc_3
  syl3Xanc_4
  syl211anc_5


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl23anc {ph ps ch th ta et ze : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl23anc_6 : ⊦ wi (wa (wa ps ch) (w3a th ta et)) ze) :
  ⊦ wi ph ze :=
@syl13anc ph (wa ps ch) th ta et ze
  (@jca ph ps ch
    syl3anc_1
    syl3anc_2)
  syl3anc_3
  syl3Xanc_4
  syl23anc_5
  syl23anc_6


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl32anc {ph ps ch th ta et ze : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl32anc_6 : ⊦ wi (wa (w3a ps ch th) (wa ta et)) ze) :
  ⊦ wi ph ze :=
@syl31anc ph ps ch th (wa ta et) ze
  syl3anc_1
  syl3anc_2
  syl3anc_3
  (@jca ph ta et
    syl3Xanc_4
    syl23anc_5)
  syl32anc_6


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl122anc {ph ps ch th ta et ze : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl122anc_6 : ⊦ wi (w3a ps (wa ch th) (wa ta et)) ze) :
  ⊦ wi ph ze :=
@syl121anc ph ps ch th (wa ta et) ze
  syl3anc_1
  syl3anc_2
  syl3anc_3
  (@jca ph ta et
    syl3Xanc_4
    syl23anc_5)
  syl122anc_6


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl221anc {ph ps ch th ta et ze : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl221anc_6 : ⊦ wi (w3a (wa ps ch) (wa th ta) et) ze) :
  ⊦ wi ph ze :=
@syl211anc ph ps ch (wa th ta) et ze
  syl3anc_1
  syl3anc_2
  (@jca ph th ta
    syl3anc_3
    syl3Xanc_4)
  syl23anc_5
  syl221anc_6


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl113anc {ph ps ch th ta et ze : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl113anc_6 : ⊦ wi (w3a ps ch (w3a th ta et)) ze) :
  ⊦ wi ph ze :=
@syl3anc ph ps ch (w3a th ta et) ze
  syl3anc_1
  syl3anc_2
  (@«3jca» ph th ta et
    syl3anc_3
    syl3Xanc_4
    syl23anc_5)
  syl113anc_6


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl131anc {ph ps ch th ta et ze : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl131anc_6 : ⊦ wi (w3a ps (w3a ch th ta) et) ze) :
  ⊦ wi ph ze :=
@syl3anc ph ps (w3a ch th ta) et ze
  syl3anc_1
  (@«3jca» ph ch th ta
    syl3anc_2
    syl3anc_3
    syl3Xanc_4)
  syl23anc_5
  syl131anc_6


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl311anc {ph ps ch th ta et ze : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl311anc_6 : ⊦ wi (w3a (w3a ps ch th) ta et) ze) :
  ⊦ wi ph ze :=
@syl3anc ph (w3a ps ch th) ta et ze
  (@«3jca» ph ps ch th
    syl3anc_1
    syl3anc_2
    syl3anc_3)
  syl3Xanc_4
  syl23anc_5
  syl311anc_6


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl33anc {ph ps ch th ta et ze si : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl33anc_6 : ⊦ wi ph ze)
  (syl33anc_7 : ⊦ wi (wa (w3a ps ch th) (w3a ta et ze)) si) :
  ⊦ wi ph si :=
@syl13anc ph (w3a ps ch th) ta et ze si
  (@«3jca» ph ps ch th
    syl3anc_1
    syl3anc_2
    syl3anc_3)
  syl3Xanc_4
  syl23anc_5
  syl33anc_6
  syl33anc_7


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl222anc {ph ps ch th ta et ze si : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl33anc_6 : ⊦ wi ph ze)
  (syl222anc_7 : ⊦ wi (w3a (wa ps ch) (wa th ta) (wa et ze)) si) :
  ⊦ wi ph si :=
@syl221anc ph ps ch th ta (wa et ze) si
  syl3anc_1
  syl3anc_2
  syl3anc_3
  syl3Xanc_4
  (@jca ph et ze
    syl23anc_5
    syl33anc_6)
  syl222anc_7


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl123anc {ph ps ch th ta et ze si : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl33anc_6 : ⊦ wi ph ze)
  (syl123anc_7 : ⊦ wi (w3a ps (wa ch th) (w3a ta et ze)) si) :
  ⊦ wi ph si :=
@syl113anc ph ps (wa ch th) ta et ze si
  syl3anc_1
  (@jca ph ch th
    syl3anc_2
    syl3anc_3)
  syl3Xanc_4
  syl23anc_5
  syl33anc_6
  syl123anc_7


/-- Syllogism combined with contraction. (Contributed by NM, 11-Mar-2012.) -/
theorem syl331anc {ph ps ch th ta et ze si rh : wff}
  (syl3anc_1 : ⊦ wi ph ps)
  (syl3anc_2 : ⊦ wi ph ch)
  (syl3anc_3 : ⊦ wi ph th)
  (syl3Xanc_4 : ⊦ wi ph ta)
  (syl23anc_5 : ⊦ wi ph et)
  (syl33anc_6 : ⊦ wi ph ze)
  (syl133anc_7 : ⊦ wi ph si)
  (syl331anc_8 : ⊦ wi (w3a (w3a ps ch th) (w3a ta et ze) si) rh) :
  ⊦ wi ph rh :=
@syl311anc ph ps ch th (w3a ta et ze) si rh
  syl3anc_1
  syl3anc_2
  syl3anc_3
  (@«3jca» ph ta et ze
    syl3Xanc_4
    syl23anc_5
    syl33anc_6)
  syl133anc_7
  syl331anc_8


/-- A syllogism inference. (Contributed by NM, 22-Aug-1995.) -/
theorem syl3an1b {ph ps ch th ta : wff}
  (syl3an1b_1 : ⊦ wb ph ps)
  (syl3an1b_2 : ⊦ wi (w3a ps ch th) ta) :
  ⊦ wi (w3a ph ch th) ta :=
@syl3an1 ph ps ch th ta
  (@biimpi ph ps
    syl3an1b_1)
  syl3an1b_2


/-- A syllogism inference. (Contributed by NM, 22-Aug-1995.) -/
theorem syl3an2b {ph ps ch th ta : wff}
  (syl3an2b_1 : ⊦ wb ph ch)
  (syl3an2b_2 : ⊦ wi (w3a ps ch th) ta) :
  ⊦ wi (w3a ps ph th) ta :=
@syl3an2 ph ps ch th ta
  (@biimpi ph ch
    syl3an2b_1)
  syl3an2b_2


/-- A syllogism inference. (Contributed by NM, 22-Aug-1995.) -/
theorem syl3an3b {ph ps ch th ta : wff}
  (syl3an3b_1 : ⊦ wb ph th)
  (syl3an3b_2 : ⊦ wi (w3a ps ch th) ta) :
  ⊦ wi (w3a ps ch ph) ta :=
@syl3an3 ph ps ch th ta
  (@biimpi ph th
    syl3an3b_1)
  syl3an3b_2


/-- A syllogism inference. (Contributed by NM, 20-May-2007.) -/
theorem syld3an3 {ph ps ch th ta : wff}
  (syld3an3_1 : ⊦ wi (w3a ph ps ch) th)
  (syld3an3_2 : ⊦ wi (w3a ph ps th) ta) :
  ⊦ wi (w3a ph ps ch) ta :=
@syl3anc (w3a ph ps ch) ph ps th ta
  (@simp1 ph ps ch)
  (@simp2 ph ps ch)
  syld3an3_1
  syld3an3_2


/-- A syllogism inference. (Contributed by NM, 7-Jul-2008.) (Proof shortened by Wolf Lammen,
26-Jun-2022.) -/
theorem syld3an1 {ph ps ch th ta : wff}
  (syld3an1_1 : ⊦ wi (w3a ch ps th) ph)
  (syld3an1_2 : ⊦ wi (w3a ph ps th) ta) :
  ⊦ wi (w3a ch ps th) ta :=
@syl3anc (w3a ch ps th) ph ps th ta
  syld3an1_1
  (@simp2 ch ps th)
  (@simp3 ch ps th)
  syld3an1_2


/-- A syllogism inference. (Contributed by NM, 20-May-2007.) -/
theorem syld3an2 {ph ps ch th ta : wff}
  (syld3an2_1 : ⊦ wi (w3a ph ch th) ps)
  (syld3an2_2 : ⊦ wi (w3a ph ps th) ta) :
  ⊦ wi (w3a ph ch th) ta :=
@syl3anc (w3a ph ch th) ph ps th ta
  (@simp1 ph ch th)
  syld3an2_1
  (@simp3 ph ch th)
  syld3an2_2


/-- A syllogism inference. (Contributed by NM, 24-Feb-2005.) -/
theorem syl3anl1 {ph ps ch th ta et : wff}
  (syl3anl1_1 : ⊦ wi ph ps)
  (syl3anl1_2 : ⊦ wi (wa (w3a ps ch th) ta) et) :
  ⊦ wi (wa (w3a ph ch th) ta) et :=
@sylan (w3a ph ch th) (w3a ps ch th) ta et
  (@«3anim1i» ph ps ch th
    syl3anl1_1)
  syl3anl1_2


/-- A syllogism inference. (Contributed by NM, 1-Aug-2007.) (Proof shortened by Wolf Lammen,
27-Jun-2022.) -/
theorem syl3anr2 {ph ps ch th ta et : wff}
  (syl3anr2_1 : ⊦ wi ph th)
  (syl3anr2_2 : ⊦ wi (wa ch (w3a ps th ta)) et) :
  ⊦ wi (wa ch (w3a ps ph ta)) et :=
@sylan2 (w3a ps ph ta) ch (w3a ps th ta) et
  (@«3anim2i» ph th ps ta
    syl3anr2_1)
  syl3anr2_2


/-- Inference from idempotent law for conjunction. (Contributed by NM, 7-Mar-2008.) -/
theorem «3anidm12» {ph ps ch : wff}
  («3anidm12_1» : ⊦ wi (w3a ph ph ps) ch) :
  ⊦ wi (wa ph ps) ch :=
@anabsi5 ph ps ch
  (@«3expib» ph ph ps ch
    «3anidm12_1»)


/-- Inference from idempotent law for conjunction. (Contributed by NM, 7-Mar-2008.) -/
theorem «3anidm13» {ph ps ch : wff}
  («3anidm13_1» : ⊦ wi (w3a ph ps ph) ch) :
  ⊦ wi (wa ph ps) ch :=
@«3anidm12» ph ps ch
  (@«3com23» ph ps ph ch
    «3anidm13_1»)


/-- Inference from idempotent law for conjunction. (Contributed by NM, 1-Feb-2007.) -/
theorem «3anidm23» {ph ps ch : wff}
  («3anidm23_1» : ⊦ wi (w3a ph ps ps) ch) :
  ⊦ wi (wa ph ps) ch :=
@anabss3 ph ps ch
  (@«3expa» ph ps ps ch
    «3anidm23_1»)


/-- ~ syl3an with antecedents in standard conjunction form. (Contributed by Alan Sare, 31-Aug-2016.)
-/
theorem syl2an3an {ph ps ch th ta et : wff}
  (syl2an3an_1 : ⊦ wi ph ps)
  (syl2an3an_2 : ⊦ wi ph ch)
  (syl2an3an_3 : ⊦ wi th ta)
  (syl2an3an_4 : ⊦ wi (w3a ps ch ta) et) :
  ⊦ wi (wa ph th) et :=
@«3anidm12» ph th et
  (@syl3an ph ps ph ch th ta et
    syl2an3an_1
    syl2an3an_2
    syl2an3an_3
    syl2an3an_4)


/-- Deduction related to ~ syl3an with antecedents in standard conjunction form. (Contributed by
Alan Sare, 31-Aug-2016.) (Proof shortened by Wolf Lammen, 28-Jun-2022.) -/
theorem syl2an23an {ph ps ch th ta et : wff}
  (syl2an23an_1 : ⊦ wi ph ps)
  (syl2an23an_2 : ⊦ wi ph ch)
  (syl2an23an_3 : ⊦ wi (wa th ph) ta)
  (syl2an23an_4 : ⊦ wi (w3a ps ch ta) et) :
  ⊦ wi (wa th ph) et :=
@anabss7 th ph et
  (@syl2an3an ph ps ch (wa th ph) ta et
    syl2an23an_1
    syl2an23an_2
    syl2an23an_3
    syl2an23an_4)


/-- Disjunction of three antecedents. (Contributed by NM, 8-Apr-1994.) -/
theorem «3jao» {ph ps ch th : wff} :
  ⊦ wi (w3a (wi ph ps) (wi ch ps) (wi th ps)) (wi (w3o ph ch th) ps) :=
@«3imp» (wi ph ps) (wi ch ps) (wi th ps) (wi (w3o ph ch th) ps)
  (@syl6 (wi ph ps) (wi ch ps) (wi (wo ph ch) ps) (wi (wi th ps) (wi (w3o ph ch th) ps))
    (@jao ph ps ch)
    (@syl7bi (w3o ph ch th) (wo (wo ph ch) th) (wi (wo ph ch) ps) (wi th ps) ps
      (@df_3or ph ch th)
      (@jao (wo ph ch) ps th)))


/-- Disjunction of three antecedents (inference). (Contributed by NM, 12-Sep-1995.) -/
theorem «3jaoi» {ph ps ch th : wff}
  («3jaoi_1» : ⊦ wi ph ps)
  («3jaoi_2» : ⊦ wi ch ps)
  («3jaoi_3» : ⊦ wi th ps) :
  ⊦ wi (w3o ph ch th) ps :=
@ax_mp (w3a (wi ph ps) (wi ch ps) (wi th ps)) (wi (w3o ph ch th) ps)
  (@«3pm3_2i» (wi ph ps) (wi ch ps) (wi th ps)
    «3jaoi_1»
    «3jaoi_2»
    «3jaoi_3»)
  (@«3jao» ph ps ch th)


/-- Disjunction of three antecedents (deduction). (Contributed by NM, 14-Oct-2005.) -/
theorem «3jaod» {ph ps ch th ta : wff}
  («3jaod_1» : ⊦ wi ph (wi ps ch))
  («3jaod_2» : ⊦ wi ph (wi th ch))
  («3jaod_3» : ⊦ wi ph (wi ta ch)) :
  ⊦ wi ph (wi (w3o ps th ta) ch) :=
@syl3anc ph (wi ps ch) (wi th ch) (wi ta ch) (wi (w3o ps th ta) ch)
  «3jaod_1»
  «3jaod_2»
  «3jaod_3»
  (@«3jao» ps ch th ta)


/-- Disjunction of three antecedents (inference). (Contributed by NM, 14-Oct-2005.) -/
theorem «3jaoian» {ph ps ch th ta : wff}
  («3jaoian_1» : ⊦ wi (wa ph ps) ch)
  («3jaoian_2» : ⊦ wi (wa th ps) ch)
  («3jaoian_3» : ⊦ wi (wa ta ps) ch) :
  ⊦ wi (wa (w3o ph th ta) ps) ch :=
@imp (w3o ph th ta) ps ch
  (@«3jaoi» ph (wi ps ch) th ta
    (@ex ph ps ch
      «3jaoian_1»)
    (@ex th ps ch
      «3jaoian_2»)
    (@ex ta ps ch
      «3jaoian_3»))


/-- Disjunction of three antecedents (deduction). (Contributed by NM, 14-Oct-2005.) -/
theorem «3jaodan» {ph ps ch th ta : wff}
  («3jaodan_1» : ⊦ wi (wa ph ps) ch)
  («3jaodan_2» : ⊦ wi (wa ph th) ch)
  («3jaodan_3» : ⊦ wi (wa ph ta) ch) :
  ⊦ wi (wa ph (w3o ps th ta)) ch :=
@imp ph (w3o ps th ta) ch
  (@«3jaod» ph ps ch th ta
    (@ex ph ps ch
      «3jaodan_1»)
    (@ex ph th ch
      «3jaodan_2»)
    (@ex ph ta ch
      «3jaodan_3»))


/-- Eliminate a three-way disjunction in a deduction. (Contributed by Thierry Arnoux, 13-Apr-2018.)
(Proof shortened by Wolf Lammen, 20-Apr-2024.) -/
theorem mpjao3dan {ph ps ch th ta : wff}
  (mpjao3dan_1 : ⊦ wi (wa ph ps) ch)
  (mpjao3dan_2 : ⊦ wi (wa ph th) ch)
  (mpjao3dan_3 : ⊦ wi (wa ph ta) ch)
  (mpjao3dan_4 : ⊦ wi ph (w3o ps th ta)) :
  ⊦ wi ph ch :=
@mpdan ph (w3o ps th ta) ch
  mpjao3dan_4
  (@«3jaodan» ph ps ch th ta
    mpjao3dan_1
    mpjao3dan_2
    mpjao3dan_3)


/-- Deduction joining 3 equivalences to form equivalence of disjunctions. (Contributed by NM,
20-Apr-1994.) -/
theorem «3orbi123d» {ph ps ch th ta et ze : wff}
  (bi3d_1 : ⊦ wi ph (wb ps ch))
  (bi3d_2 : ⊦ wi ph (wb th ta))
  (bi3d_3 : ⊦ wi ph (wb et ze)) :
  ⊦ wi ph (wb (w3o ps th et) (w3o ch ta ze)) :=
@«3bitr4g» ph (wo (wo ps th) et) (wo (wo ch ta) ze) (w3o ps th et) (w3o ch ta ze)
  (@orbi12d ph (wo ps th) (wo ch ta) et ze
    (@orbi12d ph ps ch th ta
      bi3d_1
      bi3d_2)
    bi3d_3)
  (@df_3or ps th et)
  (@df_3or ch ta ze)


/-- Deduction joining 3 equivalences to form equivalence of conjunctions. (Contributed by NM,
22-Apr-1994.) -/
theorem «3anbi123d» {ph ps ch th ta et ze : wff}
  (bi3d_1 : ⊦ wi ph (wb ps ch))
  (bi3d_2 : ⊦ wi ph (wb th ta))
  (bi3d_3 : ⊦ wi ph (wb et ze)) :
  ⊦ wi ph (wb (w3a ps th et) (w3a ch ta ze)) :=
@«3bitr4g» ph (wa (wa ps th) et) (wa (wa ch ta) ze) (w3a ps th et) (w3a ch ta ze)
  (@anbi12d ph (wa ps th) (wa ch ta) et ze
    (@anbi12d ph ps ch th ta
      bi3d_1
      bi3d_2)
    bi3d_3)
  (@df_3an ps th et)
  (@df_3an ch ta ze)


/-- Deduction conjoining and adding a conjunct to equivalences. (Contributed by NM, 8-Sep-2006.) -/
theorem «3anbi12d» {ph ps ch th ta et : wff}
  («3anbi12d_1» : ⊦ wi ph (wb ps ch))
  («3anbi12d_2» : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb (w3a ps th et) (w3a ch ta et)) :=
@«3anbi123d» ph ps ch th ta et et
  «3anbi12d_1»
  «3anbi12d_2»
  (@biidd ph et)


/-- Deduction conjoining and adding a conjunct to equivalences. (Contributed by NM, 8-Sep-2006.) -/
theorem «3anbi13d» {ph ps ch th ta et : wff}
  («3anbi12d_1» : ⊦ wi ph (wb ps ch))
  («3anbi12d_2» : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb (w3a ps et th) (w3a ch et ta)) :=
@«3anbi123d» ph ps ch et et th ta
  «3anbi12d_1»
  (@biidd ph et)
  «3anbi12d_2»


/-- Deduction conjoining and adding a conjunct to equivalences. (Contributed by NM, 8-Sep-2006.) -/
theorem «3anbi23d» {ph ps ch th ta et : wff}
  («3anbi12d_1» : ⊦ wi ph (wb ps ch))
  («3anbi12d_2» : ⊦ wi ph (wb th ta)) :
  ⊦ wi ph (wb (w3a et ps th) (w3a et ch ta)) :=
@«3anbi123d» ph et et ps ch th ta
  (@biidd ph et)
  «3anbi12d_1»
  «3anbi12d_2»


/-- Deduction adding conjuncts to an equivalence. (Contributed by NM, 8-Sep-2006.) -/
theorem «3anbi1d» {ph ps ch th ta : wff}
  («3anbi1d_1» : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (w3a ps th ta) (w3a ch th ta)) :=
@«3anbi12d» ph ps ch th th ta
  «3anbi1d_1»
  (@biidd ph th)


/-- Deduction adding conjuncts to an equivalence. (Contributed by NM, 8-Sep-2006.) -/
theorem «3anbi2d» {ph ps ch th ta : wff}
  («3anbi1d_1» : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (w3a th ps ta) (w3a th ch ta)) :=
@«3anbi12d» ph th th ps ch ta
  (@biidd ph th)
  «3anbi1d_1»


/-- Deduction adding conjuncts to an equivalence. (Contributed by NM, 8-Sep-2006.) -/
theorem «3anbi3d» {ph ps ch th ta : wff}
  («3anbi1d_1» : ⊦ wi ph (wb ps ch)) :
  ⊦ wi ph (wb (w3a th ta ps) (w3a th ta ch)) :=
@«3anbi13d» ph th th ps ch ta
  (@biidd ph th)
  «3anbi1d_1»


/-- Deduction joining 3 implications to form implication of conjunctions. (Contributed by NM,
24-Feb-2005.) -/
theorem «3anim123d» {ph ps ch th ta et ze : wff}
  («3anim123d_1» : ⊦ wi ph (wi ps ch))
  («3anim123d_2» : ⊦ wi ph (wi th ta))
  («3anim123d_3» : ⊦ wi ph (wi et ze)) :
  ⊦ wi ph (wi (w3a ps th et) (w3a ch ta ze)) :=
@«3imtr4g» ph (wa (wa ps th) et) (wa (wa ch ta) ze) (w3a ps th et) (w3a ch ta ze)
  (@anim12d ph (wa ps th) (wa ch ta) et ze
    (@anim12d ph ps ch th ta
      «3anim123d_1»
      «3anim123d_2»)
    «3anim123d_3»)
  (@df_3an ps th et)
  (@df_3an ch ta ze)


/-- Deduction joining 3 implications to form implication of disjunctions. (Contributed by NM,
4-Apr-1997.) -/
theorem «3orim123d» {ph ps ch th ta et ze : wff}
  («3anim123d_1» : ⊦ wi ph (wi ps ch))
  («3anim123d_2» : ⊦ wi ph (wi th ta))
  («3anim123d_3» : ⊦ wi ph (wi et ze)) :
  ⊦ wi ph (wi (w3o ps th et) (w3o ch ta ze)) :=
@«3imtr4g» ph (wo (wo ps th) et) (wo (wo ch ta) ze) (w3o ps th et) (w3o ch ta ze)
  (@orim12d ph (wo ps th) (wo ch ta) et ze
    (@orim12d ph ps ch th ta
      «3anim123d_1»
      «3anim123d_2»)
    «3anim123d_3»)
  (@df_3or ps th et)
  (@df_3or ch ta ze)


/-- Rearrangement of 6 conjuncts. (Contributed by NM, 13-Mar-1995.) -/
theorem an6 {ph ps ch th ta et : wff} :
  ⊦ wb (wa (w3a ph ps ch) (w3a th ta et)) (w3a (wa ph th) (wa ps ta) (wa ch et)) :=
@«3bitr4i» (wa (wa (wa ph ps) ch) (wa (wa th ta) et)) (wa (wa (wa ph th) (wa ps ta)) (wa ch et)) (wa (w3a ph ps ch) (w3a th ta et)) (w3a (wa ph th) (wa ps ta) (wa ch et))
  (@bitri (wa (wa (wa ph ps) ch) (wa (wa th ta) et)) (wa (wa (wa ph ps) (wa th ta)) (wa ch et)) (wa (wa (wa ph th) (wa ps ta)) (wa ch et))
    (@an4 (wa ph ps) ch (wa th ta) et)
    (@anbi1i (wa (wa ph ps) (wa th ta)) (wa (wa ph th) (wa ps ta)) (wa ch et)
      (@an4 ph ps th ta)))
  (@anbi12i (w3a ph ps ch) (wa (wa ph ps) ch) (w3a th ta et) (wa (wa th ta) et)
    (@df_3an ph ps ch)
    (@df_3an th ta et))
  (@df_3an (wa ph th) (wa ps ta) (wa ch et))


/-- Analogue of ~ an4 for triple conjunction. (Contributed by Scott Fenton, 16-Mar-2011.) (Proof
shortened by Andrew Salmon, 25-May-2011.) -/
theorem «3an6» {ph ps ch th ta et : wff} :
  ⊦ wb (w3a (wa ph ps) (wa ch th) (wa ta et)) (wa (w3a ph ch ta) (w3a ps th et)) :=
@bicomi (wa (w3a ph ch ta) (w3a ps th et)) (w3a (wa ph ps) (wa ch th) (wa ta et))
  (@an6 ph ch ta ps th et)


/-- An inference based on modus ponens. (Contributed by NM, 21-Nov-1994.) -/
theorem mp3an1 {ph ps ch th : wff}
  (mp3an1_1 : ⊦ ph)
  (mp3an1_2 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ps ch) th :=
@mpan ph (wa ps ch) th
  mp3an1_1
  (@«3expb» ph ps ch th
    mp3an1_2)


/-- An inference based on modus ponens. (Contributed by NM, 21-Nov-1994.) -/
theorem mp3an2 {ph ps ch th : wff}
  (mp3an2_1 : ⊦ ps)
  (mp3an2_2 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph ch) th :=
@mpanl2 ph ps ch th
  mp3an2_1
  (@«3expa» ph ps ch th
    mp3an2_2)


/-- An inference based on modus ponens. (Contributed by NM, 21-Nov-1994.) -/
theorem mp3an3 {ph ps ch th : wff}
  (mp3an3_1 : ⊦ ch)
  (mp3an3_2 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph ps) th :=
@mpi (wa ph ps) ch th
  mp3an3_1
  (@«3expia» ph ps ch th
    mp3an3_2)


/-- An inference based on modus ponens. (Contributed by NM, 13-Jul-2005.) -/
theorem mp3an12 {ph ps ch th : wff}
  (mp3an12_1 : ⊦ ph)
  (mp3an12_2 : ⊦ ps)
  (mp3an12_3 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi ch th :=
@mpan ps ch th
  mp3an12_2
  (@mp3an1 ph ps ch th
    mp3an12_1
    mp3an12_3)


/-- An inference based on modus ponens. (Contributed by NM, 14-Jul-2005.) -/
theorem mp3an13 {ph ps ch th : wff}
  (mp3an13_1 : ⊦ ph)
  (mp3an13_2 : ⊦ ch)
  (mp3an13_3 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi ps th :=
@mpan ph ps th
  mp3an13_1
  (@mp3an3 ph ps ch th
    mp3an13_2
    mp3an13_3)


/-- An inference based on modus ponens. (Contributed by NM, 14-Jul-2005.) -/
theorem mp3an23 {ph ps ch th : wff}
  (mp3an23_1 : ⊦ ps)
  (mp3an23_2 : ⊦ ch)
  (mp3an23_3 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi ph th :=
@mpan2 ph ps th
  mp3an23_1
  (@mp3an3 ph ps ch th
    mp3an23_2
    mp3an23_3)


/-- An inference based on modus ponens. (Contributed by NM, 24-Feb-2005.) -/
theorem mp3anl1 {ph ps ch th ta : wff}
  (mp3anl1_1 : ⊦ ph)
  (mp3anl1_2 : ⊦ wi (wa (w3a ph ps ch) th) ta) :
  ⊦ wi (wa (wa ps ch) th) ta :=
@imp (wa ps ch) th ta
  (@mp3an1 ph ps ch (wi th ta)
    mp3anl1_1
    (@ex (w3a ph ps ch) th ta
      mp3anl1_2))


/-- An inference based on modus ponens. (Contributed by NM, 24-Feb-2005.) -/
theorem mp3anl2 {ph ps ch th ta : wff}
  (mp3anl2_1 : ⊦ ps)
  (mp3anl2_2 : ⊦ wi (wa (w3a ph ps ch) th) ta) :
  ⊦ wi (wa (wa ph ch) th) ta :=
@imp (wa ph ch) th ta
  (@mp3an2 ph ps ch (wi th ta)
    mp3anl2_1
    (@ex (w3a ph ps ch) th ta
      mp3anl2_2))


/-- An inference based on modus ponens. (Contributed by NM, 24-Nov-2006.) -/
theorem mp3anr2 {ph ps ch th ta : wff}
  (mp3anr2_1 : ⊦ ch)
  (mp3anr2_2 : ⊦ wi (wa ph (w3a ps ch th)) ta) :
  ⊦ wi (wa ph (wa ps th)) ta :=
@ancoms (wa ps th) ph ta
  (@mp3anl2 ps ch th ph ta
    mp3anr2_1
    (@ancoms ph (w3a ps ch th) ta
      mp3anr2_2))


/-- An inference based on modus ponens. (Contributed by NM, 14-May-1999.) -/
theorem mp3an {ph ps ch th : wff}
  (mp3an_1 : ⊦ ph)
  (mp3an_2 : ⊦ ps)
  (mp3an_3 : ⊦ ch)
  (mp3an_4 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ th :=
@mp2an ps ch th
  mp3an_2
  mp3an_3
  (@mp3an1 ph ps ch th
    mp3an_1
    mp3an_4)


/-- An inference based on modus ponens. (Contributed by NM, 8-Nov-2007.) -/
theorem mpd3an3 {ph ps ch th : wff}
  (mpd3an3_2 : ⊦ wi (wa ph ps) ch)
  (mpd3an3_3 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi (wa ph ps) th :=
@mpdan (wa ph ps) ch th
  mpd3an3_2
  (@«3expa» ph ps ch th
    mpd3an3_3)


/-- An inference based on modus ponens. (Contributed by NM, 4-Dec-2006.) -/
theorem mpd3an23 {ph ps ch th : wff}
  (mpd3an23_1 : ⊦ wi ph ps)
  (mpd3an23_2 : ⊦ wi ph ch)
  (mpd3an23_3 : ⊦ wi (w3a ph ps ch) th) :
  ⊦ wi ph th :=
@syl3anc ph ph ps ch th
  (@id ph)
  mpd3an23_1
  mpd3an23_2
  mpd3an23_3


/-- A deduction based on modus ponens. (Contributed by Mario Carneiro, 24-Dec-2016.) -/
theorem mp3and {ph ps ch th ta : wff}
  (mp3and_1 : ⊦ wi ph ps)
  (mp3and_2 : ⊦ wi ph ch)
  (mp3and_3 : ⊦ wi ph th)
  (mp3and_4 : ⊦ wi ph (wi (w3a ps ch th) ta)) :
  ⊦ wi ph ta :=
@mpd ph (w3a ps ch th) ta
  (@«3jca» ph ps ch th
    mp3and_1
    mp3and_2
    mp3and_3)
  mp3and_4


/-- ~ mp3an with antecedents in standard conjunction form and with one hypothesis an implication.
(Contributed by Alan Sare, 28-Aug-2016.) -/
theorem mp3an12i {ph ps ch th ta : wff}
  (mp3an12i_1 : ⊦ ph)
  (mp3an12i_2 : ⊦ ps)
  (mp3an12i_3 : ⊦ wi ch th)
  (mp3an12i_4 : ⊦ wi (w3a ph ps th) ta) :
  ⊦ wi ch ta :=
@syl ch th ta
  mp3an12i_3
  (@mp3an12 ph ps th ta
    mp3an12i_1
    mp3an12i_2
    mp3an12i_4)


/-- ~ mp3an with antecedents in standard conjunction form and with two hypotheses which are
implications. (Contributed by Alan Sare, 28-Aug-2016.) -/
theorem mp3an2i {ph ps ch th ta : wff}
  (mp3an2i_1 : ⊦ ph)
  (mp3an2i_2 : ⊦ wi ps ch)
  (mp3an2i_3 : ⊦ wi ps th)
  (mp3an2i_4 : ⊦ wi (w3a ph ch th) ta) :
  ⊦ wi ps ta :=
@syl2anc ps ch th ta
  mp3an2i_2
  mp3an2i_3
  (@mp3an1 ph ch th ta
    mp3an2i_1
    mp3an2i_4)


/-- ~ mp3an with antecedents in standard conjunction form and with two hypotheses which are
implications. (Contributed by Alan Sare, 28-Aug-2016.) -/
theorem mp3an3an {ph ps ch th ta et : wff}
  (mp3an3an_1 : ⊦ ph)
  (mp3an3an_2 : ⊦ wi ps ch)
  (mp3an3an_3 : ⊦ wi th ta)
  (mp3an3an_4 : ⊦ wi (w3a ph ch ta) et) :
  ⊦ wi (wa ps th) et :=
@syl2an ps ch ta et th
  mp3an3an_2
  mp3an3an_3
  (@mp3an1 ph ch ta et
    mp3an3an_1
    mp3an3an_4)


/-- An elimination deduction. (Contributed by Alan Sare, 17-Oct-2017.) -/
theorem mp3an2ani {ph ps ch th ta et : wff}
  (mp3an2ani_1 : ⊦ ph)
  (mp3an2ani_2 : ⊦ wi ps ch)
  (mp3an2ani_3 : ⊦ wi (wa ps th) ta)
  (mp3an2ani_4 : ⊦ wi (w3a ph ch ta) et) :
  ⊦ wi (wa ps th) et :=
@anabss5 ps th et
  (@mp3an3an ph ps ch (wa ps th) ta et
    mp3an2ani_1
    mp3an2ani_2
    mp3an2ani_3
    mp3an2ani_4)


/-- Infer implication from a logical equivalence. Similar to ~ biimpa . (Contributed by NM,
4-Sep-2005.) -/
theorem biimp3a {ph ps ch th : wff}
  (biimp3a_1 : ⊦ wi (wa ph ps) (wb ch th)) :
  ⊦ wi (w3a ph ps ch) th :=
@«3impa» ph ps ch th
  (@biimpa (wa ph ps) ch th
    biimp3a_1)


/-- Infer implication from a logical equivalence. Similar to ~ biimpar . (Contributed by NM,
2-Jan-2009.) -/
theorem biimp3ar {ph ps ch th : wff}
  (biimp3a_1 : ⊦ wi (wa ph ps) (wb ch th)) :
  ⊦ wi (w3a ph ps th) ch :=
@«3imp» ph ps th ch
  (@exbiri ph ps ch th
    biimp3a_1)


/-- Deduction for elimination by cases. (Contributed by NM, 22-Apr-1994.) -/
theorem ecase23d {ph ps ch th : wff}
  (ecase23d_1 : ⊦ wi ph (wn ch))
  (ecase23d_2 : ⊦ wi ph (wn th))
  (ecase23d_3 : ⊦ wi ph (w3o ps ch th)) :
  ⊦ wi ph ps :=
@mt3d ph ps (wo ch th)
  (@sylanbrc ph (wn ch) (wn th) (wn (wo ch th))
    ecase23d_1
    ecase23d_2
    (@ioran ch th))
  (@ord ph ps (wo ch th)
    (@sylib ph (w3o ps ch th) (wo ps (wo ch th))
      ecase23d_3
      (@«3orass» ps ch th)))

-- constant setvar : Type

-- constant setvar.proof : setvar → Prop
-- prefix `⊦ `:26 := setvar.proof
-- constant setvar.forget {p : Prop} : (setvar → p) → p

-- /-- Extend wff definition to include the universal quantifier ("for all"). ` A. x ph ` is read "
-- ` ph ` (phi) is true for all ` x ` ". Typically, in its final application ` ph ` would be
-- replaced with a wff containing a (free) occurrence of the variable ` x ` , for example ` x = y `
-- . In a universe with a finite number of objects, "for all" is equivalent to a big conjunction
-- (AND) with one wff for each possible case of ` x ` . When the universe is infinite (as with set
-- theory), such a propositional-calculus equivalent is not possible because an infinitely long
-- formula has no meaning, but conceptually the idea is the same. -/
-- constant wal : (setvar → wff) → wff

-- constant «class» : Type

-- constant «class».proof : «class» → Prop
-- prefix `⊦ `:26 := «class».proof
-- constant «class».forget {p : Prop} : («class» → p) → p

-- /-- This syntax construction states that a variable ` x ` , which has been declared to be a
-- setvar variable by $f statement vx, is also a class expression. This can be justified informally
-- as follows. We know that the class builder ` { y | y e. x } ` is a class by ~ cab . Since (when `
-- y ` is distinct from ` x ` ) we have ` x = { y | y e. x } ` by ~ cvjust , we can argue that the
-- syntax " ` class x ` " can be viewed as an abbreviation for " ` class { y | y e. x } ` ". See the
-- discussion under the definition of class in [Jech] p. 4 showing that "Every set can be considered
-- to be a class". While it is tempting and perhaps occasionally useful to view ~ cv as a "type
-- conversion" from a setvar variable to a class variable, keep in mind that ~ cv is intrinsically
-- no different from any other class-building syntax such as ~ cab , ~ cun , or ~ c0 . For a general
-- discussion of the theory of classes and the role of ~ cv , see ~ mmset.html#class . (The
-- description above applies to set theory, not predicate calculus. The purpose of introducing `
-- class x ` here, and not in set theory where it belongs, is to allow us to express, i.e., "prove",
-- the ~ weq of predicate calculus from the ~ wceq of set theory, so that we do not overload the ` =
-- ` connective with two syntax definitions. This is done to prevent ambiguity that would complicate
-- some Metamath parsers.) -/
-- constant cv : setvar → «class»


-- /-- Extend wff definition to include class equality. For a general discussion of the theory of
-- classes, see ~ mmset.html#class . (The purpose of introducing ` wff A = B ` here, and not in set
-- theory where it belongs, is to allow us to express, i.e., "prove", the ~ weq of predicate
-- calculus in terms of the ~ wceq of set theory, so that we do not "overload" the ` = ` connective
-- with two syntax definitions. This is done to prevent ambiguity that would complicate some
-- Metamath parsers. For example, some parsers - although not the Metamath program - stumble on the
-- fact that the ` = ` in ` x = y ` could be the ` = ` of either ~ weq or ~ wceq , although
-- mathematically it makes no difference. The class variables ` A ` and ` B ` are introduced
-- temporarily for the purpose of this definition but otherwise not used in predicate calculus. See
-- ~ df-cleq for more information on the set theory usage of ~ wceq .) -/
-- constant wceq : «class» → «class» → wff


-- /-- The constant ` T. ` is a wff. -/
-- constant wtru : wff


-- /-- Definition of the truth value "true", or "verum", denoted by ` T. ` . In this definition, an
-- instance of ~ id is used as the definiens, although any tautology, such as an axiom, can be used
-- in its place. This particular instance of ~ id was chosen so this definition can be checked by
-- the same algorithm that is used for predicate calculus. This definition should be referenced
-- directly only by ~ tru , and other proofs should use ~ tru instead of this definition, since
-- there are many alternate ways to define ` T. ` . (Contributed by Anthony Hart, 13-Oct-2010.)
-- (Revised by NM, 11-Jul-2019.) Use ~ tru instead. (New usage is discouraged.) -/
-- axiom df_tru : ⊦ wb wtru (wi (wal (λ x2, wceq (cv x2) (cv x2))) (wal (λ x2, wceq (cv x2) (cv x2))))


/-- The truth value ` T. ` is provable. (Contributed by Anthony Hart, 13-Oct-2010.) -/
theorem tru :
  ⊦ wtru :=
@mpbir wtru (wi (wal (λ x2, wceq (cv x2) (cv x2))) (wal (λ x2, wceq (cv x2) (cv x2))))
  (@id (wal (λ x2, wceq (cv x2) (cv x2))))
  df_tru


/-- Eliminate ` T. ` as an antecedent. A proposition implied by ` T. ` is true. This is modus ponens
~ ax-mp when the minor hypothesis is ` T. ` (which holds by ~ tru ). (Contributed by Mario Carneiro,
13-Mar-2014.) -/
theorem mptru {ph : wff}
  (mptru_1 : ⊦ wi wtru ph) :
  ⊦ ph :=
@ax_mp wtru ph
  tru
  mptru_1


/-- A theorem is equivalent to truth. (Contributed by Mario Carneiro, 9-May-2015.) -/
theorem bitru {ph : wff}
  (bitru_1 : ⊦ ph) :
  ⊦ wb ph wtru :=
@«2th» ph wtru
  bitru_1
  tru


/-- Anything implies ` T. ` . Dual statement of ~ falim . Deduction form of ~ tru . Note on naming:
in 2022, the theorem now known as ~ mptru was renamed from trud so if you are reading documentation
written before that time, references to trud refer to what is now ~ mptru . (Contributed by FL,
20-Mar-2011.) (Proof shortened by Anthony Hart, 1-Aug-2011.) -/
theorem trud {ph : wff} :
  ⊦ wi ph wtru :=
@a1i wtru ph
  tru


-- /-- The constant ` F. ` is a wff. -/
-- constant wfal : wff


-- /-- Definition of the truth value "false", or "falsum", denoted by ` F. ` . See also ~ df-tru .
-- (Contributed by Anthony Hart, 22-Oct-2010.) -/
-- axiom df_fal : ⊦ wb wfal (wn wtru)


/-- The truth value ` F. ` is refutable. (Contributed by Anthony Hart, 22-Oct-2010.) (Proof
shortened by Mel L. O'Cat, 11-Mar-2012.) -/
theorem fal :
  ⊦ wn wfal :=
@mtbir wfal (wn wtru)
  (@notnoti wtru
    tru)
  df_fal


/-- The negation of a proposition is equivalent to itself being equivalent to ` F. ` . (Contributed
by Anthony Hart, 14-Aug-2011.) -/
theorem nbfal {ph : wff} :
  ⊦ wb (wn ph) (wb ph wfal) :=
@nbn wfal ph
  fal


/-- A contradiction is equivalent to falsehood. (Contributed by Mario Carneiro, 9-May-2015.) -/
theorem bifal {ph : wff}
  (bifal_1 : ⊦ wn ph) :
  ⊦ wb ph wfal :=
@«2false» ph wfal
  bifal_1
  fal


/-- The truth value ` F. ` implies anything. Also called the "principle of explosion", or "ex falso
[[sequitur]] quodlibet" (Latin for "from falsehood, anything [[follows]]"). Dual statement of ~ trud
. (Contributed by FL, 20-Mar-2011.) (Proof shortened by Anthony Hart, 1-Aug-2011.) -/
theorem falim {ph : wff} :
  ⊦ wi wfal ph :=
@pm2_21i wfal ph
  fal


/-- Modus tollendo ponens (inclusive-or version), aka disjunctive syllogism. This is similar to ~
mtpxor , one of the five original "indemonstrables" in Stoic logic. However, in Stoic logic this
rule used exclusive-or, while the name modus tollendo ponens often refers to a variant of the rule
that uses inclusive-or instead. The rule says, "if ` ph ` is not true, and ` ph ` or ` ps ` (or
both) are true, then ` ps ` must be true". An alternate phrasing is: "once you eliminate the
impossible, whatever remains, no matter how improbable, must be the truth". -- Sherlock Holmes (Sir
Arthur Conan Doyle, 1890: The Sign of the Four, ch. 6). (Contributed by David A. Wheeler,
3-Jul-2016.) (Proof shortened by Wolf Lammen, 11-Nov-2017.) -/
theorem mtpor {ph ps : wff}
  (mtpor_min : ⊦ wn ph)
  (mtpor_max : ⊦ wo ph ps) :
  ⊦ ps :=
@ax_mp (wn ph) ps
  mtpor_min
  (@ori ph ps
    mtpor_max)


/-- Stoic logic Thema 1 (part a). The first thema of the four Stoic logic themata, in its basic
form, was: "When from two (assertibles) a third follows, then from either of them together with the
contradictory of the conclusion the contradictory of the other follows." (Apuleius Int. 209.9-14),
see [Bobzien] p. 117 and ~ https://plato.stanford.edu/entries/logic-ancient/ We will represent thema
1 as two very similar rules ~ stoic1a and ~ stoic1b to represent each side. (Contributed by David A.
Wheeler, 16-Feb-2019.) (Proof shortened by Wolf Lammen, 21-May-2020.) -/
theorem stoic1a {ph ps th : wff}
  (stoic1_1 : ⊦ wi (wa ph ps) th) :
  ⊦ wi (wa ph (wn th)) (wn ps) :=
@con3dimp ph ps th
  (@ex ph ps th
    stoic1_1)


/-- Stoic logic Thema 3. Statement T3 of [Bobzien] p. 116-117 discusses Stoic logic Thema 3. "When
from two (assemblies) a third follows, and from the one that follows (i.e., the third) together with
another, external assumption, another follows, then that other follows from the first two and the
externally co-assumed one. (Simp. Cael. 237.2-4)" (Contributed by David A. Wheeler, 17-Feb-2019.) -/
theorem stoic3 {ph ps ch th ta : wff}
  (stoic3_1 : ⊦ wi (wa ph ps) ch)
  (stoic3_2 : ⊦ wi (wa ch th) ta) :
  ⊦ wi (w3a ph ps th) ta :=
@«3impa» ph ps th ta
  (@sylan (wa ph ps) ch th ta
    stoic3_1
    stoic3_2)


/-- Stoic logic Thema 4 version a. Statement T4 of [Bobzien] p. 117 shows a reconstructed version of
Stoic logic Thema 4: "When from two assertibles a third follows, and from the third and one (or
both) of the two and one (or more) external assertible(s) another follows, then this other follows
from the first two and the external(s)." We use ` th ` to represent the "external" assertibles. This
is version a, which is without the phrase "or both"; see ~ stoic4b for the version with the phrase
"or both". (Contributed by David A. Wheeler, 17-Feb-2019.) -/
theorem stoic4a {ph ps ch th ta : wff}
  (stoic4a_1 : ⊦ wi (wa ph ps) ch)
  (stoic4a_2 : ⊦ wi (w3a ch ph th) ta) :
  ⊦ wi (w3a ph ps th) ta :=
@syl3anc (w3a ph ps th) ch ph th ta
  (@«3adant3» ph ps ch th
    stoic4a_1)
  (@simp1 ph ps th)
  (@simp3 ph ps th)
  stoic4a_2


-- /-- Extend wff definition to include the existential quantifier ("there exists"). -/
-- constant wex : (setvar → wff) → wff


-- /-- Define existential quantification. ` E. x ph ` means "there exists at least one set ` x `
-- such that ` ph ` is true". Dual of ~ alex . See also the dual pair ~ alnex / ~ exnal . Definition
-- of [Margaris] p. 49. (Contributed by NM, 10-Jan-1993.) -/
-- axiom df_ex {ph : setvar → wff} : ⊦ wb (wex (λ x3, ph x3)) (wn (wal (λ x3, wn (ph x3))))


/-- Universal quantification of negation is equivalent to negation of existential quantification.
Dual of ~ exnal (but does not depend on ~ ax-4 contrary to it). See also the dual pair ~ df-ex / ~
alex . Theorem 19.7 of [Margaris] p. 89. (Contributed by NM, 12-Mar-1993.) -/
theorem alnex {ph : setvar → wff} :
  ⊦ wb (wal (λ x3, wn (ph x3))) (wn (wex (λ x3, ph x3))) :=
@con2bii (wex (λ x3, ph x3)) (wal (λ x3, wn (ph x3)))
  (@df_ex (λ x3, ph x3))


/-- An equivalence between an implication with an existentially quantified antecedent and an
implication with a universally quantified consequent. An interesting case is when the same formula
is substituted for both ` ph ` and ` ps ` , since then both implications express a type of
nonfreeness. See also ~ alimex . (Contributed by BJ, 12-May-2019.) -/
theorem eximal {ph ps : setvar → wff}
  (x3 : setvar) : ⊦ wb (wi (wex (λ x3, ph x3)) (ps x3)) (wi (wn (ps x3)) (wal (λ x3, wn (ph x3)))) :=
@bitri (wi (wex (λ x3, ph x3)) (ps x3)) (wi (wn (wal (λ x3, wn (ph x3)))) (ps x3)) (wi (wn (ps x3)) (wal (λ x3, wn (ph x3))))
  (@imbi1i (wex (λ x3, ph x3)) (wn (wal (λ x3, wn (ph x3)))) (ps x3)
    (@df_ex (λ x3, ph x3)))
  (@con1b (wal (λ x3, wn (ph x3))) (ps x3))


-- /-- Extend wff definition to include the not-free predicate. -/
-- constant wnf : (setvar → wff) → wff


-- /-- Define the not-free predicate for wffs. This is read " ` x ` is not free in ` ph ` ".
-- Not-free means that the value of ` x ` cannot affect the value of ` ph ` , e.g., any occurrence
-- of ` x ` in ` ph ` is effectively bound by a "for all" or something that expands to one (such as
-- "there exists"). In particular, substitution for a variable not free in a wff does not affect its
-- value ( ~ sbf ). An example of where this is used is ~ stdpc5 . See ~ nf5 for an alternate
-- definition which involves nested quantifiers on the same variable. Not-free is a commonly used
-- constraint, so it is useful to have a notation for it. Surprisingly, there is no common formal
-- notation for it, so here we devise one. Our definition lets us work with the not-free notion
-- within the logic itself rather than as a metalogical side condition. To be precise, our
-- definition really means "effectively not free", because it is slightly less restrictive than the
-- usual textbook definition for "not free" (which considers syntactic freedom). For example, ` x `
-- is effectively not free in the formula ` x = x ` (even though ` x ` is syntactically free in it,
-- so would be considered free in the usual textbook definition) because the value of ` x ` in the
-- formula ` x = x ` does not affect the truth of that formula (and thus substitutions will not
-- change the result), see ~ nfequid . This definition of "not free" tightly ties to the quantifier
-- ` A. x ` . At this state (no axioms restricting quantifiers yet) "nonfree" appears quite
-- arbitrary. Its intended semantics expresses single-valuedness (constness) across a parameter, but
-- is only evolved as much as later axioms assign properties to quantifiers. It seems the definition
-- here is best suited in situations, where axioms are only partially in effect. In particular, this
-- definition more easily carries over to other logic models with weaker axiomization. The reverse
-- implication of the definiens (the right hand side of the biconditional) always holds, see ~ 19.2
-- . This predicate only applies to wffs. See ~ df-nfc for a not-free predicate for class variables.
-- (Contributed by Mario Carneiro, 24-Sep-2016.) Convert to definition. (Revised by BJ, 6-May-2019.)
-- -/
-- axiom df_nf {ph : setvar → wff} : ⊦ wb (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3)))


/-- Alternate definition of nonfreeness. (Contributed by BJ, 16-Sep-2021.) -/
theorem nf2 {ph : setvar → wff} :
  ⊦ wb (wnf (λ x3, ph x3)) (wo (wal (λ x3, ph x3)) (wn (wex (λ x3, ph x3)))) :=
@«3bitri» (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3))) (wo (wn (wex (λ x3, ph x3))) (wal (λ x3, ph x3))) (wo (wal (λ x3, ph x3)) (wn (wex (λ x3, ph x3))))
  (@df_nf (λ x3, ph x3))
  (@imor (wex (λ x3, ph x3)) (wal (λ x3, ph x3)))
  (@orcom (wn (wex (λ x3, ph x3))) (wal (λ x3, ph x3)))


/-- Alternate definition of nonfreeness. (Contributed by BJ, 16-Sep-2021.) -/
theorem nf3 {ph : setvar → wff} :
  ⊦ wb (wnf (λ x3, ph x3)) (wo (wal (λ x3, ph x3)) (wal (λ x3, wn (ph x3)))) :=
@bitr4i (wnf (λ x3, ph x3)) (wo (wal (λ x3, ph x3)) (wn (wex (λ x3, ph x3)))) (wo (wal (λ x3, ph x3)) (wal (λ x3, wn (ph x3))))
  (@nf2 (λ x3, ph x3))
  (@orbi2i (wal (λ x3, wn (ph x3))) (wn (wex (λ x3, ph x3))) (wal (λ x3, ph x3))
    (@alnex (λ x3, ph x3)))


/-- Deduce that ` x ` is not free in ` ph ` from the definition. (Contributed by Wolf Lammen,
15-Sep-2021.) -/
theorem nfi {ph : setvar → wff}
  (nfi_1 : ⊦ wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3))) :
  ⊦ wnf (λ x3, ph x3) :=
@mpbir (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3)))
  nfi_1
  (@df_nf (λ x3, ph x3))


/-- Consequence of the definition of not-free. (Contributed by Wolf Lammen, 16-Sep-2021.) -/
theorem nfri {ph : setvar → wff}
  (nfri_1 : ⊦ wnf (λ x3, ph x3)) :
  ⊦ wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3)) :=
@mpbi (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3)))
  nfri_1
  (@df_nf (λ x3, ph x3))


/-- Deduce that ` x ` is not free in ` ps ` in a context. (Contributed by Wolf Lammen, 16-Sep-2021.)
-/
theorem nfd {ph ps : setvar → wff}
  (nfd_1 : ∀ x3, ⊦ wi (ph x3) (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3))))
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, ps x3)) :=
@sylibr (ph x3) (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3))) (wnf (λ x3, ps x3))
  (nfd_1 x3)
  (@df_nf (λ x3, ps x3))


/-- Consequence of the definition of not-free in a context. (Contributed by Wolf Lammen,
15-Oct-2021.) -/
theorem nfrd {ph ps : setvar → wff}
  (nfrd_1 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3))) :=
@sylib (ph x3) (wnf (λ x3, ps x3)) (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3)))
  (nfrd_1 x3)
  (@df_nf (λ x3, ps x3))


/-- Closed form of ~ nfth . (Contributed by Wolf Lammen, 19-Aug-2018.) (Proof shortened by BJ,
16-Sep-2021.) (Proof shortened by Wolf Lammen, 3-Sep-2022.) -/
theorem nftht {ph : setvar → wff} :
  ⊦ wi (wal (λ x3, ph x3)) (wnf (λ x3, ph x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wal (λ x3, ph x3)) (wnf (λ x3, ph x3)), from
  @nfd (λ x3, wal (λ x3, ph x3)) (λ x3, ph x3)
    (λ x3, @ax_1 (wal (λ x3, ph x3)) (wex (λ x3, ph x3))) x3


-- /-- Rule of (universal) generalization. In our axiomatization, this is the only postulated (that
-- is, axiomatic) rule of inference of predicate calculus (together with the rule of modus ponens ~
-- ax-mp of propositional calculus). See, e.g., Rule 2 of [Hamilton] p. 74. This rule says that if
-- something is unconditionally true, then it is true for all values of a variable. For example, if
-- we have proved ` x = x ` , then we can conclude ` A. x x = x ` or even ` A. y x = x ` . Theorem ~
-- altru shows the special case ` A. x T. ` . The converse rule of inference ~ spi (universal
-- instantiation, or universal specialization) shows that we can also go the other way: in other
-- words, we can add or remove universal quantifiers from the beginning of any theorem as required.
-- Note that the closed form ` ( ph -> A. x ph ) ` need not hold (but may hold in special cases, see
-- ~ ax-5 ). (Contributed by NM, 3-Jan-1993.) -/
-- axiom ax_gen {ph : setvar → wff} : (∀ x3, ⊦ ph x3) → ⊦ wal (λ x3, ph x3)


/-- Generalization applied twice. (Contributed by NM, 30-Apr-1998.) -/
theorem gen2 {ph : setvar → setvar → wff}
  (gen2_1 : ∀ x3 y, ⊦ ph x3 y) :
  ⊦ wal (λ x3, wal (λ y, ph x3 y)) :=
@ax_gen (λ x3, wal (λ y, ph x3 y))
  (λ x3, @ax_gen (λ y, ph x3 y)
    (λ y, gen2_1 x3 y))


/-- Generalization applied twice. (Contributed by NM, 30-Apr-1998.) -/
theorem gen2_b {ph : setvar → wff}
  (gen2_1 : ∀ x3, ⊦ ph x3) :
  ⊦ wal (λ x3, wal (λ x3, ph x3)) :=
@ax_gen (λ x3, wal (λ x3, ph x3))
  (λ x3, @ax_gen (λ x3, ph x3)
    (λ x3, gen2_1 x3))


/-- Modus ponens combined with generalization. (Contributed by NM, 24-May-1994.) -/
theorem mpg {ph ps : setvar → wff}
  (mpg_1 : ∀ x3, ⊦ wi (wal (λ x3, ph x3)) (ps x3))
  (mpg_2 : ∀ x3, ⊦ ph x3)
  (x3 : setvar) : ⊦ ps x3 :=
@ax_mp (wal (λ x3, ph x3)) (ps x3)
  (@ax_gen (λ x3, ph x3)
    (λ x3, mpg_2 x3))
  (mpg_1 x3)


/-- Modus ponens on biconditional combined with generalization. (Contributed by NM, 24-May-1994.)
(Proof shortened by Stefan Allan, 28-Oct-2008.) -/
theorem mpgbi {ph ps : setvar → wff}
  (mpgbi_1 : ∀ x3, ⊦ wb (wal (λ x3, ph x3)) (ps x3))
  (mpgbi_2 : ∀ x3, ⊦ ph x3)
  (x3 : setvar) : ⊦ ps x3 :=
@mpbi (wal (λ x3, ph x3)) (ps x3)
  (@ax_gen (λ x3, ph x3)
    (λ x3, mpgbi_2 x3))
  (mpgbi_1 x3)


/-- Modus ponens on biconditional combined with generalization. (Contributed by NM, 24-May-1994.)
(Proof shortened by Stefan Allan, 28-Oct-2008.) -/
theorem mpgbir {ph ps : setvar → wff}
  (mpgbir_1 : ∀ x3, ⊦ wb (ph x3) (wal (λ x3, ps x3)))
  (mpgbir_2 : ∀ x3, ⊦ ps x3)
  (x3 : setvar) : ⊦ ph x3 :=
@mpbir (ph x3) (wal (λ x3, ps x3))
  (@ax_gen (λ x3, ps x3)
    (λ x3, mpgbir_2 x3))
  (mpgbir_1 x3)


/-- Generalization rule for negated wff. (Contributed by NM, 18-May-1994.) -/
theorem nex {ph : setvar → wff}
  (nex_1 : ∀ x3, ⊦ wn (ph x3)) :
  ⊦ wn (wex (λ x3, ph x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wn (wex (λ x3, ph x3)), from
  @mpgbi (λ x3, wn (ph x3)) (λ x3, wn (wex (λ x3, ph x3)))
    (λ x3, @alnex (λ x3, ph x3))
    (λ x3, nex_1 x3) x3


/-- No variable is (effectively) free in a theorem. (Contributed by Mario Carneiro, 11-Aug-2016.) ~
df-nf changed. (Revised by Wolf Lammen, 12-Sep-2021.) -/
theorem nfth {ph : setvar → wff}
  (nfth_1 : ∀ x3, ⊦ ph x3) :
  ⊦ wnf (λ x3, ph x3) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wnf (λ x3, ph x3), from
  @mpg (λ x3, ph x3) (λ x3, wnf (λ x3, ph x3))
    (λ x3, @nftht (λ x3, ph x3))
    (λ x3, nfth_1 x3) x3


/-- No variable is (effectively) free in a theorem. This and later "hypothesis-building" lemmas,
with labels starting "hb...", allow us to construct proofs of formulas of the form ` |- ( ph -> A. x
ph ) ` from smaller formulas of this form. These are useful for constructing hypotheses that state "
` x ` is (effectively) not free in ` ph ` ". (Contributed by NM, 11-May-1993.) This hb* idiom is
generally being replaced by the nf* idiom (see ~ nfth ), but keeps its interest in some cases.
(Revised by BJ, 23-Sep-2022.) -/
theorem hbth {ph : setvar → wff}
  (hbth_1 : ∀ x3, ⊦ ph x3)
  (x3 : setvar) : ⊦ wi (ph x3) (wal (λ x3, ph x3)) :=
@a1i (wal (λ x3, ph x3)) (ph x3)
  (@ax_gen (λ x3, ph x3)
    (λ x3, hbth_1 x3))


/-- The true constant has no free variables. (This can also be proven in one step with ~ nfv , but
this proof does not use ~ ax-5 .) (Contributed by Mario Carneiro, 6-Oct-2016.) -/
theorem nftru :
  ⊦ wnf (λ x3, wtru) :=
@nfth (λ x3, wtru)
  (λ x3, tru)


-- /-- Axiom of Quantified Implication. Axiom C4 of [Monk2] p. 105 and Theorem 19.20 of [Margaris]
-- p. 90. It is restated as ~ alim for labeling consistency. It should be used only by ~ alim .
-- (Contributed by NM, 21-May-2008.) Use ~ alim instead. (New usage is discouraged.) -/
-- axiom ax_4 {ph ps : setvar → wff} : ⊦ wi (wal (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3)))


/-- Restatement of Axiom ~ ax-4 , for labeling consistency. It should be the only theorem using ~
ax-4 . (Contributed by NM, 10-Jan-1993.) -/
theorem alim {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3))) :=
@ax_4 (λ x3, ph x3) (λ x3, ps x3)


/-- Inference quantifying both antecedent and consequent. (Contributed by NM, 5-Jan-1993.) -/
theorem alimi {ph ps : setvar → wff}
  (alimi_1 : ∀ x3, ⊦ wi (ph x3) (ps x3)) :
  ⊦ wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3)), from
  @mpg (λ x3, wi (ph x3) (ps x3)) (λ x3, wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3)))
    (λ x3, @alim (λ x3, ph x3) (λ x3, ps x3))
    (λ x3, alimi_1 x3) x3


/-- Inference doubly quantifying both antecedent and consequent. (Contributed by NM, 3-Feb-2005.) -/
theorem «2alimi» {ph ps : setvar → setvar → wff}
  (alimi_1 : ∀ x3 y, ⊦ wi (ph x3 y) (ps x3 y)) :
  ⊦ wi (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ x3, wal (λ y, ps x3 y))) :=
@alimi (λ x3, wal (λ y, ph x3 y)) (λ x3, wal (λ y, ps x3 y))
  (λ x3, @alimi (λ y, ph x3 y) (λ y, ps x3 y)
    (λ y, alimi_1 x3 y))


/-- Add an antecedent in a universally quantified formula. (Contributed by BJ, 6-Oct-2018.) -/
theorem ala1 {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, ph x3)) (wal (λ x3, wi (ps x3) (ph x3))) :=
@alimi (λ x3, ph x3) (λ x3, wi (ps x3) (ph x3))
  (λ x3, @ax_1 (ph x3) (ps x3))


/-- Closed form of ~ al2imi . Version of ~ alim for a nested implication. (Contributed by Alan Sare,
31-Dec-2011.) -/
theorem al2im {ph ps ch : setvar → wff} :
  ⊦ wi (wal (λ x3, wi (ph x3) (wi (ps x3) (ch x3)))) (wi (wal (λ x3, ph x3)) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3)))) :=
@syl6 (wal (λ x3, wi (ph x3) (wi (ps x3) (ch x3)))) (wal (λ x3, ph x3)) (wal (λ x3, wi (ps x3) (ch x3))) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3)))
  (@alim (λ x3, ph x3) (λ x3, wi (ps x3) (ch x3)))
  (@alim (λ x3, ps x3) (λ x3, ch x3))


/-- Inference quantifying antecedent, nested antecedent, and consequent. (Contributed by NM,
10-Jan-1993.) -/
theorem al2imi {ph ps ch : setvar → wff}
  (al2imi_1 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3))) :
  ⊦ wi (wal (λ x3, ph x3)) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wal (λ x3, ph x3)) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3))), from
  @mpg (λ x3, wi (ph x3) (wi (ps x3) (ch x3))) (λ x3, wi (wal (λ x3, ph x3)) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3))))
    (λ x3, @al2im (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3))
    (λ x3, al2imi_1 x3) x3


/-- Variant of ~ al2imi with conjunctive antecedent. (Contributed by Andrew Salmon, 8-Jun-2011.) -/
theorem alanimi {ph ps ch : setvar → wff}
  (alanimi_1 : ∀ x3, ⊦ wi (wa (ph x3) (ps x3)) (ch x3)) :
  ⊦ wi (wa (wal (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, ch x3)) :=
@imp (wal (λ x3, ph x3)) (wal (λ x3, ps x3)) (wal (λ x3, ch x3))
  (@al2imi (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, @ex (ph x3) (ps x3) (ch x3)
      (alanimi_1 x3)))


/-- Deduction form of Theorem 19.20 of [Margaris] p. 90, see ~ alim . (Contributed by NM,
4-Jan-2002.) -/
theorem alimdh {ph ps ch : setvar → wff}
  (alimdh_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (alimdh_2 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3))) :=
@syl (ph x3) (wal (λ x3, ph x3)) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3)))
  (alimdh_1 x3)
  (@al2imi (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, alimdh_2 x3))


/-- Theorem 19.15 of [Margaris] p. 90. (Contributed by NM, 24-Jan-1993.) -/
theorem albi {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wb (ph x3) (ps x3))) (wb (wal (λ x3, ph x3)) (wal (λ x3, ps x3))) :=
@impbid (wal (λ x3, wb (ph x3) (ps x3))) (wal (λ x3, ph x3)) (wal (λ x3, ps x3))
  (@al2imi (λ x3, wb (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, ps x3)
    (λ x3, @biimp (ph x3) (ps x3)))
  (@al2imi (λ x3, wb (ph x3) (ps x3)) (λ x3, ps x3) (λ x3, ph x3)
    (λ x3, @biimpr (ph x3) (ps x3)))


/-- Inference adding universal quantifier to both sides of an equivalence. (Contributed by NM,
7-Aug-1994.) -/
theorem albii {ph ps : setvar → wff}
  (albii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wal (λ x3, ph x3)) (wal (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wal (λ x3, ph x3)) (wal (λ x3, ps x3)), from
  @mpg (λ x3, wb (ph x3) (ps x3)) (λ x3, wb (wal (λ x3, ph x3)) (wal (λ x3, ps x3)))
    (λ x3, @albi (λ x3, ph x3) (λ x3, ps x3))
    (λ x3, albii_1 x3) x3


/-- Inference adding two universal quantifiers to both sides of an equivalence. (Contributed by NM,
9-Mar-1997.) -/
theorem «2albii» {ph ps : setvar → setvar → wff}
  (albii_1 : ∀ x3 y, ⊦ wb (ph x3 y) (ps x3 y)) :
  ⊦ wb (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ x3, wal (λ y, ps x3 y))) :=
@albii (λ x3, wal (λ y, ph x3 y)) (λ x3, wal (λ y, ps x3 y))
  (λ x3, @albii (λ y, ph x3 y) (λ y, ps x3 y)
    (λ y, albii_1 x3 y))


/-- A syllogism combined with generalization. Inference associated with ~ sylgt . General form of ~
alrimih . (Contributed by BJ, 4-Oct-2019.) -/
theorem sylg {ph ps ch : setvar → wff}
  (sylg_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ps x3)))
  (sylg_2 : ∀ x3, ⊦ wi (ps x3) (ch x3))
  (x3 : setvar) : ⊦ wi (ph x3) (wal (λ x3, ch x3)) :=
@syl (ph x3) (wal (λ x3, ps x3)) (wal (λ x3, ch x3))
  (sylg_1 x3)
  (@alimi (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, sylg_2 x3))


/-- Inference form of Theorem 19.21 of [Margaris] p. 90. See ~ 19.21 and ~ 19.21h . Instance of ~
sylg . (Contributed by NM, 9-Jan-1993.) (Revised by BJ, 31-Mar-2021.) -/
theorem alrimih {ph ps : setvar → wff}
  (alrimih_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (alrimih_2 : ∀ x3, ⊦ wi (ph x3) (ps x3))
  (x3 : setvar) : ⊦ wi (ph x3) (wal (λ x3, ps x3)) :=
@sylg (λ x3, ph x3) (λ x3, ph x3) (λ x3, ps x3)
  (λ x3, alrimih_1 x3)
  (λ x3, alrimih_2 x3) x3


/-- A utility lemma to transfer a bound-variable hypothesis builder into a definition. See ~ hbxfreq
for equality version. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem hbxfrbi {ph ps : setvar → wff}
  (hbxfrbi_1 : ∀ x3, ⊦ wb (ph x3) (ps x3))
  (hbxfrbi_2 : ∀ x3, ⊦ wi (ps x3) (wal (λ x3, ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wal (λ x3, ph x3)) :=
@«3imtr4i» (ps x3) (wal (λ x3, ps x3)) (ph x3) (wal (λ x3, ph x3))
  (hbxfrbi_2 x3)
  (hbxfrbi_1 x3)
  (@albii (λ x3, ph x3) (λ x3, ps x3)
    (λ x3, hbxfrbi_1 x3))


/-- Universal quantifier in terms of existential quantifier and negation. Dual of ~ df-ex . See also
the dual pair ~ alnex / ~ exnal . Theorem 19.6 of [Margaris] p. 89. (Contributed by NM,
12-Mar-1993.) -/
theorem alex {ph : setvar → wff} :
  ⊦ wb (wal (λ x3, ph x3)) (wn (wex (λ x3, wn (ph x3)))) :=
@bitri (wal (λ x3, ph x3)) (wal (λ x3, wn (wn (ph x3)))) (wn (wex (λ x3, wn (ph x3))))
  (@albii (λ x3, ph x3) (λ x3, wn (wn (ph x3)))
    (λ x3, @notnotb (ph x3)))
  (@alnex (λ x3, wn (ph x3)))


/-- Existential quantification of negation is equivalent to negation of universal quantification.
Dual of ~ alnex . See also the dual pair ~ df-ex / ~ alex . Theorem 19.14 of [Margaris] p. 90.
(Contributed by NM, 12-Mar-1993.) -/
theorem exnal {ph : setvar → wff} :
  ⊦ wb (wex (λ x3, wn (ph x3))) (wn (wal (λ x3, ph x3))) :=
@con2bii (wal (λ x3, ph x3)) (wex (λ x3, wn (ph x3)))
  (@alex (λ x3, ph x3))


/-- Part of theorem *11.5 in [WhiteheadRussell] p. 164. (Contributed by Andrew Salmon, 24-May-2011.)
-/
theorem «2nalexn» {ph : setvar → setvar → wff} :
  ⊦ wb (wn (wal (λ x3, wal (λ y, ph x3 y)))) (wex (λ x3, wex (λ y, wn (ph x3 y)))) :=
@bicomi (wex (λ x3, wex (λ y, wn (ph x3 y)))) (wn (wal (λ x3, wal (λ y, ph x3 y))))
  (@xchbinxr (wex (λ x3, wex (λ y, wn (ph x3 y)))) (wal (λ x3, wn (wex (λ y, wn (ph x3 y))))) (wal (λ x3, wal (λ y, ph x3 y)))
    (@df_ex (λ x3, wex (λ y, wn (ph x3 y))))
    (@albii (λ x3, wal (λ y, ph x3 y)) (λ x3, wn (wex (λ y, wn (ph x3 y))))
      (λ x3, @alex (λ y, ph x3 y))))


/-- Theorem *11.22 in [WhiteheadRussell] p. 160. (Contributed by Andrew Salmon, 24-May-2011.) -/
theorem «2exnaln» {ph : setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, ph x3 y))) (wn (wal (λ x3, wal (λ y, wn (ph x3 y))))) :=
@xchbinxr (wex (λ x3, wex (λ y, ph x3 y))) (wal (λ x3, wn (wex (λ y, ph x3 y)))) (wal (λ x3, wal (λ y, wn (ph x3 y))))
  (@df_ex (λ x3, wex (λ y, ph x3 y)))
  (@albii (λ x3, wal (λ y, wn (ph x3 y))) (λ x3, wn (wex (λ y, ph x3 y)))
    (λ x3, @alnex (λ y, ph x3 y)))


/-- Theorem *11.22 in [WhiteheadRussell] p. 160. (Contributed by Andrew Salmon, 24-May-2011.) -/
theorem «2exnaln_b» {ph : setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ x3, ph x3))) (wn (wal (λ x3, wal (λ x3, wn (ph x3))))) :=
@xchbinxr (wex (λ x3, wex (λ x3, ph x3))) (wal (λ x3, wn (wex (λ x3, ph x3)))) (wal (λ x3, wal (λ x3, wn (ph x3))))
  (@df_ex (λ x3, wex (λ x3, ph x3)))
  (@albii (λ x3, wal (λ x3, wn (ph x3))) (λ x3, wn (wex (λ x3, ph x3)))
    (λ x3, @alnex (λ x3, ph x3)))


/-- A variant of ~ al2imi : instead of applying ` A. x ` quantifiers to the final implication,
replace them with ` E. x ` . A shorter proof is possible using ~ nfa1 , ~ sps and ~ eximd , but it
depends on more axioms. (Contributed by Wolf Lammen, 18-Aug-2019.) -/
theorem aleximi {ph ps ch : setvar → wff}
  (aleximi_1 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3))) :
  ⊦ wi (wal (λ x3, ph x3)) (wi (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
@con4d (wal (λ x3, ph x3)) (wex (λ x3, ch x3)) (wex (λ x3, ps x3))
  (@«3imtr3g» (wal (λ x3, ph x3)) (wal (λ x3, wn (ch x3))) (wal (λ x3, wn (ps x3))) (wn (wex (λ x3, ch x3))) (wn (wex (λ x3, ps x3)))
    (@al2imi (λ x3, ph x3) (λ x3, wn (ch x3)) (λ x3, wn (ps x3))
      (λ x3, @con3d (ph x3) (ps x3) (ch x3)
        (aleximi_1 x3)))
    (@alnex (λ x3, ch x3))
    (@alnex (λ x3, ps x3)))


/-- Biconditional form of ~ aleximi . (Contributed by BJ, 16-Nov-2020.) -/
theorem alexbii {ph ps ch : setvar → wff}
  (alexbii_1 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3))) :
  ⊦ wi (wal (λ x3, ph x3)) (wb (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
@impbid (wal (λ x3, ph x3)) (wex (λ x3, ps x3)) (wex (λ x3, ch x3))
  (@aleximi (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, @biimpd (ph x3) (ps x3) (ch x3)
      (alexbii_1 x3)))
  (@aleximi (λ x3, ph x3) (λ x3, ch x3) (λ x3, ps x3)
    (λ x3, @biimprd (ph x3) (ps x3) (ch x3)
      (alexbii_1 x3)))


/-- Theorem 19.22 of [Margaris] p. 90. (Contributed by NM, 10-Jan-1993.) (Proof shortened by Wolf
Lammen, 4-Jul-2014.) -/
theorem exim {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wi (ph x3) (ps x3))) (wi (wex (λ x3, ph x3)) (wex (λ x3, ps x3))) :=
@aleximi (λ x3, wi (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, ps x3)
  (λ x3, @id (wi (ph x3) (ps x3)))


/-- Inference adding existential quantifier to antecedent and consequent. (Contributed by NM,
10-Jan-1993.) -/
theorem eximi {ph ps : setvar → wff}
  (eximi_1 : ∀ x3, ⊦ wi (ph x3) (ps x3)) :
  ⊦ wi (wex (λ x3, ph x3)) (wex (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wex (λ x3, ph x3)) (wex (λ x3, ps x3)), from
  @mpg (λ x3, wi (ph x3) (ps x3)) (λ x3, wi (wex (λ x3, ph x3)) (wex (λ x3, ps x3)))
    (λ x3, @exim (λ x3, ph x3) (λ x3, ps x3))
    (λ x3, eximi_1 x3) x3


/-- Inference adding two existential quantifiers to antecedent and consequent. (Contributed by NM,
3-Feb-2005.) -/
theorem «2eximi» {ph ps : setvar → setvar → wff}
  (eximi_1 : ∀ x3 y, ⊦ wi (ph x3 y) (ps x3 y)) :
  ⊦ wi (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ x3, wex (λ y, ps x3 y))) :=
@eximi (λ x3, wex (λ y, ph x3 y)) (λ x3, wex (λ y, ps x3 y))
  (λ x3, @eximi (λ y, ph x3 y) (λ y, ps x3 y)
    (λ y, eximi_1 x3 y))


/-- Inference associated with ~ eximi . (Contributed by BJ, 3-Feb-2018.) -/
theorem eximii {ph ps : setvar → wff}
  (eximii_1 : ⊦ wex (λ x3, ph x3))
  (eximii_2 : ∀ x3, ⊦ wi (ph x3) (ps x3)) :
  ⊦ wex (λ x3, ps x3) :=
@ax_mp (wex (λ x3, ph x3)) (wex (λ x3, ps x3))
  eximii_1
  (@eximi (λ x3, ph x3) (λ x3, ps x3)
    (λ x3, eximii_2 x3))


/-- Add an antecedent in an existentially quantified formula. (Contributed by BJ, 6-Oct-2018.) -/
theorem exa1 {ph ps : setvar → wff} :
  ⊦ wi (wex (λ x3, ph x3)) (wex (λ x3, wi (ps x3) (ph x3))) :=
@eximi (λ x3, ph x3) (λ x3, wi (ps x3) (ph x3))
  (λ x3, @ax_1 (ph x3) (ps x3))


/-- Theorem 19.38 of [Margaris] p. 90. The converse holds under nonfreeness conditions, see ~ 19.38a
and ~ 19.38b . (Contributed by NM, 12-Mar-1993.) Allow a shortening of ~ 19.21t . (Revised by Wolf
Lammen, 2-Jan-2018.) -/
theorem «19_38» {ph ps : setvar → wff} :
  ⊦ wi (wi (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, wi (ph x3) (ps x3))) :=
@ja (wex (λ x3, ph x3)) (wal (λ x3, ps x3)) (wal (λ x3, wi (ph x3) (ps x3)))
  (@sylbir (wn (wex (λ x3, ph x3))) (wal (λ x3, wn (ph x3))) (wal (λ x3, wi (ph x3) (ps x3)))
    (@alnex (λ x3, ph x3))
    (@alimi (λ x3, wn (ph x3)) (λ x3, wi (ph x3) (ps x3))
      (λ x3, @pm2_21 (ph x3) (ps x3))))
  (@ala1 (λ x3, ps x3) (λ x3, ph x3))


/-- Under a nonfreeness hypothesis, the implication ~ 19.38 can be strengthened to an equivalence.
See also ~ 19.38b . (Contributed by BJ, 3-Nov-2021.) (Proof shortened by Wolf Lammen, 9-Jul-2022.)
-/
theorem «19_38a» {ph ps : setvar → wff} :
  ⊦ wi (wnf (λ x3, ph x3)) (wb (wi (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, wi (ph x3) (ps x3)))) :=
@impbid2 (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, wi (ph x3) (ps x3)))
  (@«19_38» (λ x3, ph x3) (λ x3, ps x3))
  (@syl9 (wnf (λ x3, ph x3)) (wex (λ x3, ph x3)) (wal (λ x3, ph x3)) (wal (λ x3, wi (ph x3) (ps x3))) (wal (λ x3, ps x3))
    (setvar.forget $ λ x3 : setvar,
      show ⊦ wi (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3))), from
      @nfrd (λ x3, wnf (λ x3, ph x3)) (λ x3, ph x3)
        (λ x3, @id (wnf (λ x3, ph x3))) x3)
    (@alim (λ x3, ph x3) (λ x3, ps x3)))


/-- Under a nonfreeness hypothesis, the implication ~ 19.38 can be strengthened to an equivalence.
See also ~ 19.38a . (Contributed by BJ, 3-Nov-2021.) (Proof shortened by Wolf Lammen, 9-Jul-2022.)
-/
theorem «19_38b» {ph ps : setvar → wff} :
  ⊦ wi (wnf (λ x3, ps x3)) (wb (wi (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, wi (ph x3) (ps x3)))) :=
@impbid2 (wnf (λ x3, ps x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, wi (ph x3) (ps x3)))
  (@«19_38» (λ x3, ph x3) (λ x3, ps x3))
  (@syl9r (wal (λ x3, wi (ph x3) (ps x3))) (wex (λ x3, ph x3)) (wex (λ x3, ps x3)) (wnf (λ x3, ps x3)) (wal (λ x3, ps x3))
    (@exim (λ x3, ph x3) (λ x3, ps x3))
    (setvar.forget $ λ x3 : setvar,
      show ⊦ wi (wnf (λ x3, ps x3)) (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3))), from
      @nfrd (λ x3, wnf (λ x3, ps x3)) (λ x3, ps x3)
        (λ x3, @id (wnf (λ x3, ps x3))) x3))


/-- Quantified implication in terms of quantified negation of conjunction. (Contributed by BJ,
16-Jul-2021.) -/
theorem imnang {ph ps : setvar → wff} :
  ⊦ wb (wal (λ x3, wi (ph x3) (wn (ps x3)))) (wal (λ x3, wn (wa (ph x3) (ps x3)))) :=
@albii (λ x3, wi (ph x3) (wn (ps x3))) (λ x3, wn (wa (ph x3) (ps x3)))
  (λ x3, @imnan (ph x3) (ps x3))


/-- A transformation of quantifiers and logical connectives. (Contributed by NM, 19-Aug-1993.) -/
theorem alinexa {ph ps : setvar → wff} :
  ⊦ wb (wal (λ x3, wi (ph x3) (wn (ps x3)))) (wn (wex (λ x3, wa (ph x3) (ps x3)))) :=
@bitri (wal (λ x3, wi (ph x3) (wn (ps x3)))) (wal (λ x3, wn (wa (ph x3) (ps x3)))) (wn (wex (λ x3, wa (ph x3) (ps x3))))
  (@imnang (λ x3, ph x3) (λ x3, ps x3))
  (@alnex (λ x3, wa (ph x3) (ps x3)))


/-- Existential quantification of a conjunction expressed with only primitive symbols ( ` -> ` , `
-. ` , ` A. ` ). (Contributed by NM, 10-May-1993.) State the most general instance. (Revised by BJ,
29-Sep-2019.) -/
theorem exnalimn {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wa (ph x3) (ps x3))) (wn (wal (λ x3, wi (ph x3) (wn (ps x3))))) :=
@con2bii (wal (λ x3, wi (ph x3) (wn (ps x3)))) (wex (λ x3, wa (ph x3) (ps x3)))
  (@alinexa (λ x3, ph x3) (λ x3, ps x3))


/-- A relationship between two quantifiers and negation. (Contributed by NM, 18-Aug-1993.) -/
theorem alexn {ph : setvar → setvar → wff} :
  ⊦ wb (wal (λ x3, wex (λ y, wn (ph x3 y)))) (wn (wex (λ x3, wal (λ y, ph x3 y)))) :=
@bitri (wal (λ x3, wex (λ y, wn (ph x3 y)))) (wal (λ x3, wn (wal (λ y, ph x3 y)))) (wn (wex (λ x3, wal (λ y, ph x3 y))))
  (@albii (λ x3, wex (λ y, wn (ph x3 y))) (λ x3, wn (wal (λ y, ph x3 y)))
    (λ x3, @exnal (λ y, ph x3 y)))
  (@alnex (λ x3, wal (λ y, ph x3 y)))


/-- Theorem 19.18 of [Margaris] p. 90. (Contributed by NM, 12-Mar-1993.) -/
theorem exbi {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wb (ph x3) (ps x3))) (wb (wex (λ x3, ph x3)) (wex (λ x3, ps x3))) :=
@alexbii (λ x3, wb (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, ps x3)
  (λ x3, @id (wb (ph x3) (ps x3)))


/-- Inference adding existential quantifier to both sides of an equivalence. (Contributed by NM,
24-May-1994.) -/
theorem exbii {ph ps : setvar → wff}
  (exbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wex (λ x3, ph x3)) (wex (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wex (λ x3, ph x3)) (wex (λ x3, ps x3)), from
  @mpg (λ x3, wb (ph x3) (ps x3)) (λ x3, wb (wex (λ x3, ph x3)) (wex (λ x3, ps x3)))
    (λ x3, @exbi (λ x3, ph x3) (λ x3, ps x3))
    (λ x3, exbii_1 x3) x3


/-- Inference adding two existential quantifiers to both sides of an equivalence. (Contributed by
NM, 16-Mar-1995.) -/
theorem «2exbii» {ph ps : setvar → setvar → wff}
  («2exbii_1» : ∀ x3 y, ⊦ wb (ph x3 y) (ps x3 y)) :
  ⊦ wb (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ x3, wex (λ y, ps x3 y))) :=
@exbii (λ x3, wex (λ y, ph x3 y)) (λ x3, wex (λ y, ps x3 y))
  (λ x3, @exbii (λ y, ph x3 y) (λ y, ps x3 y)
    (λ y, «2exbii_1» x3 y))


/-- Inference adding three existential quantifiers to both sides of an equivalence. (Contributed by
NM, 2-May-1995.) -/
theorem «3exbii» {ph ps : setvar → setvar → setvar → wff}
  («3exbii_1» : ∀ x3 y z, ⊦ wb (ph x3 y z) (ps x3 y z)) :
  ⊦ wb (wex (λ x3, wex (λ y, wex (λ z, ph x3 y z)))) (wex (λ x3, wex (λ y, wex (λ z, ps x3 y z)))) :=
@«2exbii» (λ x3 y, wex (λ z, ph x3 y z)) (λ x3 y, wex (λ z, ps x3 y z))
  (λ x3 y, @exbii (λ z, ph x3 y z) (λ z, ps x3 y z)
    (λ z, «3exbii_1» x3 y z))


/-- Equivalence theorem for the nonfreeness predicate. Closed form of ~ nfbii . (Contributed by
Giovanni Mascellani, 10-Apr-2018.) Reduce axiom usage. (Revised by BJ, 6-May-2019.) -/
theorem nfbiit {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wb (ph x3) (ps x3))) (wb (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3))) :=
@«3bitr4g» (wal (λ x3, wb (ph x3) (ps x3))) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3))) (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3))) (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3))
  (@imbi12d (wal (λ x3, wb (ph x3) (ps x3))) (wex (λ x3, ph x3)) (wex (λ x3, ps x3)) (wal (λ x3, ph x3)) (wal (λ x3, ps x3))
    (@exbi (λ x3, ph x3) (λ x3, ps x3))
    (@albi (λ x3, ph x3) (λ x3, ps x3)))
  (@df_nf (λ x3, ph x3))
  (@df_nf (λ x3, ps x3))


/-- Equality theorem for the nonfreeness predicate. (Contributed by Mario Carneiro, 11-Aug-2016.) ~
df-nf changed. (Revised by Wolf Lammen, 12-Sep-2021.) -/
theorem nfbii {ph ps : setvar → wff}
  (nfbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3)), from
  @mpg (λ x3, wb (ph x3) (ps x3)) (λ x3, wb (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3)))
    (λ x3, @nfbiit (λ x3, ph x3) (λ x3, ps x3))
    (λ x3, nfbii_1 x3) x3


/-- A utility lemma to transfer a bound-variable hypothesis builder into a definition. (Contributed
by Mario Carneiro, 11-Aug-2016.) -/
theorem nfxfr {ph ps : setvar → wff}
  (nfbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3))
  (nfxfr_2 : ⊦ wnf (λ x3, ps x3)) :
  ⊦ wnf (λ x3, ph x3) :=
@mpbir (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3))
  nfxfr_2
  (@nfbii (λ x3, ph x3) (λ x3, ps x3)
    (λ x3, nfbii_1 x3))


/-- A utility lemma to transfer a bound-variable hypothesis builder into a definition. (Contributed
by Mario Carneiro, 24-Sep-2016.) -/
theorem nfxfrd {ph ps ch : setvar → wff}
  (nfbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3))
  (nfxfrd_2 : ∀ x3, ⊦ wi (ch x3) (wnf (λ x3, ps x3)))
  (x3 : setvar) : ⊦ wi (ch x3) (wnf (λ x3, ph x3)) :=
@sylibr (ch x3) (wnf (λ x3, ps x3)) (wnf (λ x3, ph x3))
  (nfxfrd_2 x3)
  (@nfbii (λ x3, ph x3) (λ x3, ps x3)
    (λ x3, nfbii_1 x3))


/-- A variable is nonfree in a proposition if and only if it is so in its negation. (Contributed by
BJ, 6-May-2019.) -/
theorem nfnbi {ph : setvar → wff} :
  ⊦ wb (wnf (λ x3, ph x3)) (wnf (λ x3, wn (ph x3))) :=
@«3bitr4i» (wo (wal (λ x3, ph x3)) (wal (λ x3, wn (ph x3)))) (wo (wal (λ x3, wn (ph x3))) (wal (λ x3, ph x3))) (wnf (λ x3, ph x3)) (wnf (λ x3, wn (ph x3)))
  (@orcom (wal (λ x3, ph x3)) (wal (λ x3, wn (ph x3))))
  (@nf3 (λ x3, ph x3))
  (@bitr4i (wnf (λ x3, wn (ph x3))) (wo (wal (λ x3, wn (ph x3))) (wal (λ x3, wn (wn (ph x3))))) (wo (wal (λ x3, wn (ph x3))) (wal (λ x3, ph x3)))
    (@nf3 (λ x3, wn (ph x3)))
    (@orbi2i (wal (λ x3, ph x3)) (wal (λ x3, wn (wn (ph x3)))) (wal (λ x3, wn (ph x3)))
      (@albii (λ x3, ph x3) (λ x3, wn (wn (ph x3)))
        (λ x3, @notnotb (ph x3)))))


/-- If a variable is nonfree in a proposition, then it is nonfree in its negation. (Contributed by
Mario Carneiro, 24-Sep-2016.) (Proof shortened by Wolf Lammen, 28-Dec-2017.) (Revised by BJ,
24-Jul-2019.) ~ df-nf changed. (Revised by Wolf Lammen, 4-Oct-2021.) -/
theorem nfnt {ph : setvar → wff} :
  ⊦ wi (wnf (λ x3, ph x3)) (wnf (λ x3, wn (ph x3))) :=
@biimpi (wnf (λ x3, ph x3)) (wnf (λ x3, wn (ph x3)))
  (@nfnbi (λ x3, ph x3))


/-- Inference associated with ~ nfnt . (Contributed by Mario Carneiro, 11-Aug-2016.) ~ df-nf
changed. (Revised by Wolf Lammen, 18-Sep-2021.) -/
theorem nfn {ph : setvar → wff}
  (nfn_1 : ⊦ wnf (λ x3, ph x3)) :
  ⊦ wnf (λ x3, wn (ph x3)) :=
@ax_mp (wnf (λ x3, ph x3)) (wnf (λ x3, wn (ph x3)))
  nfn_1
  (@nfnt (λ x3, ph x3))


/-- Deduction associated with ~ nfnt . (Contributed by Mario Carneiro, 24-Sep-2016.) -/
theorem nfnd {ph ps : setvar → wff}
  (nfnd_1 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, wn (ps x3))) :=
@syl (ph x3) (wnf (λ x3, ps x3)) (wnf (λ x3, wn (ps x3)))
  (nfnd_1 x3)
  (@nfnt (λ x3, ps x3))


/-- A transformation of quantifiers and logical connectives. (Contributed by NM, 25-Mar-1996.)
(Proof shortened by Wolf Lammen, 4-Sep-2014.) -/
theorem exanali {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wa (ph x3) (wn (ps x3)))) (wn (wal (λ x3, wi (ph x3) (ps x3)))) :=
@bitri (wex (λ x3, wa (ph x3) (wn (ps x3)))) (wex (λ x3, wn (wi (ph x3) (ps x3)))) (wn (wal (λ x3, wi (ph x3) (ps x3))))
  (@exbii (λ x3, wa (ph x3) (wn (ps x3))) (λ x3, wn (wi (ph x3) (ps x3)))
    (λ x3, @annim (ph x3) (ps x3)))
  (@exnal (λ x3, wi (ph x3) (ps x3)))


/-- Commutation of conjunction inside an existential quantifier. (Contributed by NM, 18-Aug-1993.)
-/
theorem exancom {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wa (ph x3) (ps x3))) (wex (λ x3, wa (ps x3) (ph x3))) :=
@exbii (λ x3, wa (ph x3) (ps x3)) (λ x3, wa (ps x3) (ph x3))
  (λ x3, @ancom (ph x3) (ps x3))


/-- Place a conjunct in the scope of an existential quantifier. (Contributed by NM, 18-Aug-1993.)
(Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 13-Jan-2018.)
Reduce axiom dependencies. (Revised by BJ, 7-Jul-2021.) (Proof shortened by Wolf Lammen,
6-Nov-2022.) Expand hypothesis. (Revised by Steven Nguyen, 19-Jun-2023.) -/
theorem exan {ph ps : setvar → wff}
  (exan_1 : ⊦ wex (λ x3, ph x3))
  (exan_2 : ∀ x3, ⊦ ps x3) :
  ⊦ wex (λ x3, wa (ph x3) (ps x3)) :=
@eximii (λ x3, ph x3) (λ x3, wa (ph x3) (ps x3))
  exan_1
  (λ x3, @jctr (ph x3) (ps x3)
    (exan_2 x3))


/-- Deduction form of Theorem 19.21 of [Margaris] p. 90, see ~ 19.21 and ~ 19.21h . (Contributed by
NM, 10-Feb-1997.) (Proof shortened by Andrew Salmon, 13-May-2011.) -/
theorem alrimdh {ph ps ch : setvar → wff}
  (alrimdh_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (alrimdh_2 : ∀ x3, ⊦ wi (ps x3) (wal (λ x3, ps x3)))
  (alrimdh_3 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (ps x3) (wal (λ x3, ch x3))) :=
@syl5 (ps x3) (wal (λ x3, ps x3)) (ph x3) (wal (λ x3, ch x3))
  (alrimdh_2 x3)
  (@alimdh (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, alrimdh_1 x3)
    (λ x3, alrimdh_3 x3) x3)


/-- Deduction from Theorem 19.22 of [Margaris] p. 90. (Contributed by NM, 20-May-1996.) -/
theorem eximdh {ph ps ch : setvar → wff}
  (eximdh_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (eximdh_2 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
@syl (ph x3) (wal (λ x3, ph x3)) (wi (wex (λ x3, ps x3)) (wex (λ x3, ch x3)))
  (eximdh_1 x3)
  (@aleximi (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, eximdh_2 x3))


/-- Deduction for generalization rule for negated wff. (Contributed by NM, 2-Jan-2002.) -/
theorem nexdh {ph ps : setvar → wff}
  (nexdh_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (nexdh_2 : ∀ x3, ⊦ wi (ph x3) (wn (ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wn (wex (λ x3, ps x3))) :=
@sylib (ph x3) (wal (λ x3, wn (ps x3))) (wn (wex (λ x3, ps x3)))
  (@alrimih (λ x3, ph x3) (λ x3, wn (ps x3))
    (λ x3, nexdh_1 x3)
    (λ x3, nexdh_2 x3) x3)
  (@alnex (λ x3, ps x3))


/-- Formula-building rule for universal quantifier (deduction form). (Contributed by NM,
26-May-1993.) -/
theorem albidh {ph ps ch : setvar → wff}
  (albidh_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (albidh_2 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wal (λ x3, ps x3)) (wal (λ x3, ch x3))) :=
@syl (ph x3) (wal (λ x3, wb (ps x3) (ch x3))) (wb (wal (λ x3, ps x3)) (wal (λ x3, ch x3)))
  (@alrimih (λ x3, ph x3) (λ x3, wb (ps x3) (ch x3))
    (λ x3, albidh_1 x3)
    (λ x3, albidh_2 x3) x3)
  (@albi (λ x3, ps x3) (λ x3, ch x3))


/-- Formula-building rule for existential quantifier (deduction form). (Contributed by NM,
26-May-1993.) -/
theorem exbidh {ph ps ch : setvar → wff}
  (exbidh_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (exbidh_2 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
@syl (ph x3) (wal (λ x3, ph x3)) (wb (wex (λ x3, ps x3)) (wex (λ x3, ch x3)))
  (exbidh_1 x3)
  (@alexbii (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, exbidh_2 x3))


/-- Simplification of an existentially quantified conjunction. (Contributed by Rodolfo Medina,
25-Sep-2010.) (Proof shortened by Andrew Salmon, 29-Jun-2011.) -/
theorem exsimpl {ph ps : setvar → wff} :
  ⊦ wi (wex (λ x3, wa (ph x3) (ps x3))) (wex (λ x3, ph x3)) :=
@eximi (λ x3, wa (ph x3) (ps x3)) (λ x3, ph x3)
  (λ x3, @simpl (ph x3) (ps x3))


/-- Simplification of an existentially quantified conjunction. (Contributed by Rodolfo Medina,
25-Sep-2010.) (Proof shortened by Andrew Salmon, 29-Jun-2011.) -/
theorem exsimpr {ph ps : setvar → wff} :
  ⊦ wi (wex (λ x3, wa (ph x3) (ps x3))) (wex (λ x3, ps x3)) :=
@eximi (λ x3, wa (ph x3) (ps x3)) (λ x3, ps x3)
  (λ x3, @simpr (ph x3) (ps x3))


/-- Theorem 19.26 of [Margaris] p. 90. Also Theorem *10.22 of [WhiteheadRussell] p. 147.
(Contributed by NM, 12-Mar-1993.) (Proof shortened by Wolf Lammen, 4-Jul-2014.) -/
theorem «19_26» {ph ps : setvar → wff} :
  ⊦ wb (wal (λ x3, wa (ph x3) (ps x3))) (wa (wal (λ x3, ph x3)) (wal (λ x3, ps x3))) :=
@impbii (wal (λ x3, wa (ph x3) (ps x3))) (wa (wal (λ x3, ph x3)) (wal (λ x3, ps x3)))
  (@jca (wal (λ x3, wa (ph x3) (ps x3))) (wal (λ x3, ph x3)) (wal (λ x3, ps x3))
    (@alimi (λ x3, wa (ph x3) (ps x3)) (λ x3, ph x3)
      (λ x3, @simpl (ph x3) (ps x3)))
    (@alimi (λ x3, wa (ph x3) (ps x3)) (λ x3, ps x3)
      (λ x3, @simpr (ph x3) (ps x3))))
  (@alanimi (λ x3, ph x3) (λ x3, ps x3) (λ x3, wa (ph x3) (ps x3))
    (λ x3, @id (wa (ph x3) (ps x3))))


/-- Theorem 19.29 of [Margaris] p. 90. See also ~ 19.29r . (Contributed by NM, 21-Jun-1993.) (Proof
shortened by Andrew Salmon, 13-May-2011.) -/
theorem «19_29» {ph ps : setvar → wff} :
  ⊦ wi (wa (wal (λ x3, ph x3)) (wex (λ x3, ps x3))) (wex (λ x3, wa (ph x3) (ps x3))) :=
@imp (wal (λ x3, ph x3)) (wex (λ x3, ps x3)) (wex (λ x3, wa (ph x3) (ps x3)))
  (@aleximi (λ x3, ph x3) (λ x3, ps x3) (λ x3, wa (ph x3) (ps x3))
    (λ x3, @pm3_2 (ph x3) (ps x3)))


/-- Variation of ~ 19.29 . (Contributed by NM, 18-Aug-1993.) (Proof shortened by Wolf Lammen,
12-Nov-2020.) -/
theorem «19_29r» {ph ps : setvar → wff} :
  ⊦ wi (wa (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wex (λ x3, wa (ph x3) (ps x3))) :=
@impcom (wal (λ x3, ps x3)) (wex (λ x3, ph x3)) (wex (λ x3, wa (ph x3) (ps x3)))
  (@aleximi (λ x3, ps x3) (λ x3, ph x3) (λ x3, wa (ph x3) (ps x3))
    (λ x3, @pm3_21 (ps x3) (ph x3)))


/-- Theorem 19.35 of [Margaris] p. 90. This theorem is useful for moving an implication (in the form
of the right-hand side) into the scope of a single existential quantifier. (Contributed by NM,
12-Mar-1993.) (Proof shortened by Wolf Lammen, 27-Jun-2014.) -/
theorem «19_35» {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (wex (λ x3, ps x3))) :=
@impbii (wex (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (wex (λ x3, ps x3)))
  (@com12 (wal (λ x3, ph x3)) (wex (λ x3, wi (ph x3) (ps x3))) (wex (λ x3, ps x3))
    (@aleximi (λ x3, ph x3) (λ x3, wi (ph x3) (ps x3)) (λ x3, ps x3)
      (λ x3, @pm2_27 (ph x3) (ps x3))))
  (@ja (wal (λ x3, ph x3)) (wex (λ x3, ps x3)) (wex (λ x3, wi (ph x3) (ps x3)))
    (@sylbir (wn (wal (λ x3, ph x3))) (wex (λ x3, wn (ph x3))) (wex (λ x3, wi (ph x3) (ps x3)))
      (@exnal (λ x3, ph x3))
      (@eximi (λ x3, wn (ph x3)) (λ x3, wi (ph x3) (ps x3))
        (λ x3, @pm2_21 (ph x3) (ps x3))))
    (@exa1 (λ x3, ps x3) (λ x3, ph x3)))


/-- Inference associated with ~ 19.35 . (Contributed by NM, 21-Jun-1993.) -/
theorem «19_35i» {ph ps : setvar → wff}
  («19_35i_1» : ⊦ wex (λ x3, wi (ph x3) (ps x3))) :
  ⊦ wi (wal (λ x3, ph x3)) (wex (λ x3, ps x3)) :=
@mpbi (wex (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (wex (λ x3, ps x3)))
  «19_35i_1»
  (@«19_35» (λ x3, ph x3) (λ x3, ps x3))


/-- Inference associated with ~ 19.35 . (Contributed by NM, 12-Mar-1993.) -/
theorem «19_35ri» {ph ps : setvar → wff}
  («19_35ri_1» : ⊦ wi (wal (λ x3, ph x3)) (wex (λ x3, ps x3))) :
  ⊦ wex (λ x3, wi (ph x3) (ps x3)) :=
@mpbir (wex (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (wex (λ x3, ps x3)))
  «19_35ri_1»
  (@«19_35» (λ x3, ph x3) (λ x3, ps x3))


/-- Theorem 19.43 of [Margaris] p. 90. (Contributed by NM, 12-Mar-1993.) (Proof shortened by Wolf
Lammen, 27-Jun-2014.) -/
theorem «19_43» {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wo (ph x3) (ps x3))) (wo (wex (λ x3, ph x3)) (wex (λ x3, ps x3))) :=
@bitr4i (wex (λ x3, wo (ph x3) (ps x3))) (wi (wn (wex (λ x3, ph x3))) (wex (λ x3, ps x3))) (wo (wex (λ x3, ph x3)) (wex (λ x3, ps x3)))
  (@«3bitri» (wex (λ x3, wo (ph x3) (ps x3))) (wex (λ x3, wi (wn (ph x3)) (ps x3))) (wi (wal (λ x3, wn (ph x3))) (wex (λ x3, ps x3))) (wi (wn (wex (λ x3, ph x3))) (wex (λ x3, ps x3)))
    (@exbii (λ x3, wo (ph x3) (ps x3)) (λ x3, wi (wn (ph x3)) (ps x3))
      (λ x3, @df_or (ph x3) (ps x3)))
    (@«19_35» (λ x3, wn (ph x3)) (λ x3, ps x3))
    (@imbi1i (wal (λ x3, wn (ph x3))) (wn (wex (λ x3, ph x3))) (wex (λ x3, ps x3))
      (@alnex (λ x3, ph x3))))
  (@df_or (wex (λ x3, ph x3)) (wex (λ x3, ps x3)))


/-- Theorem 19.40 of [Margaris] p. 90. (Contributed by NM, 26-May-1993.) -/
theorem «19_40» {ph ps : setvar → wff} :
  ⊦ wi (wex (λ x3, wa (ph x3) (ps x3))) (wa (wex (λ x3, ph x3)) (wex (λ x3, ps x3))) :=
@jca (wex (λ x3, wa (ph x3) (ps x3))) (wex (λ x3, ph x3)) (wex (λ x3, ps x3))
  (@exsimpl (λ x3, ph x3) (λ x3, ps x3))
  (@exsimpr (λ x3, ph x3) (λ x3, ps x3))


/-- Split a biconditional and distribute quantifier. (Contributed by NM, 18-Aug-1993.) -/
theorem albiim {ph ps : setvar → wff} :
  ⊦ wb (wal (λ x3, wb (ph x3) (ps x3))) (wa (wal (λ x3, wi (ph x3) (ps x3))) (wal (λ x3, wi (ps x3) (ph x3)))) :=
@bitri (wal (λ x3, wb (ph x3) (ps x3))) (wal (λ x3, wa (wi (ph x3) (ps x3)) (wi (ps x3) (ph x3)))) (wa (wal (λ x3, wi (ph x3) (ps x3))) (wal (λ x3, wi (ps x3) (ph x3))))
  (@albii (λ x3, wb (ph x3) (ps x3)) (λ x3, wa (wi (ph x3) (ps x3)) (wi (ps x3) (ph x3)))
    (λ x3, @dfbi2 (ph x3) (ps x3)))
  (@«19_26» (λ x3, wi (ph x3) (ps x3)) (λ x3, wi (ps x3) (ph x3)))


/-- Split a biconditional and distribute two quantifiers. (Contributed by NM, 3-Feb-2005.) -/
theorem «2albiim» {ph ps : setvar → setvar → wff} :
  ⊦ wb (wal (λ x3, wal (λ y, wb (ph x3 y) (ps x3 y)))) (wa (wal (λ x3, wal (λ y, wi (ph x3 y) (ps x3 y)))) (wal (λ x3, wal (λ y, wi (ps x3 y) (ph x3 y))))) :=
@bitri (wal (λ x3, wal (λ y, wb (ph x3 y) (ps x3 y)))) (wal (λ x3, wa (wal (λ y, wi (ph x3 y) (ps x3 y))) (wal (λ y, wi (ps x3 y) (ph x3 y))))) (wa (wal (λ x3, wal (λ y, wi (ph x3 y) (ps x3 y)))) (wal (λ x3, wal (λ y, wi (ps x3 y) (ph x3 y)))))
  (@albii (λ x3, wal (λ y, wb (ph x3 y) (ps x3 y))) (λ x3, wa (wal (λ y, wi (ph x3 y) (ps x3 y))) (wal (λ y, wi (ps x3 y) (ph x3 y))))
    (λ x3, @albiim (λ y, ph x3 y) (λ y, ps x3 y)))
  (@«19_26» (λ x3, wal (λ y, wi (ph x3 y) (ps x3 y))) (λ x3, wal (λ y, wi (ps x3 y) (ph x3 y))))


/-- Introduce a conjunct in the scope of an existential quantifier. (Contributed by NM,
11-Aug-1993.) (Proof shortened by BJ, 16-Sep-2022.) -/
theorem exintr {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wi (ph x3) (ps x3))) (wi (wex (λ x3, ph x3)) (wex (λ x3, wa (ph x3) (ps x3)))) :=
@aleximi (λ x3, wi (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, wa (ph x3) (ps x3))
  (λ x3, @ancl (ph x3) (ps x3))


/-- If in a context ` x ` is not free in ` ps ` and ` ch ` , then it is not free in ` ( ps -> ch ) `
. Deduction form of ~ nfim . (Contributed by Mario Carneiro, 24-Sep-2016.) (Proof shortened by Wolf
Lammen, 30-Dec-2017.) ~ df-nf changed. (Revised by Wolf Lammen, 18-Sep-2021.) Eliminate curried form
of ~ nfimt . (Revised by Wolf Lammen, 10-Jul-2022.) -/
theorem nfimd {ph ps ch : setvar → wff}
  (nfimd_1 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3)))
  (nfimd_2 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, wi (ps x3) (ch x3))) :=
@nfd (λ x3, ph x3) (λ x3, wi (ps x3) (ch x3))
  (λ x3, @syl56 (wex (λ x3, wi (ps x3) (ch x3))) (wi (wal (λ x3, ps x3)) (wex (λ x3, ch x3))) (ph x3) (wi (wex (λ x3, ps x3)) (wal (λ x3, ch x3))) (wal (λ x3, wi (ps x3) (ch x3)))
    (@biimpi (wex (λ x3, wi (ps x3) (ch x3))) (wi (wal (λ x3, ps x3)) (wex (λ x3, ch x3)))
      (@«19_35» (λ x3, ps x3) (λ x3, ch x3)))
    (@imim12d (ph x3) (wex (λ x3, ps x3)) (wal (λ x3, ps x3)) (wex (λ x3, ch x3)) (wal (λ x3, ch x3))
      (@nfrd (λ x3, ph x3) (λ x3, ps x3)
        (λ x3, nfimd_1 x3) x3)
      (@nfrd (λ x3, ph x3) (λ x3, ch x3)
        (λ x3, nfimd_2 x3) x3))
    (@«19_38» (λ x3, ps x3) (λ x3, ch x3))) x3


/-- Closed form of ~ nfim and ~ nfimd . (Contributed by BJ, 20-Oct-2021.) Eliminate curried form,
former name nfimt2. (Revised by Wolf Lammen, 6-Jul-2022.) -/
theorem nfimt {ph ps : setvar → wff} :
  ⊦ wi (wa (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3))) (wnf (λ x3, wi (ph x3) (ps x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wa (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3))) (wnf (λ x3, wi (ph x3) (ps x3))), from
  @nfimd (λ x3, wa (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3))) (λ x3, ph x3) (λ x3, ps x3)
    (λ x3, @simpl (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3)))
    (λ x3, @simpr (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3))) x3


/-- If ` x ` is not free in ` ph ` and ` ps ` , then it is not free in ` ( ph -> ps ) ` . Inference
associated with ~ nfimt . (Contributed by Mario Carneiro, 11-Aug-2016.) (Proof shortened by Wolf
Lammen, 2-Jan-2018.) ~ df-nf changed. (Revised by Wolf Lammen, 17-Sep-2021.) -/
theorem nfim {ph ps : setvar → wff}
  (nfim_1 : ⊦ wnf (λ x3, ph x3))
  (nfim_2 : ⊦ wnf (λ x3, ps x3)) :
  ⊦ wnf (λ x3, wi (ph x3) (ps x3)) :=
@mp2an (wnf (λ x3, ph x3)) (wnf (λ x3, ps x3)) (wnf (λ x3, wi (ph x3) (ps x3)))
  nfim_1
  nfim_2
  (@nfimt (λ x3, ph x3) (λ x3, ps x3))


/-- If in a context ` x ` is not free in ` ps ` and ` ch ` , then it is not free in ` ( ps /\ ch ) `
. (Contributed by Mario Carneiro, 7-Oct-2016.) -/
theorem nfand {ph ps ch : setvar → wff}
  (nfand_1 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3)))
  (nfand_2 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, wa (ps x3) (ch x3))) :=
@nfxfrd (λ x3, wa (ps x3) (ch x3)) (λ x3, wn (wi (ps x3) (wn (ch x3)))) (λ x3, ph x3)
  (λ x3, @df_an (ps x3) (ch x3))
  (λ x3, @nfnd (λ x3, ph x3) (λ x3, wi (ps x3) (wn (ch x3)))
    (λ x3, @nfimd (λ x3, ph x3) (λ x3, ps x3) (λ x3, wn (ch x3))
      (λ x3, nfand_1 x3)
      (λ x3, @nfnd (λ x3, ph x3) (λ x3, ch x3)
        (λ x3, nfand_2 x3) x3) x3) x3) x3


/-- If ` x ` is not free in ` ph ` and ` ps ` , then it is not free in ` ( ph /\ ps ) ` .
(Contributed by Mario Carneiro, 11-Aug-2016.) (Proof shortened by Wolf Lammen, 13-Jan-2018.) (Proof
shortened by Wolf Lammen, 9-Oct-2021.) -/
theorem nfan {ph ps : setvar → wff}
  (nfan_1 : ⊦ wnf (λ x3, ph x3))
  (nfan_2 : ⊦ wnf (λ x3, ps x3)) :
  ⊦ wnf (λ x3, wa (ph x3) (ps x3)) :=
@mptru (wnf (λ x3, wa (ph x3) (ps x3)))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi wtru (wnf (λ x3, wa (ph x3) (ps x3))), from
    @nfand (λ x3, wtru) (λ x3, ph x3) (λ x3, ps x3)
      (λ x3, @a1i (wnf (λ x3, ph x3)) wtru
        nfan_1)
      (λ x3, @a1i (wnf (λ x3, ps x3)) wtru
        nfan_2) x3)


/-- If ` x ` is not free in ` ph ` , ` ps ` , and ` ch ` , then it is not free in ` ( ph /\ ps /\ ch
) ` . (Contributed by Mario Carneiro, 11-Aug-2016.) -/
theorem nf3an {ph ps ch : setvar → wff}
  (nfan_1 : ⊦ wnf (λ x3, ph x3))
  (nfan_2 : ⊦ wnf (λ x3, ps x3))
  (nfan_3 : ⊦ wnf (λ x3, ch x3)) :
  ⊦ wnf (λ x3, w3a (ph x3) (ps x3) (ch x3)) :=
@nfxfr (λ x3, w3a (ph x3) (ps x3) (ch x3)) (λ x3, wa (wa (ph x3) (ps x3)) (ch x3))
  (λ x3, @df_3an (ph x3) (ps x3) (ch x3))
  (@nfan (λ x3, wa (ph x3) (ps x3)) (λ x3, ch x3)
    (@nfan (λ x3, ph x3) (λ x3, ps x3)
      nfan_1
      nfan_2)
    nfan_3)


/-- If in a context ` x ` is not free in ` ps ` and ` ch ` , then it is not free in ` ( ps <-> ch )
` . (Contributed by Mario Carneiro, 24-Sep-2016.) (Proof shortened by Wolf Lammen, 29-Dec-2017.) -/
theorem nfbid {ph ps ch : setvar → wff}
  (nfbid_1 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3)))
  (nfbid_2 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, wb (ps x3) (ch x3))) :=
@nfxfrd (λ x3, wb (ps x3) (ch x3)) (λ x3, wa (wi (ps x3) (ch x3)) (wi (ch x3) (ps x3))) (λ x3, ph x3)
  (λ x3, @dfbi2 (ps x3) (ch x3))
  (λ x3, @nfand (λ x3, ph x3) (λ x3, wi (ps x3) (ch x3)) (λ x3, wi (ch x3) (ps x3))
    (λ x3, @nfimd (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
      (λ x3, nfbid_1 x3)
      (λ x3, nfbid_2 x3) x3)
    (λ x3, @nfimd (λ x3, ph x3) (λ x3, ch x3) (λ x3, ps x3)
      (λ x3, nfbid_2 x3)
      (λ x3, nfbid_1 x3) x3) x3) x3


/-- If ` x ` is not free in ` ph ` and ` ps ` , then it is not free in ` ( ph <-> ps ) ` .
(Contributed by NM, 26-May-1993.) (Revised by Mario Carneiro, 11-Aug-2016.) (Proof shortened by Wolf
Lammen, 2-Jan-2018.) -/
theorem nfbi {ph ps : setvar → wff}
  (nf_1 : ⊦ wnf (λ x3, ph x3))
  (nf_2 : ⊦ wnf (λ x3, ps x3)) :
  ⊦ wnf (λ x3, wb (ph x3) (ps x3)) :=
@mptru (wnf (λ x3, wb (ph x3) (ps x3)))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi wtru (wnf (λ x3, wb (ph x3) (ps x3))), from
    @nfbid (λ x3, wtru) (λ x3, ph x3) (λ x3, ps x3)
      (λ x3, @a1i (wnf (λ x3, ph x3)) wtru
        nf_1)
      (λ x3, @a1i (wnf (λ x3, ps x3)) wtru
        nf_2) x3)


/-- If ` x ` is not free in ` ph ` and ` ps ` , then it is not free in ` ( ph \/ ps ) ` .
(Contributed by NM, 5-Aug-1993.) (Revised by Mario Carneiro, 11-Aug-2016.) -/
theorem nfor {ph ps : setvar → wff}
  (nf_1 : ⊦ wnf (λ x3, ph x3))
  (nf_2 : ⊦ wnf (λ x3, ps x3)) :
  ⊦ wnf (λ x3, wo (ph x3) (ps x3)) :=
@nfxfr (λ x3, wo (ph x3) (ps x3)) (λ x3, wi (wn (ph x3)) (ps x3))
  (λ x3, @df_or (ph x3) (ps x3))
  (@nfim (λ x3, wn (ph x3)) (λ x3, ps x3)
    (@nfn (λ x3, ph x3)
      nf_1)
    nf_2)


-- /-- Axiom of Distinctness. This axiom quantifies a variable over a formula in which it does not
-- occur. Axiom C5 in [Megill] p. 444 (p. 11 of the preprint). Also appears as Axiom B6 (p. 75) of
-- system S2 of [Tarski] p. 77 and Axiom C5-1 of [Monk2] p. 113. (See comments in ~ ax5ALT about the
-- logical redundancy of ~ ax-5 in the presence of our obsolete axioms.) This axiom essentially says
-- that if ` x ` does not occur in ` ph ` , i.e. ` ph ` does not depend on ` x ` in any way, then we
-- can add the quantifier ` A. x ` to ` ph ` with no further assumptions. By ~ sp , we can also
-- remove the quantifier (unconditionally). For an explanation of disjoint variable conditions, see
-- ~ https://us.metamath.org/mpeuni/mmset.html#distinct . (Contributed by NM, 10-Jan-1993.) -/
-- axiom ax_5 {ph : wff} : ⊦ wi ph (wal (λ x3, ph))


/-- A rephrasing of ~ ax-5 using the existential quantifier. (Contributed by Wolf Lammen,
4-Dec-2017.) -/
theorem ax5e {ph : wff} :
  ⊦ wi (wex (λ x3, ph)) ph :=
@mpbir (wi (wex (λ x3, ph)) ph) (wi (wn ph) (wal (λ x3, wn ph)))
  (@ax_5 (wn ph))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wb (wi (wex (λ x3, ph)) ph) (wi (wn ph) (wal (λ x3, wn ph))), from
    @eximal (λ x3, ph) (λ x3, ph) x3)


/-- If a formula holds for some value of a variable not occurring in it, then it holds for all
values of that variable. (Contributed by BJ, 28-Dec-2020.) -/
theorem ax5ea {ph : wff} :
  ⊦ wi (wex (λ x3, ph)) (wal (λ x3, ph)) :=
@syl (wex (λ x3, ph)) ph (wal (λ x3, ph))
  (@ax5e ph)
  (@ax_5 ph)


/-- If ` x ` is not present in ` ph ` , then ` x ` is not free in ` ph ` . (Contributed by Mario
Carneiro, 11-Aug-2016.) Definition change. (Revised by Wolf Lammen, 12-Sep-2021.) -/
theorem nfv {ph : wff} :
  ⊦ wnf (λ x3, ph) :=
@nfi (λ x3, ph)
  (@ax5ea ph)


/-- ~ nfv with antecedent. Useful in proofs of deduction versions of bound-variable hypothesis
builders such as ~ nfimd . (Contributed by Mario Carneiro, 6-Oct-2016.) -/
theorem nfvd {ph : setvar → wff} {ps : wff}
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, ps)) :=
@a1i (wnf (λ x3, ps)) (ph x3)
  (@nfv ps)


/-- Deduction form of Theorem 19.20 of [Margaris] p. 90, see ~ alim . See ~ alimdh and ~ alimd for
versions without a distinct variable condition. (Contributed by NM, 3-Apr-1994.) -/
theorem alimdv {ph : wff} {ps ch : setvar → wff}
  (alimdv_1 : ∀ x3, ⊦ wi ph (wi (ps x3) (ch x3))) :
  ⊦ wi ph (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3))), from
  @alimdh (λ x3, ph) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, @ax_5 ph)
    (λ x3, alimdv_1 x3) x3


/-- Deduction form of Theorem 19.22 of [Margaris] p. 90, see ~ exim . See ~ eximdh and ~ eximd for
versions without a distinct variable condition. (Contributed by NM, 27-Apr-1994.) -/
theorem eximdv {ph : wff} {ps ch : setvar → wff}
  (alimdv_1 : ∀ x3, ⊦ wi ph (wi (ps x3) (ch x3))) :
  ⊦ wi ph (wi (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wi (wex (λ x3, ps x3)) (wex (λ x3, ch x3))), from
  @eximdh (λ x3, ph) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, @ax_5 ph)
    (λ x3, alimdv_1 x3) x3


/-- Deduction form of Theorem 19.20 of [Margaris] p. 90 with two quantifiers, see ~ alim .
(Contributed by NM, 27-Apr-2004.) -/
theorem «2alimdv» {ph : wff} {ps ch : setvar → setvar → wff}
  («2alimdv_1» : ∀ x3 y, ⊦ wi ph (wi (ps x3 y) (ch x3 y))) :
  ⊦ wi ph (wi (wal (λ x3, wal (λ y, ps x3 y))) (wal (λ x3, wal (λ y, ch x3 y)))) :=
@alimdv ph (λ x3, wal (λ y, ps x3 y)) (λ x3, wal (λ y, ch x3 y))
  (λ x3, @alimdv ph (λ y, ps x3 y) (λ y, ch x3 y)
    (λ y, «2alimdv_1» x3 y))


/-- Deduction form of Theorem 19.22 of [Margaris] p. 90 with two quantifiers, see ~ exim .
(Contributed by NM, 3-Aug-1995.) -/
theorem «2eximdv» {ph : wff} {ps ch : setvar → setvar → wff}
  («2alimdv_1» : ∀ x3 y, ⊦ wi ph (wi (ps x3 y) (ch x3 y))) :
  ⊦ wi ph (wi (wex (λ x3, wex (λ y, ps x3 y))) (wex (λ x3, wex (λ y, ch x3 y)))) :=
@eximdv ph (λ x3, wex (λ y, ps x3 y)) (λ x3, wex (λ y, ch x3 y))
  (λ x3, @eximdv ph (λ y, ps x3 y) (λ y, ch x3 y)
    (λ y, «2alimdv_1» x3 y))


/-- Formula-building rule for universal quantifier (deduction form). See also ~ albidh and ~ albid .
(Contributed by NM, 26-May-1993.) -/
theorem albidv {ph : wff} {ps ch : setvar → wff}
  (albidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wal (λ x3, ps x3)) (wal (λ x3, ch x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wb (wal (λ x3, ps x3)) (wal (λ x3, ch x3))), from
  @albidh (λ x3, ph) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, @ax_5 ph)
    (λ x3, albidv_1 x3) x3


/-- Formula-building rule for existential quantifier (deduction form). See also ~ exbidh and ~ exbid
. (Contributed by NM, 26-May-1993.) -/
theorem exbidv {ph : wff} {ps ch : setvar → wff}
  (albidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wb (wex (λ x3, ps x3)) (wex (λ x3, ch x3))), from
  @exbidh (λ x3, ph) (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, @ax_5 ph)
    (λ x3, albidv_1 x3) x3


/-- An equality theorem for nonfreeness. See ~ nfbidf for a version without disjoint variable
condition but requiring more axioms. (Contributed by Mario Carneiro, 4-Oct-2016.) Remove dependency
on ~ ax-6 , ~ ax-7 , ~ ax-12 by adapting proof of ~ nfbidf . (Revised by BJ, 25-Sep-2022.) -/
theorem nfbidv {ph : wff} {ps ch : setvar → wff}
  (albidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wnf (λ x3, ps x3)) (wnf (λ x3, ch x3))) :=
@«3bitr4g» ph (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3))) (wi (wex (λ x3, ch x3)) (wal (λ x3, ch x3))) (wnf (λ x3, ps x3)) (wnf (λ x3, ch x3))
  (@imbi12d ph (wex (λ x3, ps x3)) (wex (λ x3, ch x3)) (wal (λ x3, ps x3)) (wal (λ x3, ch x3))
    (@exbidv ph (λ x3, ps x3) (λ x3, ch x3)
      (λ x3, albidv_1 x3))
    (@albidv ph (λ x3, ps x3) (λ x3, ch x3)
      (λ x3, albidv_1 x3)))
  (@df_nf (λ x3, ps x3))
  (@df_nf (λ x3, ch x3))


/-- Formula-building rule for two universal quantifiers (deduction form). (Contributed by NM,
4-Mar-1997.) -/
theorem «2albidv» {ph : wff} {ps ch : setvar → setvar → wff}
  («2albidv_1» : ∀ x3 y, ⊦ wi ph (wb (ps x3 y) (ch x3 y))) :
  ⊦ wi ph (wb (wal (λ x3, wal (λ y, ps x3 y))) (wal (λ x3, wal (λ y, ch x3 y)))) :=
@albidv ph (λ x3, wal (λ y, ps x3 y)) (λ x3, wal (λ y, ch x3 y))
  (λ x3, @albidv ph (λ y, ps x3 y) (λ y, ch x3 y)
    (λ y, «2albidv_1» x3 y))


/-- Formula-building rule for two existential quantifiers (deduction form). (Contributed by NM,
1-May-1995.) -/
theorem «2exbidv» {ph : wff} {ps ch : setvar → setvar → wff}
  («2albidv_1» : ∀ x3 y, ⊦ wi ph (wb (ps x3 y) (ch x3 y))) :
  ⊦ wi ph (wb (wex (λ x3, wex (λ y, ps x3 y))) (wex (λ x3, wex (λ y, ch x3 y)))) :=
@exbidv ph (λ x3, wex (λ y, ps x3 y)) (λ x3, wex (λ y, ch x3 y))
  (λ x3, @exbidv ph (λ y, ps x3 y) (λ y, ch x3 y)
    (λ y, «2albidv_1» x3 y))


/-- Formula-building rule for two existential quantifiers (deduction form). (Contributed by NM,
1-May-1995.) -/
theorem «2exbidv_b» {ph : wff} {ps ch : setvar → wff}
  («2albidv_1» : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wex (λ x3, wex (λ x3, ps x3))) (wex (λ x3, wex (λ x3, ch x3)))) :=
@exbidv ph (λ x3, wex (λ x3, ps x3)) (λ x3, wex (λ x3, ch x3))
  (λ x3, @exbidv ph (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, «2albidv_1» x3))


/-- Formula-building rule for three existential quantifiers (deduction form). (Contributed by NM,
1-May-1995.) -/
theorem «3exbidv» {ph : wff} {ps ch : setvar → setvar → setvar → wff}
  («3exbidv_1» : ∀ x3 y z, ⊦ wi ph (wb (ps x3 y z) (ch x3 y z))) :
  ⊦ wi ph (wb (wex (λ x3, wex (λ y, wex (λ z, ps x3 y z)))) (wex (λ x3, wex (λ y, wex (λ z, ch x3 y z))))) :=
@«2exbidv» ph (λ x3 y, wex (λ z, ps x3 y z)) (λ x3 y, wex (λ z, ch x3 y z))
  (λ x3 y, @exbidv ph (λ z, ps x3 y z) (λ z, ch x3 y z)
    (λ z, «3exbidv_1» x3 y z))


/-- Formula-building rule for four existential quantifiers (deduction form). (Contributed by NM,
3-Aug-1995.) -/
theorem «4exbidv» {ph : wff} {ps ch : setvar → setvar → setvar → setvar → wff}
  («4exbidv_1» : ∀ x3 y z w, ⊦ wi ph (wb (ps x3 y z w) (ch x3 y z w))) :
  ⊦ wi ph (wb (wex (λ x3, wex (λ y, wex (λ z, wex (λ w, ps x3 y z w))))) (wex (λ x3, wex (λ y, wex (λ z, wex (λ w, ch x3 y z w)))))) :=
@«2exbidv» ph (λ x3 y, wex (λ z, wex (λ w, ps x3 y z w))) (λ x3 y, wex (λ z, wex (λ w, ch x3 y z w)))
  (λ x3 y, @«2exbidv» ph (λ z w, ps x3 y z w) (λ z w, ch x3 y z w)
    (λ z w, «4exbidv_1» x3 y z w))


/-- Inference form of Theorem 19.21 of [Margaris] p. 90. See ~ 19.21 and ~ 19.21v . (Contributed by
NM, 21-Jun-1993.) -/
theorem alrimiv {ph : wff} {ps : setvar → wff}
  (alrimiv_1 : ∀ x3, ⊦ wi ph (ps x3)) :
  ⊦ wi ph (wal (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wal (λ x3, ps x3)), from
  @alrimih (λ x3, ph) (λ x3, ps x3)
    (λ x3, @ax_5 ph)
    (λ x3, alrimiv_1 x3) x3


/-- Inference form of Theorem 19.21 of [Margaris] p. 90. See ~ 19.21 and ~ 19.21v . (Contributed by
NM, 31-Jul-1995.) -/
theorem alrimivv {ph : wff} {ps : setvar → setvar → wff}
  (alrimivv_1 : ∀ x3 y, ⊦ wi ph (ps x3 y)) :
  ⊦ wi ph (wal (λ x3, wal (λ y, ps x3 y))) :=
@alrimiv ph (λ x3, wal (λ y, ps x3 y))
  (λ x3, @alrimiv ph (λ y, ps x3 y)
    (λ y, alrimivv_1 x3 y))


/-- Deduction form of Theorem 19.21 of [Margaris] p. 90. See ~ 19.21 and ~ 19.21v . (Contributed by
NM, 10-Feb-1997.) -/
theorem alrimdv {ph ps : wff} {ch : setvar → wff}
  (alrimdv_1 : ∀ x3, ⊦ wi ph (wi ps (ch x3))) :
  ⊦ wi ph (wi ps (wal (λ x3, ch x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wi ps (wal (λ x3, ch x3))), from
  @alrimdh (λ x3, ph) (λ x3, ps) (λ x3, ch x3)
    (λ x3, @ax_5 ph)
    (λ x3, @ax_5 ps)
    (λ x3, alrimdv_1 x3) x3


/-- Inference form of Theorem 19.23 of [Margaris] p. 90, see ~ 19.23 . See ~ exlimi for a more
general version requiring more axioms. This inference, along with its many variants such as ~
rexlimdv , is used to implement a metatheorem called "Rule C" that is given in many logic textbooks.
See, for example, Rule C in [Mendelson] p. 81, Rule C in [Margaris] p. 40, or Rule C in Hirst and
Hirst's _A Primer for Logic and Proof_ p. 59 (PDF p. 65) at ~
http://www.appstate.edu/~~hirstjl/primer/hirst.pdf . In informal proofs, the statement "Let ` C ` be
an element such that..." almost always means an implicit application of Rule C. In essence, Rule C
states that if we can prove that some element ` x ` exists satisfying a wff, i.e. ` E. x ph ( x ) `
where ` ph ( x ) ` has ` x ` free, then we can use ` ph ( C ) ` as a hypothesis for the proof where
` C ` is a new (fictitious) constant not appearing previously in the proof, nor in any axioms used,
nor in the theorem to be proved. The purpose of Rule C is to get rid of the existential quantifier.
We cannot do this in Metamath directly. Instead, we use the original ` ph ` (containing ` x ` ) as
an antecedent for the main part of the proof. We eventually arrive at ` ( ph -> ps ) ` where ` ps `
is the theorem to be proved and does not contain ` x ` . Then we apply ~ exlimiv to arrive at ` ( E.
x ph -> ps ) ` . Finally, we separately prove ` E. x ph ` and detach it with modus ponens ~ ax-mp to
arrive at the final theorem ` ps ` , see ~ exlimiiv . (Contributed by NM, 21-Jun-1993.) Remove
dependencies on ~ ax-6 and ~ ax-8 . (Revised by Wolf Lammen, 4-Dec-2017.) -/
theorem exlimiv {ph : setvar → wff} {ps : wff}
  (exlimiv_1 : ∀ x3, ⊦ wi (ph x3) ps) :
  ⊦ wi (wex (λ x3, ph x3)) ps :=
@syl (wex (λ x3, ph x3)) (wex (λ x3, ps)) ps
  (@eximi (λ x3, ph x3) (λ x3, ps)
    (λ x3, exlimiv_1 x3))
  (@ax5e ps)


/-- Inference (Rule C) associated with ~ exlimiv . (Contributed by BJ, 19-Dec-2020.) -/
theorem exlimiiv {ph : setvar → wff} {ps : wff}
  (exlimiv_1 : ∀ x3, ⊦ wi (ph x3) ps)
  (exlimiiv_2 : ⊦ wex (λ x3, ph x3)) :
  ⊦ ps :=
@ax_mp (wex (λ x3, ph x3)) ps
  exlimiiv_2
  (@exlimiv (λ x3, ph x3) ps
    (λ x3, exlimiv_1 x3))


/-- Inference form of Theorem 19.23 of [Margaris] p. 90, see ~ 19.23 . (Contributed by NM,
1-Aug-1995.) -/
theorem exlimivv {ph : setvar → setvar → wff} {ps : wff}
  (exlimivv_1 : ∀ x3 y, ⊦ wi (ph x3 y) ps) :
  ⊦ wi (wex (λ x3, wex (λ y, ph x3 y))) ps :=
@exlimiv (λ x3, wex (λ y, ph x3 y)) ps
  (λ x3, @exlimiv (λ y, ph x3 y) ps
    (λ y, exlimivv_1 x3 y))


/-- Inference form of Theorem 19.23 of [Margaris] p. 90, see ~ 19.23 . (Contributed by NM,
1-Aug-1995.) -/
theorem exlimivv_b {ph : setvar → wff} {ps : wff}
  (exlimivv_1 : ∀ x3, ⊦ wi (ph x3) ps) :
  ⊦ wi (wex (λ x3, wex (λ x3, ph x3))) ps :=
@exlimiv (λ x3, wex (λ x3, ph x3)) ps
  (λ x3, @exlimiv (λ x3, ph x3) ps
    (λ x3, exlimivv_1 x3))


/-- Deduction form of Theorem 19.23 of [Margaris] p. 90, see ~ 19.23 . (Contributed by NM,
27-Apr-1994.) Remove dependencies on ~ ax-6 , ~ ax-7 . (Revised by Wolf Lammen, 4-Dec-2017.) -/
theorem exlimdv {ph : wff} {ps : setvar → wff} {ch : wff}
  (exlimdv_1 : ∀ x3, ⊦ wi ph (wi (ps x3) ch)) :
  ⊦ wi ph (wi (wex (λ x3, ps x3)) ch) :=
@syl6 ph (wex (λ x3, ps x3)) (wex (λ x3, ch)) ch
  (@eximdv ph (λ x3, ps x3) (λ x3, ch)
    (λ x3, exlimdv_1 x3))
  (@ax5e ch)


/-- Deduction form of Theorem 19.23 of [Margaris] p. 90, see ~ 19.23 . (Contributed by NM,
31-Jul-1995.) -/
theorem exlimdvv {ph : wff} {ps : setvar → setvar → wff} {ch : wff}
  (exlimdvv_1 : ∀ x3 y, ⊦ wi ph (wi (ps x3 y) ch)) :
  ⊦ wi ph (wi (wex (λ x3, wex (λ y, ps x3 y))) ch) :=
@exlimdv ph (λ x3, wex (λ y, ps x3 y)) ch
  (λ x3, @exlimdv ph (λ y, ps x3 y) ch
    (λ y, exlimdvv_1 x3 y))


/-- Existential elimination rule of natural deduction (Rule C, explained in ~ exlimiv ).
(Contributed by Mario Carneiro, 15-Jun-2016.) -/
theorem exlimddv {ph : wff} {ps : setvar → wff} {ch : wff}
  (exlimddv_1 : ⊦ wi ph (wex (λ x3, ps x3)))
  (exlimddv_2 : ∀ x3, ⊦ wi (wa ph (ps x3)) ch) :
  ⊦ wi ph ch :=
@mpd ph (wex (λ x3, ps x3)) ch
  exlimddv_1
  (@exlimdv ph (λ x3, ps x3) ch
    (λ x3, @ex ph (ps x3) ch
      (exlimddv_2 x3)))


/-- Deduction for generalization rule for negated wff. (Contributed by NM, 5-Aug-1993.) Reduce
dependencies on axioms. (Revised by Wolf Lammen, 13-Jul-2020.) (Proof shortened by Wolf Lammen,
10-Oct-2021.) -/
theorem nexdv {ph : wff} {ps : setvar → wff}
  (nexdv_1 : ∀ x3, ⊦ wi ph (wn (ps x3))) :
  ⊦ wi ph (wn (wex (λ x3, ps x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wn (wex (λ x3, ps x3))), from
  @nexdh (λ x3, ph) (λ x3, ps x3)
    (λ x3, @ax_5 ph)
    (λ x3, nexdv_1 x3) x3


/-- Version of ~ stdpc5 with a disjoint variable condition, requiring fewer axioms. (Contributed by
BJ, 7-Mar-2020.) Revised to shorten ~ 19.21v . (Revised by Wolf Lammen, 12-Jul-2020.) -/
theorem stdpc5v {ph : wff} {ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wi ph (ps x3))) (wi ph (wal (λ x3, ps x3))) :=
@syl5 ph (wal (λ x3, ph)) (wal (λ x3, wi ph (ps x3))) (wal (λ x3, ps x3))
  (@ax_5 ph)
  (@alim (λ x3, ph) (λ x3, ps x3))


/-- Version of ~ 19.21 with a disjoint variable condition, requiring fewer axioms. _Notational
convention_: We sometimes suffix with "v" the label of a theorem using a distinct variable ("dv")
condition instead of a nonfreeness hypothesis such as ` F/ x ph ` . Conversely, we sometimes suffix
with "f" the label of a theorem introducing such a nonfreeness hypothesis ("f" stands for "not free
in", see ~ df-nf ) instead of a disjoint variable condition. For instance, ~ 19.21v versus ~ 19.21
and ~ vtoclf versus ~ vtocl . Note that "not free in" is less restrictive than "does not occur in".
Note that the version with a disjoint variable condition is easily proved from the version with the
corresponding nonfreeness hypothesis, by using ~ nfv . However, the dv version can often be proved
from fewer axioms. (Contributed by NM, 21-Jun-1993.) Reduce dependencies on axioms. (Revised by Wolf
Lammen, 2-Jan-2020.) (Proof shortened by Wolf Lammen, 12-Jul-2020.) -/
theorem «19_21v» {ph : wff} {ps : setvar → wff} :
  ⊦ wb (wal (λ x3, wi ph (ps x3))) (wi ph (wal (λ x3, ps x3))) :=
@impbii (wal (λ x3, wi ph (ps x3))) (wi ph (wal (λ x3, ps x3)))
  (@stdpc5v ph (λ x3, ps x3))
  (@syl (wi ph (wal (λ x3, ps x3))) (wi (wex (λ x3, ph)) (wal (λ x3, ps x3))) (wal (λ x3, wi ph (ps x3)))
    (@imim1i (wex (λ x3, ph)) ph (wal (λ x3, ps x3))
      (@ax5e ph))
    (@«19_38» (λ x3, ph) (λ x3, ps x3)))


/-- Version of ~ 19.23 with a disjoint variable condition instead of a nonfreeness hypothesis.
(Contributed by NM, 28-Jun-1998.) Reduce dependencies on axioms. (Revised by Wolf Lammen,
11-Jan-2020.) Remove dependency on ~ ax-6 . (Revised by Rohan Ridenour, 15-Apr-2022.) -/
theorem «19_23v» {ph : setvar → wff} {ps : wff} :
  ⊦ wb (wal (λ x3, wi (ph x3) ps)) (wi (wex (λ x3, ph x3)) ps) :=
@impbii (wal (λ x3, wi (ph x3) ps)) (wi (wex (λ x3, ph x3)) ps)
  (@syl6 (wal (λ x3, wi (ph x3) ps)) (wex (λ x3, ph x3)) (wex (λ x3, ps)) ps
    (@exim (λ x3, ph x3) (λ x3, ps))
    (@ax5e ps))
  (@syl (wi (wex (λ x3, ph x3)) ps) (wi (wex (λ x3, ph x3)) (wal (λ x3, ps))) (wal (λ x3, wi (ph x3) ps))
    (@imim2i ps (wal (λ x3, ps)) (wex (λ x3, ph x3))
      (@ax_5 ps))
    (@«19_38» (λ x3, ph x3) (λ x3, ps)))


/-- Theorem ~ 19.23v extended to two variables. (Contributed by NM, 10-Aug-2004.) -/
theorem «19_23vv» {ph : setvar → setvar → wff} {ps : wff} :
  ⊦ wb (wal (λ x3, wal (λ y, wi (ph x3 y) ps))) (wi (wex (λ x3, wex (λ y, ph x3 y))) ps) :=
@bitri (wal (λ x3, wal (λ y, wi (ph x3 y) ps))) (wal (λ x3, wi (wex (λ y, ph x3 y)) ps)) (wi (wex (λ x3, wex (λ y, ph x3 y))) ps)
  (@albii (λ x3, wal (λ y, wi (ph x3 y) ps)) (λ x3, wi (wex (λ y, ph x3 y)) ps)
    (λ x3, @«19_23v» (λ y, ph x3 y) ps))
  (@«19_23v» (λ x3, wex (λ y, ph x3 y)) ps)


/-- Version of ~ 19.41 with a disjoint variable condition, requiring fewer axioms. (Contributed by
NM, 21-Jun-1993.) Remove dependency on ~ ax-6 . (Revised by Rohan Ridenour, 15-Apr-2022.) -/
theorem «19_41v» {ph : setvar → wff} {ps : wff} :
  ⊦ wb (wex (λ x3, wa (ph x3) ps)) (wa (wex (λ x3, ph x3)) ps) :=
@impbii (wex (λ x3, wa (ph x3) ps)) (wa (wex (λ x3, ph x3)) ps)
  (@syl (wex (λ x3, wa (ph x3) ps)) (wa (wex (λ x3, ph x3)) (wex (λ x3, ps))) (wa (wex (λ x3, ph x3)) ps)
    (@«19_40» (λ x3, ph x3) (λ x3, ps))
    (@anim2i (wex (λ x3, ps)) ps (wex (λ x3, ph x3))
      (@ax5e ps)))
  (@impcom ps (wex (λ x3, ph x3)) (wex (λ x3, wa (ph x3) ps))
    (@eximdv ps (λ x3, ph x3) (λ x3, wa (ph x3) ps)
      (λ x3, @pm3_21 ps (ph x3))))


/-- Version of ~ 19.41 with two quantifiers and a disjoint variable condition requiring fewer
axioms. (Contributed by NM, 30-Apr-1995.) -/
theorem «19_41vv» {ph : setvar → setvar → wff} {ps : wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wa (ph x3 y) ps))) (wa (wex (λ x3, wex (λ y, ph x3 y))) ps) :=
@bitri (wex (λ x3, wex (λ y, wa (ph x3 y) ps))) (wex (λ x3, wa (wex (λ y, ph x3 y)) ps)) (wa (wex (λ x3, wex (λ y, ph x3 y))) ps)
  (@exbii (λ x3, wex (λ y, wa (ph x3 y) ps)) (λ x3, wa (wex (λ y, ph x3 y)) ps)
    (λ x3, @«19_41v» (λ y, ph x3 y) ps))
  (@«19_41v» (λ x3, wex (λ y, ph x3 y)) ps)


/-- Version of ~ 19.41 with three quantifiers and a disjoint variable condition requiring fewer
axioms. (Contributed by NM, 30-Apr-1995.) -/
theorem «19_41vvv» {ph : setvar → setvar → setvar → wff} {ps : wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wex (λ z, wa (ph x3 y z) ps)))) (wa (wex (λ x3, wex (λ y, wex (λ z, ph x3 y z)))) ps) :=
@bitri (wex (λ x3, wex (λ y, wex (λ z, wa (ph x3 y z) ps)))) (wex (λ x3, wa (wex (λ y, wex (λ z, ph x3 y z))) ps)) (wa (wex (λ x3, wex (λ y, wex (λ z, ph x3 y z)))) ps)
  (@exbii (λ x3, wex (λ y, wex (λ z, wa (ph x3 y z) ps))) (λ x3, wa (wex (λ y, wex (λ z, ph x3 y z))) ps)
    (λ x3, @«19_41vv» (λ y z, ph x3 y z) ps))
  (@«19_41v» (λ x3, wex (λ y, wex (λ z, ph x3 y z))) ps)


/-- Version of ~ 19.42 with a disjoint variable condition requiring fewer axioms. (Contributed by
NM, 21-Jun-1993.) -/
theorem «19_42v» {ph : wff} {ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wa ph (ps x3))) (wa ph (wex (λ x3, ps x3))) :=
@«3bitr4i» (wex (λ x3, wa (ps x3) ph)) (wa (wex (λ x3, ps x3)) ph) (wex (λ x3, wa ph (ps x3))) (wa ph (wex (λ x3, ps x3)))
  (@«19_41v» (λ x3, ps x3) ph)
  (@exancom (λ x3, ph) (λ x3, ps x3))
  (@ancom ph (wex (λ x3, ps x3)))


/-- Distribution of existential quantifiers. See also ~ exdistrv . (Contributed by NM, 9-Mar-1995.)
-/
theorem exdistr {ph : setvar → wff} {ps : setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wa (ph x3) (ps x3 y)))) (wex (λ x3, wa (ph x3) (wex (λ y, ps x3 y)))) :=
@exbii (λ x3, wex (λ y, wa (ph x3) (ps x3 y))) (λ x3, wa (ph x3) (wex (λ y, ps x3 y)))
  (λ x3, @«19_42v» (ph x3) (λ y, ps x3 y))


/-- Distribute a pair of existential quantifiers (over disjoint variables) over a conjunction.
Combination of ~ 19.41v and ~ 19.42v . For a version with fewer disjoint variable conditions but
requiring more axioms, see ~ eeanv . (Contributed by BJ, 30-Sep-2022.) -/
theorem exdistrv {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wa (wex (λ x3, ph x3)) (wex (λ y, ps y))) :=
@bitri (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wex (λ x3, wa (ph x3) (wex (λ y, ps y)))) (wa (wex (λ x3, ph x3)) (wex (λ y, ps y)))
  (@exdistr (λ x3, ph x3) (λ x3 y, ps y))
  (@«19_41v» (λ x3, ph x3) (wex (λ y, ps y)))


/-- Distribute two pairs of existential quantifiers (over disjoint variables) over a conjunction.
For a version with fewer disjoint variable conditions but requiring more axioms, see ~ ee4anv .
(Contributed by BJ, 5-Jan-2023.) -/
theorem «4exdistrv» {ph ps : setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ z, wex (λ y, wex (λ w, wa (ph x3 y) (ps z w)))))) (wa (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ z, wex (λ w, ps z w)))) :=
@bitri (wex (λ x3, wex (λ z, wex (λ y, wex (λ w, wa (ph x3 y) (ps z w)))))) (wex (λ x3, wex (λ z, wa (wex (λ y, ph x3 y)) (wex (λ w, ps z w))))) (wa (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ z, wex (λ w, ps z w))))
  (@«2exbii» (λ x3 z, wex (λ y, wex (λ w, wa (ph x3 y) (ps z w)))) (λ x3 z, wa (wex (λ y, ph x3 y)) (wex (λ w, ps z w)))
    (λ x3 z, @exdistrv (λ y, ph x3 y) (λ w, ps z w)))
  (@exdistrv (λ x3, wex (λ y, ph x3 y)) (λ z, wex (λ w, ps z w)))


/-- Version of ~ 19.42 with two quantifiers and a disjoint variable condition requiring fewer
axioms. (Contributed by NM, 16-Mar-1995.) -/
theorem «19_42vv» {ph : wff} {ps : setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wa ph (ps x3 y)))) (wa ph (wex (λ x3, wex (λ y, ps x3 y)))) :=
@bitri (wex (λ x3, wex (λ y, wa ph (ps x3 y)))) (wex (λ x3, wa ph (wex (λ y, ps x3 y)))) (wa ph (wex (λ x3, wex (λ y, ps x3 y))))
  (@exdistr (λ x3, ph) (λ x3 y, ps x3 y))
  (@«19_42v» ph (λ x3, wex (λ y, ps x3 y)))


/-- Specialization, with additional weakening (compared to ~ 19.2 ) to allow bundling of ` x ` and `
y ` . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 23-Apr-2017.) (Proof shortened by
Wolf Lammen, 5-Dec-2017.) -/
theorem speimfw {ph ps : setvar → setvar → wff}
  (speimfw_2 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
  (y : setvar) : ⊦ wi (wn (wal (λ x3, wn (wceq (cv x3) (cv y))))) (wi (wal (λ x3, ph x3 y)) (wex (λ x3, ps x3 y))) :=
@syl5com (wn (wal (λ x3, wn (wceq (cv x3) (cv y))))) (wex (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, ph x3 y)) (wex (λ x3, ps x3 y))
  (@biimpri (wex (λ x3, wceq (cv x3) (cv y))) (wn (wal (λ x3, wn (wceq (cv x3) (cv y)))))
    (@df_ex (λ x3, wceq (cv x3) (cv y))))
  (@aleximi (λ x3, ph x3 y) (λ x3, wceq (cv x3) (cv y)) (λ x3, ps x3 y)
    (λ x3, @com12 (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
      (speimfw_2 x3 y)))


/-- Specialization, with additional weakening (compared to ~ sp ) to allow bundling of ` x ` and ` y
` . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 23-Apr-2017.) (Proof shortened by Wolf
Lammen, 7-Aug-2017.) -/
theorem spimfw {ph ps : setvar → setvar → wff}
  (spimfw_1 : ∀ x3 y, ⊦ wi (wn (ps x3 y)) (wal (λ x3, wn (ps x3 y))))
  (spimfw_2 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wn (wal (λ x3, wn (wceq (cv x3) (cv y))))) (wi (wal (λ x3, ph x3 y)) (ps x3 y)) :=
@syl6 (wn (wal (λ x3, wn (wceq (cv x3) (cv y))))) (wal (λ x3, ph x3 y)) (wex (λ x3, ps x3 y)) (ps x3 y)
  (@speimfw (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ x3 y, spimfw_2 x3 y) y)
  (@sylbi (wex (λ x3, ps x3 y)) (wn (wal (λ x3, wn (ps x3 y)))) (ps x3 y)
    (@df_ex (λ x3, ps x3 y))
    (@con1i (ps x3 y) (wal (λ x3, wn (ps x3 y)))
      (spimfw_1 x3 y)))


-- /-- Axiom of Existence. One of the equality and substitution axioms of predicate calculus with
-- equality. This axiom tells us that at least one thing exists. In this form (not requiring that `
-- x ` and ` y ` be distinct) it was used in an axiom system of Tarski (see Axiom B7' in footnote 1
-- of [KalishMontague] p. 81.) It is equivalent to axiom scheme C10' in [Megill] p. 448 (p. 16 of
-- the preprint); the equivalence is established by ~ axc10 and ~ ax6fromc10 . A more convenient
-- form of this axiom is ~ ax6e , which has additional remarks. Raph Levien proved the independence
-- of this axiom from the other logical axioms on 12-Apr-2005. See item 16 at ~
-- https://us.metamath.org/award2003.html . ~ ax-6 can be proved from the weaker version ~ ax6v
-- requiring that the variables be distinct; see Theorem ~ ax6 . ~ ax-6 can also be proved from the
-- Axiom of Separation (in the form that we use that axiom, where free variables are not universally
-- quantified). See Theorem ~ ax6vsep . Except by ~ ax6v , this axiom should not be referenced
-- directly. Instead, use Theorem ~ ax6 . (Contributed by NM, 10-Jan-1993.) (New usage is
-- discouraged.) -/
-- axiom ax_6 {y : setvar} : ⊦ wn (wal (λ x3, wn (wceq (cv x3) (cv y))))


/-- Axiom B7 of [Tarski] p. 75, which requires that ` x ` and ` y ` be distinct. This trivial proof
is intended merely to weaken Axiom ~ ax-6 by adding a distinct variable restriction ($d). From here
on, ~ ax-6 should not be referenced directly by any other proof, so that Theorem ~ ax6 will show
that we can recover ~ ax-6 from this weaker version if it were an axiom (as it is in the case of
Tarski). Note: Introducing ` x , y ` as a distinct variable group "out of the blue" with no apparent
justification has puzzled some people, but it is perfectly sound. All we are doing is adding an
additional prerequisite, similar to adding an unnecessary logical hypothesis, that results in a
weakening of the theorem. This means that any _future_ theorem that references ~ ax6v must have a $d
specified for the two variables that get substituted for ` x ` and ` y ` . The $d does not propagate
"backwards", i.e., it does not impose a requirement on ~ ax-6 . When possible, use of this theorem
rather than ~ ax6 is preferred since its derivation is much shorter and requires fewer axioms.
(Contributed by NM, 7-Aug-2015.) -/
theorem ax6v {y : setvar} :
  ⊦ wn (wal (λ x3, wn (wceq (cv x3) (cv y)))) :=
@ax_6 y


/-- At least one individual exists. Weaker version of ~ ax6e . When possible, use of this theorem
rather than ~ ax6e is preferred since its derivation is much shorter and requires fewer axioms.
(Contributed by NM, 3-Aug-2017.) -/
theorem ax6ev {y : setvar} :
  ⊦ wex (λ x3, wceq (cv x3) (cv y)) :=
@mpbir (wex (λ x3, wceq (cv x3) (cv y))) (wn (wal (λ x3, wn (wceq (cv x3) (cv y)))))
  (@ax6v y)
  (@df_ex (λ x3, wceq (cv x3) (cv y)))


/-- Specialization. Lemma 8 of [KalishMontague] p. 87. Uses only Tarski's FOL axiom schemes.
(Contributed by NM, 19-Apr-2017.) (Proof shortened by Wolf Lammen, 7-Aug-2017.) -/
theorem spimw {ph ps : setvar → setvar → wff}
  (spimw_1 : ∀ x3 y, ⊦ wi (wn (ps x3 y)) (wal (λ x3, wn (ps x3 y))))
  (spimw_2 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, ph x3 y)) (ps x3 y) :=
@ax_mp (wn (wal (λ x3, wn (wceq (cv x3) (cv y))))) (wi (wal (λ x3, ph x3 y)) (ps x3 y))
  (@ax6v y)
  (@spimfw (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ x3 y, spimw_1 x3 y)
    (λ x3 y, spimw_2 x3 y) x3 y)


/-- Existential introduction, using implicit substitution. Compare Lemma 14 of [Tarski] p. 70.
(Contributed by NM, 7-Aug-1994.) (Proof shortened by Wolf Lammen, 22-Oct-2023.) -/
theorem spimew {ph ps : setvar → setvar → wff}
  (spimew_1 : ∀ x3 y, ⊦ wi (ph x3 y) (wal (λ x3, ph x3 y)))
  (spimew_2 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wex (λ x3, ps x3 y)) :=
@mpsyl (wn (wal (λ x3, wn (wceq (cv x3) (cv y))))) (ph x3 y) (wal (λ x3, ph x3 y)) (wex (λ x3, ps x3 y))
  (@ax6v y)
  (spimew_1 x3 y)
  (@speimfw (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ x3 y, spimew_2 x3 y) y)


/-- Inference from existential specialization. (Contributed by NM, 19-Aug-1993.) (Revised by Wolf
Lammen, 22-Oct-2023.) -/
theorem speiv {ph ps : setvar → setvar → wff}
  (speiv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ps x3 y) (ph x3 y)))
  (speiv_2 : ∀ x3 y, ⊦ ps x3 y)
  (y : setvar) : ⊦ wex (λ x3, ph x3 y) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wex (λ x3, ph x3 y), from
  @ax_mp (ps x3 y) (wex (λ x3, ph x3 y))
    (speiv_2 x3 y)
    (@spimew (λ x3 y, ps x3 y) (λ x3 y, ph x3 y)
      (λ x3 y, @hbth (λ x3, ps x3 y)
        (λ x3, speiv_2 x3 y) x3)
      (λ x3 y, speiv_1 x3 y) x3 y)


/-- Rule of existential generalization, similar to universal generalization ~ ax-gen , but valid
only if an individual exists. Its proof requires ~ ax-6 in our axiomatization but the equality
predicate does not occur in its statement. Some fundamental theorems of predicate calculus can be
proven from ~ ax-gen , ~ ax-4 and this theorem alone, not requiring ~ ax-7 or excessive distinct
variable conditions. (Contributed by Wolf Lammen, 12-Nov-2017.) (Proof shortened by Wolf Lammen,
20-Oct-2023.) -/
theorem exgen {ph : setvar → wff}
  (exgen_1 : ∀ x3, ⊦ ph x3) :
  ⊦ wex (λ x3, ph x3) :=
setvar.forget $ λ y : setvar,
  show ⊦ wex (λ x3, ph x3), from
  @speiv (λ x3 y, ph x3) (λ x3 y, ph x3)
    (λ x3 y, @idd (wceq (cv x3) (cv y)) (ph x3))
    (λ x3 y, exgen_1 x3) y


/-- Theorem 19.2 of [Margaris] p. 89. This corresponds to the axiom (D) of modal logic (the other
standard formulation being ~ extru ). Note: This proof is very different from Margaris' because we
only have Tarski's FOL axiom schemes available at this point. See the later ~ 19.2g for a more
conventional proof of a more general result, which uses additional axioms. The reverse implication
is the defining property of effective nonfreeness (see ~ df-nf ). (Contributed by NM, 2-Aug-2017.)
Remove dependency on ~ ax-7 . (Revised by Wolf Lammen, 4-Dec-2017.) -/
theorem «19_2» {ph : setvar → wff} :
  ⊦ wi (wal (λ x3, ph x3)) (wex (λ x3, ph x3)) :=
@«19_35i» (λ x3, ph x3) (λ x3, ph x3)
  (@exgen (λ x3, wi (ph x3) (ph x3))
    (λ x3, @id (ph x3)))


/-- Deduction associated with ~ 19.2 . (Contributed by BJ, 12-May-2019.) -/
theorem «19_2d» {ph ps : setvar → wff}
  («19_2d_1» : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wex (λ x3, ps x3)) :=
@syl (ph x3) (wal (λ x3, ps x3)) (wex (λ x3, ps x3))
  («19_2d_1» x3)
  (@«19_2» (λ x3, ps x3))


/-- Weak version of ~ 19.8a and instance of ~ 19.2d . (Contributed by NM, 1-Aug-2017.) (Proof
shortened by Wolf Lammen, 4-Dec-2017.) (Revised by BJ, 31-Mar-2021.) -/
theorem «19_8w» {ph : setvar → wff}
  («19_8w_1» : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wex (λ x3, ph x3)) :=
@«19_2d» (λ x3, ph x3) (λ x3, ph x3)
  (λ x3, «19_8w_1» x3) x3


/-- Weak version of ~ sp . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 1-Aug-2017.)
(Proof shortened by Wolf Lammen, 13-Aug-2017.) -/
theorem spnfw {ph : setvar → wff}
  (spnfw_1 : ∀ x3, ⊦ wi (wn (ph x3)) (wal (λ x3, wn (ph x3))))
  (x3 : setvar) : ⊦ wi (wal (λ x3, ph x3)) (ph x3) :=
setvar.forget $ λ y : setvar,
  show ⊦ wi (wal (λ x3, ph x3)) (ph x3), from
  @spimw (λ x3 y, ph x3) (λ x3 y, ph x3)
    (λ x3 y, spnfw_1 x3)
    (λ x3 y, @idd (wceq (cv x3) (cv y)) (ph x3)) x3 y


/-- Version of ~ sp when ` x ` does not occur in ` ph ` . Converse of ~ ax-5 . Uses only Tarski's
FOL axiom schemes. (Contributed by NM, 10-Apr-2017.) (Proof shortened by Wolf Lammen, 4-Dec-2017.)
Shorten ~ 19.3v . (Revised by Wolf Lammen, 20-Oct-2023.) -/
theorem spvw {ph : wff} :
  ⊦ wi (wal (λ x3, ph)) ph :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wal (λ x3, ph)) ph, from
  @spnfw (λ x3, ph)
    (λ x3, @ax_5 (wn ph)) x3


/-- Version of ~ 19.3 with a disjoint variable condition, requiring fewer axioms. Any formula can be
universally quantified using a variable which it does not contain. See also ~ 19.9v . (Contributed
by Anthony Hart, 13-Sep-2011.) Remove dependency on ~ ax-7 . (Revised by Wolf Lammen, 4-Dec-2017.)
(Proof shortened by Wolf Lammen, 20-Oct-2023.) -/
theorem «19_3v» {ph : wff} :
  ⊦ wb (wal (λ x3, ph)) ph :=
@impbii (wal (λ x3, ph)) ph
  (@spvw ph)
  (@ax_5 ph)


/-- Version of ~ 19.8a with a disjoint variable condition, requiring fewer axioms. Converse of ~
ax5e . (Contributed by BJ, 12-Mar-2020.) -/
theorem «19_8v» {ph : wff} :
  ⊦ wi ph (wex (λ x3, ph)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wex (λ x3, ph)), from
  @«19_8w» (λ x3, ph)
    (λ x3, @ax_5 ph) x3


/-- Version of ~ 19.9 with a disjoint variable condition, requiring fewer axioms. Any formula can be
existentially quantified using a variable which it does not contain. See also ~ 19.3v . (Contributed
by NM, 28-May-1995.) Remove dependency on ~ ax-7 . (Revised by Wolf Lammen, 4-Dec-2017.) -/
theorem «19_9v» {ph : wff} :
  ⊦ wb (wex (λ x3, ph)) ph :=
@impbii (wex (λ x3, ph)) ph
  (@ax5e ph)
  (@«19_8v» ph)


/-- Version of ~ 19.36 with a disjoint variable condition instead of a nonfreeness hypothesis.
(Contributed by NM, 18-Aug-1993.) Reduce dependencies on axioms. (Revised by Wolf Lammen,
17-Jan-2020.) -/
theorem «19_36v» {ph : setvar → wff} {ps : wff} :
  ⊦ wb (wex (λ x3, wi (ph x3) ps)) (wi (wal (λ x3, ph x3)) ps) :=
@bitri (wex (λ x3, wi (ph x3) ps)) (wi (wal (λ x3, ph x3)) (wex (λ x3, ps))) (wi (wal (λ x3, ph x3)) ps)
  (@«19_35» (λ x3, ph x3) (λ x3, ps))
  (@imbi2i (wex (λ x3, ps)) ps (wal (λ x3, ph x3))
    (@«19_9v» ps))


/-- Version of ~ 19.28 with a disjoint variable condition, requiring fewer axioms. (Contributed by
NM, 25-Mar-2004.) -/
theorem «19_28v» {ph : wff} {ps : setvar → wff} :
  ⊦ wb (wal (λ x3, wa ph (ps x3))) (wa ph (wal (λ x3, ps x3))) :=
@bitri (wal (λ x3, wa ph (ps x3))) (wa (wal (λ x3, ph)) (wal (λ x3, ps x3))) (wa ph (wal (λ x3, ps x3)))
  (@«19_26» (λ x3, ph) (λ x3, ps x3))
  (@anbi1i (wal (λ x3, ph)) ph (wal (λ x3, ps x3))
    (@«19_3v» ph))


/-- Version of ~ 19.37 with a disjoint variable condition, requiring fewer axioms. (Contributed by
NM, 21-Jun-1993.) -/
theorem «19_37v» {ph : wff} {ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wi ph (ps x3))) (wi ph (wex (λ x3, ps x3))) :=
@bitri (wex (λ x3, wi ph (ps x3))) (wi (wal (λ x3, ph)) (wex (λ x3, ps x3))) (wi ph (wex (λ x3, ps x3)))
  (@«19_35» (λ x3, ph) (λ x3, ps x3))
  (@imbi1i (wal (λ x3, ph)) ph (wex (λ x3, ps x3))
    (@«19_3v» ph))


/-- A weak form of specialization. Lemma 8 of [KalishMontague] p. 87. Uses only Tarski's FOL axiom
schemes. For stronger forms using more axioms, see ~ spimv and ~ spimfv . (Contributed by NM,
9-Apr-2017.) -/
theorem spimvw {ph : setvar → setvar → wff} {ps : setvar → wff}
  (spimvw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps y)))
  (y : setvar) : ⊦ wi (wal (λ x3, ph x3 y)) (ps y) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wal (λ x3, ph x3 y)) (ps y), from
  @spimw (λ x3 y, ph x3 y) (λ x3 y, ps y)
    (λ x3 y, @ax_5 (wn (ps y)))
    (λ x3 y, spimvw_1 x3 y) x3 y


/-- Specialization, using implicit substitution. Version of ~ spv with a disjoint variable
condition, which does not require ~ ax-7 , ~ ax-12 , ~ ax-13 . (Contributed by NM, 30-Aug-1993.)
(Revised by BJ, 31-May-2019.) -/
theorem spvv {ph : setvar → setvar → wff} {ps : setvar → wff}
  (spvv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps y)))
  (y : setvar) : ⊦ wi (wal (λ x3, ph x3 y)) (ps y) :=
@spimvw (λ x3 y, ph x3 y) (λ y, ps y)
  (λ x3 y, @biimpd (wceq (cv x3) (cv y)) (ph x3 y) (ps y)
    (spvv_1 x3 y)) y


/-- Implicit substitution of ` y ` for ` x ` into a theorem. Version of ~ chvarv with a disjoint
variable condition, which does not require ~ ax-13 . (Contributed by NM, 20-Apr-1994.) (Revised by
BJ, 31-May-2019.) -/
theorem chvarvv {ph : setvar → setvar → wff} {ps : setvar → wff}
  (chvarvv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps y)))
  (chvarvv_2 : ∀ x3 y, ⊦ ph x3 y)
  (y : setvar) : ⊦ ps y :=
setvar.forget $ λ x3 : setvar,
  show ⊦ ps y, from
  @mpg (λ x3, ph x3 y) (λ x3, ps y)
    (λ x3, @spvv (λ x3 y, ph x3 y) (λ y, ps y)
      (λ x3 y, chvarvv_1 x3 y) y)
    (λ x3, chvarvv_2 x3 y) x3


/-- Version of ~ equs4 with a disjoint variable condition, which requires fewer axioms. (Contributed
by NM, 10-May-1993.) (Revised by BJ, 31-May-2019.) -/
theorem equs4v {ph : setvar → wff} {y : setvar} :
  ⊦ wi (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3))) :=
@mpi (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wex (λ x3, wceq (cv x3) (cv y))) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3)))
  (@ax6ev y)
  (@exintr (λ x3, wceq (cv x3) (cv y)) (λ x3, ph x3))


/-- Version of ~ equs4v with its consequence simplified by ~ exsimpr . (Contributed by BJ,
9-Nov-2021.) -/
theorem alequexv {ph : setvar → wff} {y : setvar} :
  ⊦ wi (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wex (λ x3, ph x3)) :=
@mpi (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wex (λ x3, wceq (cv x3) (cv y))) (wex (λ x3, ph x3))
  (@ax6ev y)
  (@exim (λ x3, wceq (cv x3) (cv y)) (λ x3, ph x3))


/-- One direction of the equivalence in ~ exsb is based on fewer axioms. (Contributed by Wolf
Lammen, 2-Mar-2023.) -/
theorem exsbim {ph : setvar → wff} :
  ⊦ wi (wex (λ y, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))) (wex (λ x3, ph x3)) :=
@exlimiv (λ y, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wex (λ x3, ph x3))
  (λ y, @alequexv (λ x3, ph x3) y)


/-- If a formula does not contain a variable ` x ` , then it is equivalent to the corresponding
prototype of substitution with a fresh variable (see ~ sb6 ). (Contributed by BJ, 23-Jul-2023.) -/
theorem equsv {ph : wff} {y : setvar} :
  ⊦ wb (wal (λ x3, wi (wceq (cv x3) (cv y)) ph)) ph :=
@bitr4i (wal (λ x3, wi (wceq (cv x3) (cv y)) ph)) (wi (wex (λ x3, wceq (cv x3) (cv y))) ph) ph
  (@«19_23v» (λ x3, wceq (cv x3) (cv y)) ph)
  (@a1bi (wex (λ x3, wceq (cv x3) (cv y))) ph
    (@ax6ev y))


/-- Version of ~ equsalv with a disjoint variable condition, and of ~ equsal with two disjoint
variable conditions, which requires fewer axioms. See also the dual form ~ equsexvw . (Contributed
by BJ, 31-May-2019.) -/
theorem equsalvw {ph : setvar → setvar → wff} {ps : setvar → wff}
  (equsalvw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps y)))
  (y : setvar) : ⊦ wb (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (ps y) :=
@bitri (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ps y))) (ps y)
  (@albii (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y)) (λ x3, wi (wceq (cv x3) (cv y)) (ps y))
    (λ x3, @pm5_74i (wceq (cv x3) (cv y)) (ph x3 y) (ps y)
      (equsalvw_1 x3 y)))
  (@equsv (ps y) y)


/-- Version of ~ equsexv with a disjoint variable condition, and of ~ equsex with two disjoint
variable conditions, which requires fewer axioms. See also the dual form ~ equsalvw . (Contributed
by BJ, 31-May-2019.) (Proof shortened by Wolf Lammen, 23-Oct-2023.) -/
theorem equsexvw {ph : setvar → setvar → wff} {ps : setvar → wff}
  (equsalvw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps y)))
  (y : setvar) : ⊦ wb (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 y))) (ps y) :=
@con4bii (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 y))) (ps y)
  (@bitr3i (wn (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 y)))) (wal (λ x3, wi (wceq (cv x3) (cv y)) (wn (ph x3 y)))) (wn (ps y))
    (@alinexa (λ x3, wceq (cv x3) (cv y)) (λ x3, ph x3 y))
    (@equsalvw (λ x3 y, wn (ph x3 y)) (λ y, wn (ps y))
      (λ x3 y, @notbid (wceq (cv x3) (cv y)) (ph x3 y) (ps y)
        (equsalvw_1 x3 y)) y))


/-- Change bound variable. Uses only Tarski's FOL axiom schemes. Part of Lemma 7 of [KalishMontague]
p. 86. (Contributed by NM, 19-Apr-2017.) -/
theorem cbvaliw {ph ps : setvar → setvar → wff}
  (cbvaliw_1 : ∀ y, ⊦ wi (wal (λ x3, ph x3 y)) (wal (λ y, wal (λ x3, ph x3 y))))
  (cbvaliw_2 : ∀ x3 y, ⊦ wi (wn (ps x3 y)) (wal (λ x3, wn (ps x3 y))))
  (cbvaliw_3 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y)) :=
@alrimih (λ y, wal (λ x3, ph x3 y)) (λ y, ps x3 y)
  (λ y, cbvaliw_1 y)
  (λ y, @spimw (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ x3 y, cbvaliw_2 x3 y)
    (λ x3 y, cbvaliw_3 x3 y) x3 y) y


/-- Change bound variable. Uses only Tarski's FOL axiom schemes. Part of Lemma 7 of [KalishMontague]
p. 86. (Contributed by NM, 9-Apr-2017.) -/
theorem cbvalivw {ph ps : setvar → wff}
  (cbvalivw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3) (ps y))) :
  ⊦ wi (wal (λ x3, ph x3)) (wal (λ y, ps y)) :=
@alrimiv (wal (λ x3, ph x3)) (λ y, ps y)
  (λ y, @spimvw (λ x3 y, ph x3) (λ y, ps y)
    (λ x3 y, cbvalivw_1 x3 y) y)


-- /-- Axiom of Equality. One of the equality and substitution axioms of predicate calculus with
-- equality. It states that equality is a right-Euclidean binary relation (this is similar, but not
-- identical, to being transitive, which is proved as ~ equtr ). This axiom scheme is a sub-scheme
-- of Axiom Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with
-- our notation. Also appears as Axiom C7 of [Monk2] p. 105 and Axiom Scheme C8' in [Megill] p. 448
-- (p. 16 of the preprint). The equality symbol was invented in 1557 by Robert Recorde. He chose a
-- pair of parallel lines of the same length because "noe .2. thynges, can be moare equalle". We
-- prove in ~ ax7 that this axiom can be recovered from its weakened version ~ ax7v where ` x ` and
-- ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-7
-- should be ~ ax7v . See the comment of ~ ax7v for more details on these matters. (Contributed by
-- NM, 10-Jan-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax7 instead. (New usage is discouraged.) -/
-- axiom ax_7 {x3 y z : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv z)) (wceq (cv y) (cv z)))


-- /-- Axiom of Equality. One of the equality and substitution axioms of predicate calculus with
-- equality. It states that equality is a right-Euclidean binary relation (this is similar, but not
-- identical, to being transitive, which is proved as ~ equtr ). This axiom scheme is a sub-scheme
-- of Axiom Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with
-- our notation. Also appears as Axiom C7 of [Monk2] p. 105 and Axiom Scheme C8' in [Megill] p. 448
-- (p. 16 of the preprint). The equality symbol was invented in 1557 by Robert Recorde. He chose a
-- pair of parallel lines of the same length because "noe .2. thynges, can be moare equalle". We
-- prove in ~ ax7 that this axiom can be recovered from its weakened version ~ ax7v where ` x ` and
-- ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-7
-- should be ~ ax7v . See the comment of ~ ax7v for more details on these matters. (Contributed by
-- NM, 10-Jan-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax7 instead. (New usage is discouraged.) -/
-- axiom ax_7_b {x3 y : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3)))


-- /-- Axiom of Equality. One of the equality and substitution axioms of predicate calculus with
-- equality. It states that equality is a right-Euclidean binary relation (this is similar, but not
-- identical, to being transitive, which is proved as ~ equtr ). This axiom scheme is a sub-scheme
-- of Axiom Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with
-- our notation. Also appears as Axiom C7 of [Monk2] p. 105 and Axiom Scheme C8' in [Megill] p. 448
-- (p. 16 of the preprint). The equality symbol was invented in 1557 by Robert Recorde. He chose a
-- pair of parallel lines of the same length because "noe .2. thynges, can be moare equalle". We
-- prove in ~ ax7 that this axiom can be recovered from its weakened version ~ ax7v where ` x ` and
-- ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-7
-- should be ~ ax7v . See the comment of ~ ax7v for more details on these matters. (Contributed by
-- NM, 10-Jan-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax7 instead. (New usage is discouraged.) -/
-- axiom ax_7_b1 {x3 y : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv y)) (wceq (cv y) (cv y)))


/-- Weakened version of ~ ax-7 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-7 , and it should be referenced only by its two weakened versions ~
ax7v1 and ~ ax7v2 , from which ~ ax-7 is then rederived as ~ ax7 , which shows that either ~ ax7v or
the conjunction of ~ ax7v1 and ~ ax7v2 is sufficient. In ~ ax7v , it is still allowed to substitute
the same variable for ` x ` and ` z ` , or the same variable for ` y ` and ` z ` . Therefore, ~ ax7v
"bundles" (a term coined by Raph Levien) its "principal instance" ` ( x = y -> ( x = z -> y = z ) )
` with ` x , y , z ` distinct, and its "degenerate instances" ` ( x = y -> ( x = x -> y = x ) ) `
and ` ( x = y -> ( x = y -> y = y ) ) ` with ` x , y ` distinct. These degenerate instances are for
instance used in the proofs of ~ equcomiv and ~ equid respectively. (Contributed by BJ, 7-Dec-2020.)
Use ~ ax7 instead. (New usage is discouraged.) -/
theorem ax7v {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) :=
@ax_7 x3 y z


/-- Weakened version of ~ ax-7 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-7 , and it should be referenced only by its two weakened versions ~
ax7v1 and ~ ax7v2 , from which ~ ax-7 is then rederived as ~ ax7 , which shows that either ~ ax7v or
the conjunction of ~ ax7v1 and ~ ax7v2 is sufficient. In ~ ax7v , it is still allowed to substitute
the same variable for ` x ` and ` z ` , or the same variable for ` y ` and ` z ` . Therefore, ~ ax7v
"bundles" (a term coined by Raph Levien) its "principal instance" ` ( x = y -> ( x = z -> y = z ) )
` with ` x , y , z ` distinct, and its "degenerate instances" ` ( x = y -> ( x = x -> y = x ) ) `
and ` ( x = y -> ( x = y -> y = y ) ) ` with ` x , y ` distinct. These degenerate instances are for
instance used in the proofs of ~ equcomiv and ~ equid respectively. (Contributed by BJ, 7-Dec-2020.)
Use ~ ax7 instead. (New usage is discouraged.) -/
theorem ax7v_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))) :=
@ax_7_b x3 y


/-- Weakened version of ~ ax-7 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-7 , and it should be referenced only by its two weakened versions ~
ax7v1 and ~ ax7v2 , from which ~ ax-7 is then rederived as ~ ax7 , which shows that either ~ ax7v or
the conjunction of ~ ax7v1 and ~ ax7v2 is sufficient. In ~ ax7v , it is still allowed to substitute
the same variable for ` x ` and ` z ` , or the same variable for ` y ` and ` z ` . Therefore, ~ ax7v
"bundles" (a term coined by Raph Levien) its "principal instance" ` ( x = y -> ( x = z -> y = z ) )
` with ` x , y , z ` distinct, and its "degenerate instances" ` ( x = y -> ( x = x -> y = x ) ) `
and ` ( x = y -> ( x = y -> y = y ) ) ` with ` x , y ` distinct. These degenerate instances are for
instance used in the proofs of ~ equcomiv and ~ equid respectively. (Contributed by BJ, 7-Dec-2020.)
Use ~ ax7 instead. (New usage is discouraged.) -/
theorem ax7v_b1 {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv y)) (wceq (cv y) (cv y))) :=
@ax_7_b1 x3 y


/-- First of two weakened versions of ~ ax7v , with an extra disjoint variable condition on ` x , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7v1 {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) :=
@ax7v x3 y z


/-- First of two weakened versions of ~ ax7v , with an extra disjoint variable condition on ` x , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7v1_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv y)) (wceq (cv y) (cv y))) :=
@ax7v_b1 x3 y


/-- Second of two weakened versions of ~ ax7v , with an extra disjoint variable condition on ` y , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7v2 {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) :=
@ax7v x3 y z


/-- Second of two weakened versions of ~ ax7v , with an extra disjoint variable condition on ` y , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7v2_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))) :=
@ax7v_b x3 y


/-- Identity law for equality. Lemma 2 of [KalishMontague] p. 85. See also Lemma 6 of [Tarski] p.
68. (Contributed by NM, 1-Apr-2005.) (Revised by NM, 9-Apr-2017.) (Proof shortened by Wolf Lammen,
22-Aug-2020.) -/
theorem equid {x3 : setvar} :
  ⊦ wceq (cv x3) (cv x3) :=
@exlimiiv (λ y, wceq (cv y) (cv x3)) (wceq (cv x3) (cv x3))
  (λ y, @pm2_43i (wceq (cv y) (cv x3)) (wceq (cv x3) (cv x3))
    (@ax7v1_b y x3))
  (@ax6ev x3)


/-- Weaker form of ~ equcomi with a disjoint variable condition on ` x , y ` . This is an
intermediate step and ~ equcomi is fully recovered later. (Contributed by BJ, 7-Dec-2020.) -/
theorem equcomiv {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wceq (cv y) (cv x3)) :=
@mpi (wceq (cv x3) (cv y)) (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))
  (@equid x3)
  (@ax7v2_b x3 y)


/-- A commuted form of ~ ax6ev . (Contributed by BJ, 7-Dec-2020.) -/
theorem ax6evr {y : setvar} :
  ⊦ wex (λ x3, wceq (cv y) (cv x3)) :=
@eximii (λ x3, wceq (cv x3) (cv y)) (λ x3, wceq (cv y) (cv x3))
  (@ax6ev y)
  (λ x3, @equcomiv x3 y)


/-- Proof of ~ ax-7 from ~ ax7v1 and ~ ax7v2 (and earlier axioms), proving sufficiency of the
conjunction of the latter two weakened versions of ~ ax7v , which is itself a weakened version of ~
ax-7 . Note that the weakened version of ~ ax-7 obtained by adding a disjoint variable condition on
` x , z ` (resp. on ` y , z ` ) does not permit, together with the other axioms, to prove
reflexivity (resp. symmetry). (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7 {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) :=
@ex (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))
  (@exlimiiv (λ t, wceq (cv x3) (cv t)) (wi (wa (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z))) (wceq (cv y) (cv z)))
    (λ t, @syl2and (wceq (cv x3) (cv t)) (wceq (cv x3) (cv y)) (wceq (cv t) (cv y)) (wceq (cv x3) (cv z)) (wceq (cv t) (cv z)) (wceq (cv y) (cv z))
      (@ax7v2 x3 t y)
      (@ax7v2 x3 t z)
      (@a1i (wi (wa (wceq (cv t) (cv y)) (wceq (cv t) (cv z))) (wceq (cv y) (cv z))) (wceq (cv x3) (cv t))
        (@imp (wceq (cv t) (cv y)) (wceq (cv t) (cv z)) (wceq (cv y) (cv z))
          (@ax7v1 t y z))))
    (@ax6evr x3))


/-- Proof of ~ ax-7 from ~ ax7v1 and ~ ax7v2 (and earlier axioms), proving sufficiency of the
conjunction of the latter two weakened versions of ~ ax7v , which is itself a weakened version of ~
ax-7 . Note that the weakened version of ~ ax-7 obtained by adding a disjoint variable condition on
` x , z ` (resp. on ` y , z ` ) does not permit, together with the other axioms, to prove
reflexivity (resp. symmetry). (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7_b {x3 : setvar} :
  ⊦ wi (wceq (cv x3) (cv x3)) (wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))) :=
@ex (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))
  (@exlimiiv (λ t, wceq (cv x3) (cv t)) (wi (wa (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))) (wceq (cv x3) (cv x3)))
    (λ t, @syl2and (wceq (cv x3) (cv t)) (wceq (cv x3) (cv x3)) (wceq (cv t) (cv x3)) (wceq (cv x3) (cv x3)) (wceq (cv t) (cv x3)) (wceq (cv x3) (cv x3))
      (@ax7v2_b x3 t)
      (@ax7v2_b x3 t)
      (@a1i (wi (wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv x3))) (wceq (cv x3) (cv x3))) (wceq (cv x3) (cv t))
        (@imp (wceq (cv t) (cv x3)) (wceq (cv t) (cv x3)) (wceq (cv x3) (cv x3))
          (@ax7v1_b t x3))))
    (@ax6evr x3))


/-- Proof of ~ ax-7 from ~ ax7v1 and ~ ax7v2 (and earlier axioms), proving sufficiency of the
conjunction of the latter two weakened versions of ~ ax7v , which is itself a weakened version of ~
ax-7 . Note that the weakened version of ~ ax-7 obtained by adding a disjoint variable condition on
` x , z ` (resp. on ` y , z ` ) does not permit, together with the other axioms, to prove
reflexivity (resp. symmetry). (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7_b1 {x3 z : setvar} :
  ⊦ wi (wceq (cv x3) (cv x3)) (wi (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z))) :=
@ex (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z))
  (@exlimiiv (λ t, wceq (cv x3) (cv t)) (wi (wa (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv z))) (wceq (cv x3) (cv z)))
    (λ t, @syl2and (wceq (cv x3) (cv t)) (wceq (cv x3) (cv x3)) (wceq (cv t) (cv x3)) (wceq (cv x3) (cv z)) (wceq (cv t) (cv z)) (wceq (cv x3) (cv z))
      (@ax7v2_b x3 t)
      (@ax7v2 x3 t z)
      (@a1i (wi (wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv z))) (wceq (cv x3) (cv z))) (wceq (cv x3) (cv t))
        (@imp (wceq (cv t) (cv x3)) (wceq (cv t) (cv z)) (wceq (cv x3) (cv z))
          (@ax7v1 t x3 z))))
    (@ax6evr x3))


/-- Proof of ~ ax-7 from ~ ax7v1 and ~ ax7v2 (and earlier axioms), proving sufficiency of the
conjunction of the latter two weakened versions of ~ ax7v , which is itself a weakened version of ~
ax-7 . Note that the weakened version of ~ ax-7 obtained by adding a disjoint variable condition on
` x , z ` (resp. on ` y , z ` ) does not permit, together with the other axioms, to prove
reflexivity (resp. symmetry). (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7_b2 {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))) :=
@ex (wceq (cv x3) (cv y)) (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))
  (@exlimiiv (λ t, wceq (cv x3) (cv t)) (wi (wa (wceq (cv x3) (cv y)) (wceq (cv x3) (cv x3))) (wceq (cv y) (cv x3)))
    (λ t, @syl2and (wceq (cv x3) (cv t)) (wceq (cv x3) (cv y)) (wceq (cv t) (cv y)) (wceq (cv x3) (cv x3)) (wceq (cv t) (cv x3)) (wceq (cv y) (cv x3))
      (@ax7v2 x3 t y)
      (@ax7v2_b x3 t)
      (@a1i (wi (wa (wceq (cv t) (cv y)) (wceq (cv t) (cv x3))) (wceq (cv y) (cv x3))) (wceq (cv x3) (cv t))
        (@imp (wceq (cv t) (cv y)) (wceq (cv t) (cv x3)) (wceq (cv y) (cv x3))
          (@ax7v1 t y x3))))
    (@ax6evr x3))


/-- Proof of ~ ax-7 from ~ ax7v1 and ~ ax7v2 (and earlier axioms), proving sufficiency of the
conjunction of the latter two weakened versions of ~ ax7v , which is itself a weakened version of ~
ax-7 . Note that the weakened version of ~ ax-7 obtained by adding a disjoint variable condition on
` x , z ` (resp. on ` y , z ` ) does not permit, together with the other axioms, to prove
reflexivity (resp. symmetry). (Contributed by BJ, 7-Dec-2020.) -/
theorem ax7_b3 {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv y)) (wceq (cv y) (cv y))) :=
@ex (wceq (cv x3) (cv y)) (wceq (cv x3) (cv y)) (wceq (cv y) (cv y))
  (@exlimiiv (λ t, wceq (cv x3) (cv t)) (wi (wa (wceq (cv x3) (cv y)) (wceq (cv x3) (cv y))) (wceq (cv y) (cv y)))
    (λ t, @syl2and (wceq (cv x3) (cv t)) (wceq (cv x3) (cv y)) (wceq (cv t) (cv y)) (wceq (cv x3) (cv y)) (wceq (cv t) (cv y)) (wceq (cv y) (cv y))
      (@ax7v2 x3 t y)
      (@ax7v2 x3 t y)
      (@a1i (wi (wa (wceq (cv t) (cv y)) (wceq (cv t) (cv y))) (wceq (cv y) (cv y))) (wceq (cv x3) (cv t))
        (@imp (wceq (cv t) (cv y)) (wceq (cv t) (cv y)) (wceq (cv y) (cv y))
          (@ax7v1_b t y))))
    (@ax6evr x3))


/-- Commutative law for equality. Equality is a symmetric relation. Lemma 3 of [KalishMontague] p.
85. See also Lemma 7 of [Tarski] p. 69. (Contributed by NM, 10-Jan-1993.) (Revised by NM,
9-Apr-2017.) -/
theorem equcomi {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wceq (cv y) (cv x3)) :=
@mpi (wceq (cv x3) (cv y)) (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))
  (@equid x3)
  (@ax7_b2 x3 y)


/-- Commutative law for equality. Equality is a symmetric relation. Lemma 3 of [KalishMontague] p.
85. See also Lemma 7 of [Tarski] p. 69. (Contributed by NM, 10-Jan-1993.) (Revised by NM,
9-Apr-2017.) -/
theorem equcomi_b {x3 : setvar} :
  ⊦ wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)) :=
@mpi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))
  (@equid x3)
  (@ax7_b x3)


/-- Commutative law for equality. Equality is a symmetric relation. (Contributed by NM,
20-Aug-1993.) -/
theorem equcom {x3 y : setvar} :
  ⊦ wb (wceq (cv x3) (cv y)) (wceq (cv y) (cv x3)) :=
@impbii (wceq (cv x3) (cv y)) (wceq (cv y) (cv x3))
  (@equcomi x3 y)
  (@equcomi y x3)


/-- Deduction form of ~ equcom , symmetry of equality. For the versions for classes, see ~ eqcom and
~ eqcomd . (Contributed by BJ, 6-Oct-2019.) -/
theorem equcomd {ph : setvar → setvar → wff}
  (equcomd_1 : ∀ x3 y, ⊦ wi (ph x3 y) (wceq (cv x3) (cv y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wceq (cv y) (cv x3)) :=
@sylib (ph x3 y) (wceq (cv x3) (cv y)) (wceq (cv y) (cv x3))
  (equcomd_1 x3 y)
  (@equcom x3 y)


/-- An inference commuting equality in antecedent. Used to eliminate the need for a syllogism.
(Contributed by NM, 10-Jan-1993.) -/
theorem equcoms {ph : setvar → setvar → wff}
  (equcoms_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (ph x3 y))
  (x3 y : setvar) : ⊦ wi (wceq (cv y) (cv x3)) (ph x3 y) :=
@syl (wceq (cv y) (cv x3)) (wceq (cv x3) (cv y)) (ph x3 y)
  (@equcomi y x3)
  (equcoms_1 x3 y)


/-- An inference commuting equality in antecedent. Used to eliminate the need for a syllogism.
(Contributed by NM, 10-Jan-1993.) -/
theorem equcoms_b {ph : setvar → wff}
  (equcoms_1 : ∀ x3, ⊦ wi (wceq (cv x3) (cv x3)) (ph x3))
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (ph x3) :=
@syl (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)) (ph x3)
  (@equcomi_b x3)
  (equcoms_1 x3)


/-- A transitive law for equality. (Contributed by NM, 23-Aug-1993.) -/
theorem equtr {z : setvar}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv y) (cv z)) (wceq (cv x3) (cv z))) :=
@equcoms (λ y x3, wi (wceq (cv y) (cv z)) (wceq (cv x3) (cv z)))
  (λ y x3, @ax7 y x3 z) y x3


/-- A transitive law for equality. (Contributed by NM, 23-Aug-1993.) -/
theorem equtr_b
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))) :=
@equcoms_b (λ x3, wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)))
  (λ x3, @ax7_b x3) x3


/-- A transitive law for equality. (Contributed by NM, 23-Aug-1993.) -/
theorem equtr_b1 {z : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z))) :=
@equcoms_b (λ x3, wi (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z)))
  (λ x3, @ax7_b1 x3 z) x3


/-- A transitive law for equality. (Contributed by NM, 23-Aug-1993.) -/
theorem equtr_b2
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv y) (cv x3)) (wceq (cv x3) (cv x3))) :=
@equcoms (λ y x3, wi (wceq (cv y) (cv x3)) (wceq (cv x3) (cv x3)))
  (λ y x3, @ax7_b3 y x3) y x3


/-- A transitive law for equality. (Contributed by NM, 23-Aug-1993.) -/
theorem equtr_b3
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv y) (cv y)) (wceq (cv x3) (cv y))) :=
@equcoms (λ y x3, wi (wceq (cv y) (cv y)) (wceq (cv x3) (cv y)))
  (λ y x3, @ax7_b2 y x3) y x3


/-- A transitive law for equality. Lemma L17 in [Megill] p. 446 (p. 14 of the preprint).
(Contributed by NM, 23-Aug-1993.) -/
theorem equtrr {y : setvar}
  (x3 z : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv z) (cv x3)) (wceq (cv z) (cv y))) :=
@com12 (wceq (cv z) (cv x3)) (wceq (cv x3) (cv y)) (wceq (cv z) (cv y))
  (@equtr y z x3)


/-- A transitive law for equality. Lemma L17 in [Megill] p. 446 (p. 14 of the preprint).
(Contributed by NM, 23-Aug-1993.) -/
theorem equtrr_b
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))) :=
@com12 (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))
  (@equtr_b x3)


/-- A transitive law for equality. Lemma L17 in [Megill] p. 446 (p. 14 of the preprint).
(Contributed by NM, 23-Aug-1993.) -/
theorem equtrr_b1 {y : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv y))) :=
@com12 (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv y)) (wceq (cv x3) (cv y))
  (@equtr_b1 y x3)


/-- A transitive law for equality. Lemma L17 in [Megill] p. 446 (p. 14 of the preprint).
(Contributed by NM, 23-Aug-1993.) -/
theorem equtrr_b2
  (x3 z : setvar) : ⊦ wi (wceq (cv x3) (cv z)) (wi (wceq (cv z) (cv x3)) (wceq (cv z) (cv z))) :=
@com12 (wceq (cv z) (cv x3)) (wceq (cv x3) (cv z)) (wceq (cv z) (cv z))
  (@equtr_b2 z x3)


/-- Commuted version of ~ equeucl (equality is left-Euclidean). (Contributed by BJ, 12-Apr-2021.) -/
theorem equeuclr
  (x3 y z : setvar) : ⊦ wi (wceq (cv x3) (cv z)) (wi (wceq (cv y) (cv z)) (wceq (cv y) (cv x3))) :=
@equcoms (λ z x3, wi (wceq (cv y) (cv z)) (wceq (cv y) (cv x3)))
  (λ z x3, @equtrr x3 z y) z x3


/-- Commuted version of ~ equeucl (equality is left-Euclidean). (Contributed by BJ, 12-Apr-2021.) -/
theorem equeuclr_b
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))) :=
@equcoms_b (λ x3, wi (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)))
  (λ x3, @equtrr_b x3) x3


/-- Commuted version of ~ equeucl (equality is left-Euclidean). (Contributed by BJ, 12-Apr-2021.) -/
theorem equeuclr_b1
  (x3 z : setvar) : ⊦ wi (wceq (cv x3) (cv z)) (wi (wceq (cv x3) (cv z)) (wceq (cv x3) (cv x3))) :=
@equcoms (λ z x3, wi (wceq (cv x3) (cv z)) (wceq (cv x3) (cv x3)))
  (λ z x3, @equtrr_b2 z x3) z x3


/-- Commuted version of ~ equeucl (equality is left-Euclidean). (Contributed by BJ, 12-Apr-2021.) -/
theorem equeuclr_b2
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wceq (cv y) (cv y)) (wceq (cv y) (cv x3))) :=
@equcoms (λ y x3, wi (wceq (cv y) (cv y)) (wceq (cv y) (cv x3)))
  (λ y x3, @equtrr_b1 x3 y) y x3


/-- Equality is a left-Euclidean binary relation. (Right-Euclideanness is stated in ~ ax-7 .)
Curried (exported) form of ~ equtr2 . (Contributed by BJ, 11-Apr-2021.) -/
theorem equeucl
  (x3 y z : setvar) : ⊦ wi (wceq (cv x3) (cv z)) (wi (wceq (cv y) (cv z)) (wceq (cv x3) (cv y))) :=
@com12 (wceq (cv y) (cv z)) (wceq (cv x3) (cv z)) (wceq (cv x3) (cv y))
  (@equeuclr y x3 z)


/-- Equality is a left-Euclidean binary relation. (Right-Euclideanness is stated in ~ ax-7 .)
Curried (exported) form of ~ equtr2 . (Contributed by BJ, 11-Apr-2021.) -/
theorem equeucl_b
  (x3 z : setvar) : ⊦ wi (wceq (cv x3) (cv z)) (wi (wceq (cv x3) (cv z)) (wceq (cv x3) (cv x3))) :=
@com12 (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z)) (wceq (cv x3) (cv x3))
  (@equeuclr_b1 x3 z)


/-- Equality is a left-Euclidean binary relation. (Right-Euclideanness is stated in ~ ax-7 .)
Curried (exported) form of ~ equtr2 . (Contributed by BJ, 11-Apr-2021.) -/
theorem equeucl_b1
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (wceq (cv y) (cv x3)) (wceq (cv x3) (cv y))) :=
@com12 (wceq (cv y) (cv x3)) (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv y))
  (@equeuclr_b2 y x3)


/-- An equivalence law for equality. (Contributed by NM, 1-Aug-1993.) (Proof shortened by Wolf
Lammen, 10-Dec-2017.) -/
theorem equequ1 {z : setvar}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) :=
@impbid (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))
  (@ax7 x3 y z)
  (@equtr z x3 y)


/-- An equivalence law for equality. (Contributed by NM, 1-Aug-1993.) (Proof shortened by Wolf
Lammen, 10-Dec-2017.) -/
theorem equequ1_b
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))) :=
@impbid (wceq (cv x3) (cv y)) (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3))
  (@ax7_b2 x3 y)
  (@equtr_b2 x3 y)


/-- An equivalence law for equality. (Contributed by NM, 1-Aug-1993.) (Proof shortened by Wolf
Lammen, 10-Dec-2017.) -/
theorem equequ1_b1
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wceq (cv x3) (cv y)) (wceq (cv y) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wceq (cv x3) (cv y)) (wceq (cv y) (cv y))
  (@ax7_b3 x3 y)
  (@equtr_b3 x3 y)


/-- An equivalence law for equality. (Contributed by NM, 21-Jun-1993.) (Proof shortened by Wolf
Lammen, 4-Aug-2017.) (Proof shortened by BJ, 12-Apr-2021.) -/
theorem equequ2
  (x3 y z : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wceq (cv z) (cv x3)) (wceq (cv z) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wceq (cv z) (cv x3)) (wceq (cv z) (cv y))
  (@equtrr y x3 z)
  (@equeuclr x3 z y)


/-- An equivalence law for equality. (Contributed by NM, 21-Jun-1993.) (Proof shortened by Wolf
Lammen, 4-Aug-2017.) (Proof shortened by BJ, 12-Apr-2021.) -/
theorem equequ2_b
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wb (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))) :=
@impbid (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv x3))
  (@equtrr_b x3)
  (@equeuclr_b x3)


/-- An equivalence law for equality. (Contributed by NM, 21-Jun-1993.) (Proof shortened by Wolf
Lammen, 4-Aug-2017.) (Proof shortened by BJ, 12-Apr-2021.) -/
theorem equequ2_b1
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv y))
  (@equtrr_b1 y x3)
  (@equeuclr_b1 x3 y)


/-- An equivalence law for equality. (Contributed by NM, 21-Jun-1993.) (Proof shortened by Wolf
Lammen, 4-Aug-2017.) (Proof shortened by BJ, 12-Apr-2021.) -/
theorem equequ2_b2
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wceq (cv y) (cv x3)) (wceq (cv y) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wceq (cv y) (cv x3)) (wceq (cv y) (cv y))
  (@equtrr_b2 x3 y)
  (@equeuclr_b2 x3 y)


/-- Equality is a left-Euclidean binary relation. Uncurried (imported) form of ~ equeucl .
(Contributed by NM, 12-Aug-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened
by BJ, 11-Apr-2021.) -/
theorem equtr2
  (x3 y z : setvar) : ⊦ wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) (wceq (cv x3) (cv y)) :=
@imp (wceq (cv x3) (cv z)) (wceq (cv y) (cv z)) (wceq (cv x3) (cv y))
  (@equeucl x3 y z)


/-- Equality is a left-Euclidean binary relation. Uncurried (imported) form of ~ equeucl .
(Contributed by NM, 12-Aug-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened
by BJ, 11-Apr-2021.) -/
theorem equtr2_b
  (x3 z : setvar) : ⊦ wi (wa (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z))) (wceq (cv x3) (cv x3)) :=
@imp (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z)) (wceq (cv x3) (cv x3))
  (@equeucl_b x3 z)


/-- A variable introduction law for equality. Lemma 15 of [Monk2] p. 109. (Contributed by NM,
9-Jan-1993.) Remove dependencies on ~ ax-10 , ~ ax-13 . (Revised by Wolf Lammen, 10-Jun-2019.) Move
the quantified variable ( ` z ` ) to the left of the equality signs. (Revised by Wolf Lammen,
11-Apr-2021.) (Proof shortened by Wolf Lammen, 12-Jul-2022.) -/
theorem equvinv {y : setvar}
  (x3 : setvar) : ⊦ wb (wceq (cv x3) (cv y)) (wex (λ z, wa (wceq (cv z) (cv x3)) (wceq (cv z) (cv y)))) :=
@bicomi (wex (λ z, wa (wceq (cv z) (cv x3)) (wceq (cv z) (cv y)))) (wceq (cv x3) (cv y))
  (@equsexvw (λ z x3, wceq (cv z) (cv y)) (λ x3, wceq (cv x3) (cv y))
    (λ z x3, @equequ1 y z x3) x3)


/-- A variable introduction law for equality. Lemma 15 of [Monk2] p. 109. (Contributed by NM,
9-Jan-1993.) Remove dependencies on ~ ax-10 , ~ ax-13 . (Revised by Wolf Lammen, 10-Jun-2019.) Move
the quantified variable ( ` z ` ) to the left of the equality signs. (Revised by Wolf Lammen,
11-Apr-2021.) (Proof shortened by Wolf Lammen, 12-Jul-2022.) -/
theorem equvinv_b
  (x3 : setvar) : ⊦ wb (wceq (cv x3) (cv x3)) (wex (λ z, wa (wceq (cv z) (cv x3)) (wceq (cv z) (cv x3)))) :=
@bicomi (wex (λ z, wa (wceq (cv z) (cv x3)) (wceq (cv z) (cv x3)))) (wceq (cv x3) (cv x3))
  (@equsexvw (λ z x3, wceq (cv z) (cv x3)) (λ x3, wceq (cv x3) (cv x3))
    (λ z x3, @equequ1_b1 z x3) x3)


/-- A modified version of the forward implication of ~ equvinv adapted to common usage. (Contributed
by Wolf Lammen, 8-Sep-2018.) -/
theorem equvinva
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wex (λ z, wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv z)))) :=
@mpi (wceq (cv x3) (cv y)) (wex (λ z, wceq (cv y) (cv z))) (wex (λ z, wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))))
  (@ax6evr y)
  (@eximdv (wceq (cv x3) (cv y)) (λ z, wceq (cv y) (cv z)) (λ z, wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv z)))
    (λ z, @ancrd (wceq (cv x3) (cv y)) (wceq (cv y) (cv z)) (wceq (cv x3) (cv z))
      (@equtr z x3 y)))


/-- A modified version of the forward implication of ~ equvinv adapted to common usage. (Contributed
by Wolf Lammen, 8-Sep-2018.) -/
theorem equvinva_b
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wex (λ z, wa (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z)))) :=
@mpi (wceq (cv x3) (cv x3)) (wex (λ z, wceq (cv x3) (cv z))) (wex (λ z, wa (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z))))
  (@ax6evr x3)
  (@eximdv (wceq (cv x3) (cv x3)) (λ z, wceq (cv x3) (cv z)) (λ z, wa (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z)))
    (λ z, @ancrd (wceq (cv x3) (cv x3)) (wceq (cv x3) (cv z)) (wceq (cv x3) (cv z))
      (@equtr_b1 z x3)))


/-- Weak version of ~ sp . Uses only Tarski's FOL axiom schemes. Lemma 9 of [KalishMontague] p. 87.
This may be the best we can do with minimal distinct variable conditions. (Contributed by NM,
19-Apr-2017.) (Proof shortened by Wolf Lammen, 10-Oct-2021.) -/
theorem spfw {ph ps : setvar → setvar → wff}
  (spfw_1 : ∀ x3 y, ⊦ wi (wn (ps x3 y)) (wal (λ x3, wn (ps x3 y))))
  (spfw_2 : ∀ y, ⊦ wi (wal (λ x3, ph x3 y)) (wal (λ y, wal (λ x3, ph x3 y))))
  (spfw_3 : ∀ x3 y, ⊦ wi (wn (ph x3 y)) (wal (λ y, wn (ph x3 y))))
  (spfw_4 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, ph x3 y)) (ph x3 y) :=
@syl (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y)) (ph x3 y)
  (@cbvaliw (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ y, spfw_2 y)
    (λ x3 y, spfw_1 x3 y)
    (λ x3 y, @biimpd (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
      (spfw_4 x3 y)) x3 y)
  (@spimw (λ y x3, ps x3 y) (λ y x3, ph x3 y)
    (λ y x3, spfw_3 x3 y)
    (λ y x3, @equcoms (λ x3 y, wi (ps x3 y) (ph x3 y))
      (λ x3 y, @biimprd (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
        (spfw_4 x3 y)) x3 y) y x3)


/-- Weak version of the specialization scheme ~ sp . Lemma 9 of [KalishMontague] p. 87. While it
appears that ~ sp in its general form does not follow from Tarski's FOL axiom schemes, from this
theorem we can prove any _instance_ of ~ sp having mutually distinct setvar variables and no wff
metavariables (see ~ ax12wdemo for an example of the procedure to eliminate the hypothesis). Other
approximations of ~ sp are ~ spfw (minimal distinct variable requirements), ~ spnfw (when ` x ` is
not free in ` -. ph ` ), ~ spvw (when ` x ` does not appear in ` ph ` ), ~ sptruw (when ` ph ` is
true), ~ spfalw (when ` ph ` is false), and ~ spvv (where ` ph ` is changed into ` ps ` ).
(Contributed by NM, 9-Apr-2017.) (Proof shortened by Wolf Lammen, 27-Feb-2018.) -/
theorem spw {ph ps : setvar → wff}
  (spw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y)))
  (x3 : setvar) : ⊦ wi (wal (λ x3, ph x3)) (ph x3) :=
setvar.forget $ λ y : setvar,
  show ⊦ wi (wal (λ x3, ph x3)) (ph x3), from
  @spfw (λ x3 y, ph x3) (λ x3 y, ps y)
    (λ x3 y, @ax_5 (wn (ps y)))
    (λ y, @ax_5 (wal (λ x3, ph x3)))
    (λ x3 y, @ax_5 (wn (ph x3)))
    (λ x3 y, spw_1 x3 y) x3 y


/-- Change bound variable. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 9-Apr-2017.) -/
theorem cbvalw {ph ps : setvar → setvar → wff}
  (cbvalw_1 : ∀ y, ⊦ wi (wal (λ x3, ph x3 y)) (wal (λ y, wal (λ x3, ph x3 y))))
  (cbvalw_2 : ∀ x3 y, ⊦ wi (wn (ps x3 y)) (wal (λ x3, wn (ps x3 y))))
  (cbvalw_3 : ∀ x3, ⊦ wi (wal (λ y, ps x3 y)) (wal (λ x3, wal (λ y, ps x3 y))))
  (cbvalw_4 : ∀ x3 y, ⊦ wi (wn (ph x3 y)) (wal (λ y, wn (ph x3 y))))
  (cbvalw_5 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y)) :=
@impbii (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y))
  (@cbvaliw (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ y, cbvalw_1 y)
    (λ x3 y, cbvalw_2 x3 y)
    (λ x3 y, @biimpd (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
      (cbvalw_5 x3 y)) x3 y)
  (@cbvaliw (λ y x3, ps x3 y) (λ y x3, ph x3 y)
    (λ x3, cbvalw_3 x3)
    (λ y x3, cbvalw_4 x3 y)
    (λ y x3, @equcoms (λ x3 y, wi (ps x3 y) (ph x3 y))
      (λ x3 y, @biimprd (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
        (cbvalw_5 x3 y)) x3 y) y x3)


/-- Change bound variable. Uses only Tarski's FOL axiom schemes. See ~ cbvalv for a version with
fewer disjoint variable conditions but requiring more axioms. (Contributed by NM, 9-Apr-2017.)
(Proof shortened by Wolf Lammen, 28-Feb-2018.) -/
theorem cbvalvw {ph ps : setvar → wff}
  (cbvalvw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wb (wal (λ x3, ph x3)) (wal (λ y, ps y)) :=
setvar.forget $ λ x3 : setvar,
  setvar.forget $ λ y : setvar,
  show ⊦ wb (wal (λ x3, ph x3)) (wal (λ y, ps y)), from
  @cbvalw (λ x3 y, ph x3) (λ x3 y, ps y)
    (λ y, @ax_5 (wal (λ x3, ph x3)))
    (λ x3 y, @ax_5 (wn (ps y)))
    (λ x3, @ax_5 (wal (λ y, ps y)))
    (λ x3 y, @ax_5 (wn (ph x3)))
    (λ x3 y, cbvalvw_1 x3 y) x3 y


/-- Change bound variable. Uses only Tarski's FOL axiom schemes. See ~ cbvexv for a version with
fewer disjoint variable conditions but requiring more axioms. (Contributed by NM, 19-Apr-2017.) -/
theorem cbvexvw {ph ps : setvar → wff}
  (cbvalvw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wb (wex (λ x3, ph x3)) (wex (λ y, ps y)) :=
@«3bitr4i» (wn (wal (λ x3, wn (ph x3)))) (wn (wal (λ y, wn (ps y)))) (wex (λ x3, ph x3)) (wex (λ y, ps y))
  (@notbii (wal (λ x3, wn (ph x3))) (wal (λ y, wn (ps y)))
    (@cbvalvw (λ x3, wn (ph x3)) (λ y, wn (ps y))
      (λ x3 y, @notbid (wceq (cv x3) (cv y)) (ph x3) (ps y)
        (cbvalvw_1 x3 y))))
  (@df_ex (λ x3, ph x3))
  (@df_ex (λ y, ps y))


/-- Rule used to change the bound variable in a universal quantifier with implicit substitution.
Deduction form. Version of ~ cbvaldva with a disjoint variable condition, requiring fewer axioms.
(Contributed by David Moews, 1-May-2017.) (Revised by Gino Giotto, 10-Jan-2024.) Reduce axiom usage,
along an idea of Gino Giotto. (Revised by Wolf Lammen, 10-Feb-2024.) -/
theorem cbvaldvaw {ph : wff} {ps ch : setvar → wff}
  (cbvaldvaw_1 : ∀ x3 y, ⊦ wi (wa ph (wceq (cv x3) (cv y))) (wb (ps x3) (ch y))) :
  ⊦ wi ph (wb (wal (λ x3, ps x3)) (wal (λ y, ch y))) :=
@pm5_74ri ph (wal (λ x3, ps x3)) (wal (λ y, ch y))
  (@«3bitr3i» (wal (λ x3, wi ph (ps x3))) (wal (λ y, wi ph (ch y))) (wi ph (wal (λ x3, ps x3))) (wi ph (wal (λ y, ch y)))
    (@cbvalvw (λ x3, wi ph (ps x3)) (λ y, wi ph (ch y))
      (λ x3 y, @pm5_74da (wceq (cv x3) (cv y)) ph (ps x3) (ch y)
        (@ancoms ph (wceq (cv x3) (cv y)) (wb (ps x3) (ch y))
          (cbvaldvaw_1 x3 y))))
    (@«19_21v» ph (λ x3, ps x3))
    (@«19_21v» ph (λ y, ch y)))


/-- Rule used to change the bound variable in an existential quantifier with implicit substitution.
Deduction form. Version of ~ cbvexdva with a disjoint variable condition, requiring fewer axioms.
(Contributed by David Moews, 1-May-2017.) (Revised by Gino Giotto, 10-Jan-2024.) Reduce axiom usage.
(Revised by Wolf Lammen, 10-Feb-2024.) -/
theorem cbvexdvaw {ph : wff} {ps ch : setvar → wff}
  (cbvaldvaw_1 : ∀ x3 y, ⊦ wi (wa ph (wceq (cv x3) (cv y))) (wb (ps x3) (ch y))) :
  ⊦ wi ph (wb (wex (λ x3, ps x3)) (wex (λ y, ch y))) :=
@con4bid ph (wex (λ x3, ps x3)) (wex (λ y, ch y))
  (@«3bitr3g» ph (wal (λ x3, wn (ps x3))) (wal (λ y, wn (ch y))) (wn (wex (λ x3, ps x3))) (wn (wex (λ y, ch y)))
    (@cbvaldvaw ph (λ x3, wn (ps x3)) (λ y, wn (ch y))
      (λ x3 y, @notbid (wa ph (wceq (cv x3) (cv y))) (ps x3) (ch y)
        (cbvaldvaw_1 x3 y)))
    (@alnex (λ x3, ps x3))
    (@alnex (λ y, ch y)))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbval2vv with
more disjoint variable conditions, which requires fewer axioms . (Contributed by NM, 4-Feb-2005.)
(Revised by Gino Giotto, 10-Jan-2024.) -/
theorem cbval2vw {ph ps : setvar → setvar → wff}
  (cbval2vw_1 : ∀ x3 y z w, ⊦ wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (wb (ph x3 y) (ps z w))) :
  ⊦ wb (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ z, wal (λ w, ps z w))) :=
@cbvalvw (λ x3, wal (λ y, ph x3 y)) (λ z, wal (λ w, ps z w))
  (λ x3 z, @cbvaldvaw (wceq (cv x3) (cv z)) (λ y, ph x3 y) (λ w, ps z w)
    (λ y w, cbval2vw_1 x3 y z w))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbvex2vv with
more disjoint variable conditions, which requires fewer axioms . (Contributed by NM, 26-Jul-1995.)
(Revised by Gino Giotto, 10-Jan-2024.) -/
theorem cbvex2vw {ph ps : setvar → setvar → wff}
  (cbval2vw_1 : ∀ x3 y z w, ⊦ wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (wb (ph x3 y) (ps z w))) :
  ⊦ wb (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ z, wex (λ w, ps z w))) :=
@cbvexvw (λ x3, wex (λ y, ph x3 y)) (λ z, wex (λ w, ps z w))
  (λ x3 z, @cbvexdvaw (wceq (cv x3) (cv z)) (λ y, ph x3 y) (λ w, ps z w)
    (λ y w, cbval2vw_1 x3 y z w))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbvex4v with more
disjoint variable conditions, which requires fewer axioms. (Contributed by NM, 26-Jul-1995.)
(Revised by Gino Giotto, 10-Jan-2024.) -/
theorem cbvex4vw {ph : setvar → setvar → setvar → setvar → setvar → setvar → wff} {ps : setvar → setvar → setvar → setvar → wff} {ch : setvar → setvar → setvar → setvar → setvar → setvar → wff}
  (cbvex4vw_1 : ∀ x3 y z w v u f g, ⊦ wi (wa (wceq (cv x3) (cv v)) (wceq (cv y) (cv u))) (wb (ph x3 y z w f g) (ps z w v u)))
  (cbvex4vw_2 : ∀ x3 y z w v u f g, ⊦ wi (wa (wceq (cv z) (cv f)) (wceq (cv w) (cv g))) (wb (ps z w v u) (ch x3 y v u f g)))
  (x3 y f g : setvar) : ⊦ wb (wex (λ x3, wex (λ y, wex (λ z, wex (λ w, ph x3 y z w f g))))) (wex (λ v, wex (λ u, wex (λ f, wex (λ g, ch x3 y v u f g))))) :=
@bitri (wex (λ x3, wex (λ y, wex (λ z, wex (λ w, ph x3 y z w f g))))) (wex (λ v, wex (λ u, wex (λ z, wex (λ w, ps z w v u))))) (wex (λ v, wex (λ u, wex (λ f, wex (λ g, ch x3 y v u f g)))))
  (@cbvex2vw (λ x3 y, wex (λ z, wex (λ w, ph x3 y z w f g))) (λ v u, wex (λ z, wex (λ w, ps z w v u)))
    (λ x3 y v u, @«2exbidv» (wa (wceq (cv x3) (cv v)) (wceq (cv y) (cv u))) (λ z w, ph x3 y z w f g) (λ z w, ps z w v u)
      (λ z w, cbvex4vw_1 x3 y z w v u f g)))
  (@«2exbii» (λ v u, wex (λ z, wex (λ w, ps z w v u))) (λ v u, wex (λ f, wex (λ g, ch x3 y v u f g)))
    (λ v u, @cbvex2vw (λ z w, ps z w v u) (λ f g, ch x3 y v u f g)
      (λ z w f g, cbvex4vw_2 x3 y z w v u f g)))


/-- Weak version of ~ alcom . Uses only Tarski's FOL axiom schemes. (Contributed by NM,
10-Apr-2017.) (Proof shortened by Wolf Lammen, 28-Dec-2023.) -/
theorem alcomiw {ph ps : setvar → setvar → wff}
  (alcomiw_1 : ∀ x3 y z, ⊦ wi (wceq (cv y) (cv z)) (wb (ph x3 y) (ps x3 z))) :
  ⊦ wi (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ y, wal (λ x3, ph x3 y))) :=
@«3syl» (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ x3, wal (λ z, ps x3 z))) (wal (λ y, wal (λ x3, wal (λ z, ps x3 z)))) (wal (λ y, wal (λ x3, ph x3 y)))
  (@alimi (λ x3, wal (λ y, ph x3 y)) (λ x3, wal (λ z, ps x3 z))
    (λ x3, @biimpi (wal (λ y, ph x3 y)) (wal (λ z, ps x3 z))
      (@cbvalvw (λ y, ph x3 y) (λ z, ps x3 z)
        (λ y z, alcomiw_1 x3 y z))))
  (@ax_5 (wal (λ x3, wal (λ z, ps x3 z))))
  (@«2alimi» (λ y x3, wal (λ z, ps x3 z)) (λ y x3, ph x3 y)
    (λ y x3, @spimvw (λ z y, ps x3 z) (λ y, ph x3 y)
      (λ z y, @equcoms (λ y z, wi (ps x3 z) (ph x3 y))
        (λ y z, @biimprd (wceq (cv y) (cv z)) (ph x3 y) (ps x3 z)
          (alcomiw_1 x3 y z)) y z) y))


/-- Weak version of ~ ax-10 from which we can prove any ~ ax-10 instance not involving wff variables
or bundling. Uses only Tarski's FOL axiom schemes. (Contributed by NM, 19-Apr-2017.) (Proof
shortened by Wolf Lammen, 28-Feb-2018.) -/
theorem hbn1fw {ph ps : setvar → setvar → wff}
  (hbn1fw_1 : ∀ y, ⊦ wi (wal (λ x3, ph x3 y)) (wal (λ y, wal (λ x3, ph x3 y))))
  (hbn1fw_2 : ∀ x3 y, ⊦ wi (wn (ps x3 y)) (wal (λ x3, wn (ps x3 y))))
  (hbn1fw_3 : ∀ x3, ⊦ wi (wal (λ y, ps x3 y)) (wal (λ x3, wal (λ y, ps x3 y))))
  (hbn1fw_4 : ∀ x3 y, ⊦ wi (wn (ph x3 y)) (wal (λ y, wn (ph x3 y))))
  (hbn1fw_5 : ∀ x3, ⊦ wi (wn (wal (λ y, ps x3 y))) (wal (λ x3, wn (wal (λ y, ps x3 y)))))
  (hbn1fw_6 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (y : setvar) : ⊦ wi (wn (wal (λ x3, ph x3 y))) (wal (λ x3, wn (wal (λ x3, ph x3 y)))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wn (wal (λ x3, ph x3 y))) (wal (λ x3, wn (wal (λ x3, ph x3 y)))), from
  @hbxfrbi (λ x3, wn (wal (λ x3, ph x3 y))) (λ x3, wn (wal (λ y, ps x3 y)))
    (λ x3, @notbii (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y))
      (@cbvalw (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
        (λ y, hbn1fw_1 y)
        (λ x3 y, hbn1fw_2 x3 y)
        (λ x3, hbn1fw_3 x3)
        (λ x3 y, hbn1fw_4 x3 y)
        (λ x3 y, hbn1fw_6 x3 y) x3 y))
    (λ x3, hbn1fw_5 x3) x3


/-- Weak version of ~ hbn1 . Uses only Tarski's FOL axiom schemes. (Contributed by NM, 9-Apr-2017.)
-/
theorem hbn1w {ph ps : setvar → wff}
  (hbn1w_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wi (wn (wal (λ x3, ph x3))) (wal (λ x3, wn (wal (λ x3, ph x3)))) :=
setvar.forget $ λ y : setvar,
  show ⊦ wi (wn (wal (λ x3, ph x3))) (wal (λ x3, wn (wal (λ x3, ph x3)))), from
  @hbn1fw (λ x3 y, ph x3) (λ x3 y, ps y)
    (λ y, @ax_5 (wal (λ x3, ph x3)))
    (λ x3 y, @ax_5 (wn (ps y)))
    (λ x3, @ax_5 (wal (λ y, ps y)))
    (λ x3 y, @ax_5 (wn (ph x3)))
    (λ x3, @ax_5 (wn (wal (λ y, ps y))))
    (λ x3 y, hbn1w_1 x3 y) y


/-- Weak version of ~ hba1 . See comments for ~ ax10w . Uses only Tarski's FOL axiom schemes.
(Contributed by NM, 9-Apr-2017.) (Proof shortened by Wolf Lammen, 10-Oct-2021.) -/
theorem hba1w {ph ps : setvar → wff}
  (hbn1w_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wi (wal (λ x3, ph x3)) (wal (λ x3, wal (λ x3, ph x3))) :=
@«3syl» (wal (λ x3, ph x3)) (wn (wal (λ x3, wn (wal (λ x3, ph x3))))) (wal (λ x3, wn (wal (λ x3, wn (wal (λ x3, ph x3)))))) (wal (λ x3, wal (λ x3, ph x3)))
  (@con2i (wal (λ x3, wn (wal (λ x3, ph x3)))) (wal (λ x3, ph x3))
    (setvar.forget $ λ x3 : setvar,
      show ⊦ wi (wal (λ x3, wn (wal (λ x3, ph x3)))) (wn (wal (λ x3, ph x3))), from
      @spw (λ x3, wn (wal (λ x3, ph x3))) (λ y, wn (wal (λ y, ps y)))
        (λ x3 y, @a1i (wb (wn (wal (λ x3, ph x3))) (wn (wal (λ y, ps y)))) (wceq (cv x3) (cv y))
          (@notbii (wal (λ x3, ph x3)) (wal (λ y, ps y))
            (@cbvalvw (λ x3, ph x3) (λ y, ps y)
              (λ x3 y, hbn1w_1 x3 y)))) x3))
  (@hbn1w (λ x3, wn (wal (λ x3, ph x3))) (λ y, wn (wal (λ y, ps y)))
    (λ x3 y, @a1i (wb (wn (wal (λ x3, ph x3))) (wn (wal (λ y, ps y)))) (wceq (cv x3) (cv y))
      (@notbii (wal (λ x3, ph x3)) (wal (λ y, ps y))
        (@cbvalvw (λ x3, ph x3) (λ y, ps y)
          (λ x3 y, hbn1w_1 x3 y)))))
  (@alimi (λ x3, wn (wal (λ x3, wn (wal (λ x3, ph x3))))) (λ x3, wal (λ x3, ph x3))
    (λ x3, @con1i (wal (λ x3, ph x3)) (wal (λ x3, wn (wal (λ x3, ph x3))))
      (@hbn1w (λ x3, ph x3) (λ y, ps y)
        (λ x3 y, hbn1w_1 x3 y))))


/-- A special instance of ~ sp applied to an equality with a disjoint variable condition. Unlike the
more general ~ sp , we can prove this without ~ ax-12 . Instance of ~ aeveq . The antecedent ` A. x
x = y ` with distinct ` x ` and ` y ` is a characteristic of a degenerate universe, in which just
one object exists. Actually more than one object may still exist, but if so, we give up on equality
as a discriminating term. Separating this degenerate case from a richer universe, where inequality
is possible, is a common proof idea. The name of this theorem follows a convention, where the
condition ` A. x x = y ` is denoted by 'aev', a shorthand for 'all equal, with a distinct variable
condition'. (Contributed by Wolf Lammen, 14-Mar-2021.) -/
theorem spaev {y : setvar}
  (x3 : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wceq (cv x3) (cv y)) :=
@spw (λ x3, wceq (cv x3) (cv y)) (λ z, wceq (cv z) (cv y))
  (λ x3 z, @equequ1 y x3 z) x3


/-- Change bound variable in an equality with a disjoint variable condition. Instance of ~ aev .
(Contributed by NM, 22-Jul-2015.) (Revised by BJ, 18-Jun-2019.) -/
theorem cbvaev {y : setvar} :
  ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv y))) :=
@syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ t, wceq (cv t) (cv y))) (wal (λ z, wceq (cv z) (cv y)))
  (@cbvalivw (λ x3, wceq (cv x3) (cv y)) (λ t, wceq (cv t) (cv y))
    (λ x3 t, @ax7 x3 t y))
  (@cbvalivw (λ t, wceq (cv t) (cv y)) (λ z, wceq (cv z) (cv y))
    (λ t z, @ax7 t z y))


/-- Change bound variable in an equality with a disjoint variable condition. Instance of ~ aev .
(Contributed by NM, 22-Jul-2015.) (Revised by BJ, 18-Jun-2019.) -/
theorem cbvaev_b {y : setvar} :
  ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv y))) :=
@syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ t, wceq (cv t) (cv y))) (wal (λ x3, wceq (cv x3) (cv y)))
  (@cbvalivw (λ x3, wceq (cv x3) (cv y)) (λ t, wceq (cv t) (cv y))
    (λ x3 t, @ax7 x3 t y))
  (@cbvalivw (λ t, wceq (cv t) (cv y)) (λ x3, wceq (cv x3) (cv y))
    (λ t x3, @ax7 t x3 y))


/-- Lemma for ~ aevlem . Instance of ~ aev . (Contributed by NM, 8-Jul-2016.) (Proof shortened by
Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 14-Mar-2021.)
(Revised by BJ, 29-Mar-2021.) (Proof shortened by Wolf Lammen, 30-Mar-2021.) -/
theorem aevlem0
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv x3))) :=
@sylc (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv y))) (wal (λ z, wceq (cv z) (cv x3)))
  (@alrimiv (wal (λ x3, wceq (cv x3) (cv y))) (λ z, wceq (cv x3) (cv y))
    (λ z, @spaev y x3))
  (@cbvaev y)
  (@al2imi (λ z, wceq (cv x3) (cv y)) (λ z, wceq (cv z) (cv y)) (λ z, wceq (cv z) (cv x3))
    (λ z, @equeuclr x3 z y))


/-- Lemma for ~ aev and ~ axc16g . Change free and bound variables. Instance of ~ aev . (Contributed
by NM, 22-Jul-2015.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 29-Mar-2021.) -/
theorem aevlem
  (y t : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv t))) :=
setvar.forget $ λ u : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv t))), from
  @«4syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ t, wceq (cv t) (cv u))) (wal (λ z, wceq (cv z) (cv t)))
    (@cbvaev y)
    (@aevlem0 u y)
    (@cbvaev u)
    (@aevlem0 t u)


/-- Lemma for ~ aev and ~ axc16g . Change free and bound variables. Instance of ~ aev . (Contributed
by NM, 22-Jul-2015.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 29-Mar-2021.) -/
theorem aevlem_b
  (y t : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv t))) :=
setvar.forget $ λ u : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv t))), from
  @«4syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ t, wceq (cv t) (cv u))) (wal (λ x3, wceq (cv x3) (cv t)))
    (@cbvaev y)
    (@aevlem0 u y)
    (@cbvaev u)
    (@aevlem0 t u)


/-- Lemma for ~ aev and ~ axc16g . Change free and bound variables. Instance of ~ aev . (Contributed
by NM, 22-Jul-2015.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 29-Mar-2021.) -/
theorem aevlem_b1
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ y, wceq (cv y) (cv x3))) :=
setvar.forget $ λ u : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ y, wceq (cv y) (cv x3))), from
  @«4syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ y, wceq (cv y) (cv x3)))
    (@cbvaev y)
    (@aevlem0 u y)
    (@cbvaev_b u)
    (@aevlem0 x3 u)


/-- Lemma for ~ aev and ~ axc16g . Change free and bound variables. Instance of ~ aev . (Contributed
by NM, 22-Jul-2015.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 29-Mar-2021.) -/
theorem aevlem_b2
  (y t : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ y, wceq (cv y) (cv t))) :=
setvar.forget $ λ u : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ y, wceq (cv y) (cv t))), from
  @«4syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ t, wceq (cv t) (cv u))) (wal (λ y, wceq (cv y) (cv t)))
    (@cbvaev y)
    (@aevlem0 u y)
    (@cbvaev u)
    (@aevlem0 t u)


/-- Lemma for ~ aev and ~ axc16g . Change free and bound variables. Instance of ~ aev . (Contributed
by NM, 22-Jul-2015.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 29-Mar-2021.) -/
theorem aevlem_b3
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv x3))) :=
setvar.forget $ λ u : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv x3))), from
  @«4syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ z, wceq (cv z) (cv x3)))
    (@cbvaev y)
    (@aevlem0 u y)
    (@cbvaev_b u)
    (@aevlem0 x3 u)


/-- Lemma for ~ aev and ~ axc16g . Change free and bound variables. Instance of ~ aev . (Contributed
by NM, 22-Jul-2015.) (Proof shortened by Wolf Lammen, 17-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 29-Mar-2021.) -/
theorem aevlem_b4
  (y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv y))) :=
setvar.forget $ λ u : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv y))), from
  @«4syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))) (wal (λ y, wceq (cv y) (cv u))) (wal (λ z, wceq (cv z) (cv y)))
    (@cbvaev y)
    (@aevlem0 u y)
    (@cbvaev u)
    (@aevlem0 y u)


/-- The antecedent ` A. x x = y ` with a disjoint variable condition (typical of a one-object
universe) forces equality of everything. (Contributed by Wolf Lammen, 19-Mar-2021.) -/
theorem aeveq {t : setvar}
  (y z : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wceq (cv z) (cv t)) :=
@«3syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv z))) (wex (λ u, wceq (cv z) (cv t))) (wceq (cv z) (cv t))
  (@aevlem y z)
  (@mpi (wal (λ u, wceq (cv u) (cv z))) (wex (λ u, wceq (cv u) (cv t))) (wex (λ u, wceq (cv z) (cv t)))
    (@ax6ev t)
    (@aleximi (λ u, wceq (cv u) (cv z)) (λ u, wceq (cv u) (cv t)) (λ u, wceq (cv z) (cv t))
      (λ u, @ax7 u z t)))
  (@ax5e (wceq (cv z) (cv t)))


/-- The antecedent ` A. x x = y ` with a disjoint variable condition (typical of a one-object
universe) forces equality of everything. (Contributed by Wolf Lammen, 19-Mar-2021.) -/
theorem aeveq_b {t : setvar}
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wceq (cv x3) (cv t)) :=
@«3syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv x3))) (wex (λ u, wceq (cv x3) (cv t))) (wceq (cv x3) (cv t))
  (@aevlem_b3 x3 y)
  (@mpi (wal (λ u, wceq (cv u) (cv x3))) (wex (λ u, wceq (cv u) (cv t))) (wex (λ u, wceq (cv x3) (cv t)))
    (@ax6ev t)
    (@aleximi (λ u, wceq (cv u) (cv x3)) (λ u, wceq (cv u) (cv t)) (λ u, wceq (cv x3) (cv t))
      (λ u, @ax7 u x3 t)))
  (@ax5e (wceq (cv x3) (cv t)))


/-- The antecedent ` A. x x = y ` with a disjoint variable condition (typical of a one-object
universe) forces equality of everything. (Contributed by Wolf Lammen, 19-Mar-2021.) -/
theorem aeveq_b1 {t : setvar}
  (y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wceq (cv y) (cv t)) :=
@«3syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv y))) (wex (λ u, wceq (cv y) (cv t))) (wceq (cv y) (cv t))
  (@aevlem_b4 y)
  (@mpi (wal (λ u, wceq (cv u) (cv y))) (wex (λ u, wceq (cv u) (cv t))) (wex (λ u, wceq (cv y) (cv t)))
    (@ax6ev t)
    (@aleximi (λ u, wceq (cv u) (cv y)) (λ u, wceq (cv u) (cv t)) (λ u, wceq (cv y) (cv t))
      (λ u, @ax7 u y t)))
  (@ax5e (wceq (cv y) (cv t)))


/-- The antecedent ` A. x x = y ` with a disjoint variable condition (typical of a one-object
universe) forces equality of everything. (Contributed by Wolf Lammen, 19-Mar-2021.) -/
theorem aeveq_b2
  (y z : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wceq (cv z) (cv z)) :=
@«3syl» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ u, wceq (cv u) (cv z))) (wex (λ u, wceq (cv z) (cv z))) (wceq (cv z) (cv z))
  (@aevlem y z)
  (@mpi (wal (λ u, wceq (cv u) (cv z))) (wex (λ u, wceq (cv u) (cv z))) (wex (λ u, wceq (cv z) (cv z)))
    (@ax6ev z)
    (@aleximi (λ u, wceq (cv u) (cv z)) (λ u, wceq (cv u) (cv z)) (λ u, wceq (cv z) (cv z))
      (λ u, @ax7_b3 u z)))
  (@ax5e (wceq (cv z) (cv z)))


/-- A "distinctor elimination" lemma with no restrictions on variables in the consequent.
(Contributed by NM, 8-Nov-2006.) Remove dependency on ~ ax-11 . (Revised by Wolf Lammen,
7-Sep-2018.) Remove dependency on ~ ax-13 , inspired by an idea of BJ. (Revised by Wolf Lammen,
30-Nov-2019.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 19-Mar-2021.) -/
theorem aev {u : setvar}
  (y t : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv t) (cv u))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv t) (cv u))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ v, wceq (cv v) (cv w))) (wal (λ z, wceq (cv t) (cv u)))
    (@aevlem y w)
    (@alrimiv (wal (λ v, wceq (cv v) (cv w))) (λ z, wceq (cv t) (cv u))
      (λ z, @aeveq u w t))


/-- A "distinctor elimination" lemma with no restrictions on variables in the consequent.
(Contributed by NM, 8-Nov-2006.) Remove dependency on ~ ax-11 . (Revised by Wolf Lammen,
7-Sep-2018.) Remove dependency on ~ ax-13 , inspired by an idea of BJ. (Revised by Wolf Lammen,
30-Nov-2019.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 19-Mar-2021.) -/
theorem aev_b
  (y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv x3))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv x3))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ v, wceq (cv v) (cv w))) (wal (λ x3, wceq (cv x3) (cv x3)))
    (@aevlem y w)
    (@alrimiv (wal (λ v, wceq (cv v) (cv w))) (λ x3, wceq (cv x3) (cv x3))
      (λ x3, @aeveq_b2 w x3))


/-- A "distinctor elimination" lemma with no restrictions on variables in the consequent.
(Contributed by NM, 8-Nov-2006.) Remove dependency on ~ ax-11 . (Revised by Wolf Lammen,
7-Sep-2018.) Remove dependency on ~ ax-13 , inspired by an idea of BJ. (Revised by Wolf Lammen,
30-Nov-2019.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 19-Mar-2021.) -/
theorem aev_b1 {u : setvar}
  (y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv u))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ v, wceq (cv v) (cv w))) (wal (λ x3, wceq (cv x3) (cv u)))
    (@aevlem y w)
    (@alrimiv (wal (λ v, wceq (cv v) (cv w))) (λ x3, wceq (cv x3) (cv u))
      (λ x3, @aeveq u w x3))


/-- A "distinctor elimination" lemma with no restrictions on variables in the consequent.
(Contributed by NM, 8-Nov-2006.) Remove dependency on ~ ax-11 . (Revised by Wolf Lammen,
7-Sep-2018.) Remove dependency on ~ ax-13 , inspired by an idea of BJ. (Revised by Wolf Lammen,
30-Nov-2019.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 19-Mar-2021.) -/
theorem aev_b2 {u : setvar}
  (y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ y, wceq (cv y) (cv u))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ y, wceq (cv y) (cv u))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ v, wceq (cv v) (cv w))) (wal (λ y, wceq (cv y) (cv u)))
    (@aevlem y w)
    (@alrimiv (wal (λ v, wceq (cv v) (cv w))) (λ y, wceq (cv y) (cv u))
      (λ y, @aeveq u w y))


/-- A "distinctor elimination" lemma with no restrictions on variables in the consequent.
(Contributed by NM, 8-Nov-2006.) Remove dependency on ~ ax-11 . (Revised by Wolf Lammen,
7-Sep-2018.) Remove dependency on ~ ax-13 , inspired by an idea of BJ. (Revised by Wolf Lammen,
30-Nov-2019.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 19-Mar-2021.) -/
theorem aev_b3
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv x3))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv x3))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ v, wceq (cv v) (cv w))) (wal (λ z, wceq (cv z) (cv x3)))
    (@aevlem y w)
    (@alrimiv (wal (λ v, wceq (cv v) (cv w))) (λ z, wceq (cv z) (cv x3))
      (λ z, @aeveq x3 w z))


/-- A "distinctor elimination" lemma with no restrictions on variables in the consequent.
(Contributed by NM, 8-Nov-2006.) Remove dependency on ~ ax-11 . (Revised by Wolf Lammen,
7-Sep-2018.) Remove dependency on ~ ax-13 , inspired by an idea of BJ. (Revised by Wolf Lammen,
30-Nov-2019.) Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 19-Mar-2021.) -/
theorem aev_b4 {u : setvar}
  (y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv u))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv u))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ v, wceq (cv v) (cv w))) (wal (λ z, wceq (cv z) (cv u)))
    (@aevlem y w)
    (@alrimiv (wal (λ v, wceq (cv v) (cv w))) (λ z, wceq (cv z) (cv u))
      (λ z, @aeveq u w z))


/-- If some set variables can assume different values, then any two distinct set variables cannot
always be the same. (Contributed by Wolf Lammen, 10-Aug-2019.) -/
theorem naev {y : setvar}
  (v : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wn (wal (λ u, wceq (cv u) (cv v)))) :=
@con3i (wal (λ u, wceq (cv u) (cv v))) (wal (λ x3, wceq (cv x3) (cv y)))
  (@aev_b4 y v)


/-- If some set variables can assume different values, then any two distinct set variables cannot
always be the same. (Contributed by Wolf Lammen, 10-Aug-2019.) -/
theorem naev_b {y : setvar}
  (x3 : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wn (wal (λ u, wceq (cv u) (cv x3)))) :=
@con3i (wal (λ u, wceq (cv u) (cv x3))) (wal (λ x3, wceq (cv x3) (cv y)))
  (@aev_b2 y x3)


/-- If some set variables can assume different values, then any two distinct set variables cannot
always be the same. (Contributed by Wolf Lammen, 10-Aug-2019.) -/
theorem naev_b1 {y : setvar}
  (v : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wn (wal (λ x3, wceq (cv x3) (cv v)))) :=
@con3i (wal (λ x3, wceq (cv x3) (cv v))) (wal (λ x3, wceq (cv x3) (cv y)))
  (@aev_b1 y v)


/-- If some set variables can assume different values, then any two distinct set variables cannot
always be the same. (Contributed by Wolf Lammen, 10-Aug-2019.) -/
theorem naev_b2
  (v u : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv u)))) (wn (wal (λ u, wceq (cv u) (cv v)))) :=
@con3i (wal (λ u, wceq (cv u) (cv v))) (wal (λ x3, wceq (cv x3) (cv u)))
  (@aev_b3 u v)


/-- Generalization of ~ hbnaev . (Contributed by Wolf Lammen, 9-Apr-2021.) -/
theorem naev2 {y : setvar}
  (u : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wal (λ z, wn (wal (λ t, wceq (cv t) (cv u))))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wal (λ z, wn (wal (λ t, wceq (cv t) (cv u))))), from
  @«3syl» (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wn (wal (λ v, wceq (cv v) (cv w)))) (wal (λ z, wn (wal (λ v, wceq (cv v) (cv w))))) (wal (λ z, wn (wal (λ t, wceq (cv t) (cv u)))))
    (@naev y w)
    (@ax_5 (wn (wal (λ v, wceq (cv v) (cv w)))))
    (@alimi (λ z, wn (wal (λ v, wceq (cv v) (cv w)))) (λ z, wn (wal (λ t, wceq (cv t) (cv u))))
      (λ z, @naev w u))


/-- Generalization of ~ hbnaev . (Contributed by Wolf Lammen, 9-Apr-2021.) -/
theorem naev2_b
  (z : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv z)))) (wal (λ z, wn (wal (λ x3, wceq (cv x3) (cv z))))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv z)))) (wal (λ z, wn (wal (λ x3, wceq (cv x3) (cv z))))), from
  @«3syl» (wn (wal (λ x3, wceq (cv x3) (cv z)))) (wn (wal (λ v, wceq (cv v) (cv w)))) (wal (λ z, wn (wal (λ v, wceq (cv v) (cv w))))) (wal (λ z, wn (wal (λ x3, wceq (cv x3) (cv z)))))
    (@naev z w)
    (@ax_5 (wn (wal (λ v, wceq (cv v) (cv w)))))
    (@alimi (λ z, wn (wal (λ v, wceq (cv v) (cv w)))) (λ z, wn (wal (λ x3, wceq (cv x3) (cv z))))
      (λ z, @naev w z))


/-- Generalization of ~ hbnaev . (Contributed by Wolf Lammen, 9-Apr-2021.) -/
theorem naev2_b1
  (u : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv u)))) (wal (λ z, wn (wal (λ x3, wceq (cv x3) (cv u))))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv u)))) (wal (λ z, wn (wal (λ x3, wceq (cv x3) (cv u))))), from
  @«3syl» (wn (wal (λ x3, wceq (cv x3) (cv u)))) (wn (wal (λ v, wceq (cv v) (cv w)))) (wal (λ z, wn (wal (λ v, wceq (cv v) (cv w))))) (wal (λ z, wn (wal (λ x3, wceq (cv x3) (cv u)))))
    (@naev u w)
    (@ax_5 (wn (wal (λ v, wceq (cv v) (cv w)))))
    (@alimi (λ z, wn (wal (λ v, wceq (cv v) (cv w)))) (λ z, wn (wal (λ x3, wceq (cv x3) (cv u))))
      (λ z, @naev w u))


/-- Any variable is free in ` -. A. x x = y ` , if ` x ` and ` y ` are distinct. This condition is
dropped in ~ hbnae , at the expense of more axiom dependencies. Instance of ~ naev2 . (Contributed
by NM, 13-May-1993.) (Revised by Wolf Lammen, 9-Apr-2021.) -/
theorem hbnaev
  (y : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wal (λ z, wn (wal (λ x3, wceq (cv x3) (cv y))))) :=
@naev2_b1 y


/-- Any variable is free in ` -. A. x x = y ` , if ` x ` and ` y ` are distinct. This condition is
dropped in ~ hbnae , at the expense of more axiom dependencies. Instance of ~ naev2 . (Contributed
by NM, 13-May-1993.) (Revised by Wolf Lammen, 9-Apr-2021.) -/
theorem hbnaev_b
  (y : setvar) : ⊦ wi (wn (wal (λ x3, wceq (cv x3) (cv y)))) (wal (λ y, wn (wal (λ x3, wceq (cv x3) (cv y))))) :=
@naev2_b y


-- /-- Extend wff definition to include proper substitution (read "the wff that results when ` y `
-- is properly substituted for ` x ` in wff ` ph ` "). (Contributed by NM, 24-Jan-2006.) -/
-- constant wsb : (setvar → wff) → setvar → wff


-- /-- Define proper substitution. For our notation, we use ` [ t / x ] ph ` to mean "the wff that
-- results from the proper substitution of ` t ` for ` x ` in the wff ` ph ` ". That is, ` t `
-- properly replaces ` x ` . For example, ` [ t / x ] z e. x ` is the same as ` z e. t ` (when ` x `
-- and ` z ` are distinct), as shown in ~ elsb4 . Our notation was introduced in Haskell B. Curry's
-- _Foundations of Mathematical Logic_ (1977), p. 316 and is frequently used in textbooks of lambda
-- calculus and combinatory logic. This notation improves the common but ambiguous notation, " ` ph
-- ( t ) ` is the wff that results when ` t ` is properly substituted for ` x ` in ` ph ( x ) ` ".
-- For example, if the original ` ph ( x ) ` is ` x = t ` , then ` ph ( t ) ` is ` t = t ` , from
-- which we obtain that ` ph ( x ) ` is ` x = x ` . So what exactly does ` ph ( x ) ` mean? Curry's
-- notation solves this problem. A very similar notation, namely ` ( y | x ) ph ` , was introduced
-- in Bourbaki's Set Theory (Chapter 1, Description of Formal Mathematic, 1953). In most books,
-- proper substitution has a somewhat complicated recursive definition with multiple cases based on
-- the occurrences of free and bound variables in the wff. Instead, we use a single formula that is
-- exactly equivalent and gives us a direct definition. We later prove that our definition has the
-- properties we expect of proper substitution (see Theorems ~ sbequ , ~ sbcom2 and ~ sbid2v ). Note
-- that our definition is valid even when ` x ` and ` t ` are replaced with the same variable, as ~
-- sbid shows. We achieve this by applying twice Tarski's definition ~ sb6 which is valid for
-- disjoint variables, and introducing a dummy variable ` y ` which isolates ` x ` from ` t ` , as
-- in ~ dfsb7 with respect to ~ sb5 . We can also achieve this by having ` x ` free in the first
-- conjunct and bound in the second, as the alternate definition ~ dfsb1 shows. Another version that
-- mixes free and bound variables is ~ dfsb3 . When ` x ` and ` t ` are distinct, we can express
-- proper substitution with the simpler expressions of ~ sb5 and ~ sb6 . Note that the occurrences
-- of a given variable in the definiens are either all bound ( ` x , y ` ) or all free ( ` t ` ).
-- Also note that the definiens uses only primitive symbols. This double level definition will make
-- several proofs using it appear as doubled. Alternately, one could often first prove as a lemma
-- the same theorem with a disjoint variable condition on the substitute and the substituted
-- variables, and then prove the original theorem by applying this lemma twice in a row.
-- (Contributed by NM, 10-May-1993.) Revised from the original definition ~ dfsb1 . (Revised by BJ,
-- 22-Dec-2020.) -/
-- axiom df_sb {ph : setvar → wff} {t : setvar} : ⊦ wb (wsb (λ x3, ph x3) t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))))


-- /-- Define proper substitution. For our notation, we use ` [ t / x ] ph ` to mean "the wff that
-- results from the proper substitution of ` t ` for ` x ` in the wff ` ph ` ". That is, ` t `
-- properly replaces ` x ` . For example, ` [ t / x ] z e. x ` is the same as ` z e. t ` (when ` x `
-- and ` z ` are distinct), as shown in ~ elsb4 . Our notation was introduced in Haskell B. Curry's
-- _Foundations of Mathematical Logic_ (1977), p. 316 and is frequently used in textbooks of lambda
-- calculus and combinatory logic. This notation improves the common but ambiguous notation, " ` ph
-- ( t ) ` is the wff that results when ` t ` is properly substituted for ` x ` in ` ph ( x ) ` ".
-- For example, if the original ` ph ( x ) ` is ` x = t ` , then ` ph ( t ) ` is ` t = t ` , from
-- which we obtain that ` ph ( x ) ` is ` x = x ` . So what exactly does ` ph ( x ) ` mean? Curry's
-- notation solves this problem. A very similar notation, namely ` ( y | x ) ph ` , was introduced
-- in Bourbaki's Set Theory (Chapter 1, Description of Formal Mathematic, 1953). In most books,
-- proper substitution has a somewhat complicated recursive definition with multiple cases based on
-- the occurrences of free and bound variables in the wff. Instead, we use a single formula that is
-- exactly equivalent and gives us a direct definition. We later prove that our definition has the
-- properties we expect of proper substitution (see Theorems ~ sbequ , ~ sbcom2 and ~ sbid2v ). Note
-- that our definition is valid even when ` x ` and ` t ` are replaced with the same variable, as ~
-- sbid shows. We achieve this by applying twice Tarski's definition ~ sb6 which is valid for
-- disjoint variables, and introducing a dummy variable ` y ` which isolates ` x ` from ` t ` , as
-- in ~ dfsb7 with respect to ~ sb5 . We can also achieve this by having ` x ` free in the first
-- conjunct and bound in the second, as the alternate definition ~ dfsb1 shows. Another version that
-- mixes free and bound variables is ~ dfsb3 . When ` x ` and ` t ` are distinct, we can express
-- proper substitution with the simpler expressions of ~ sb5 and ~ sb6 . Note that the occurrences
-- of a given variable in the definiens are either all bound ( ` x , y ` ) or all free ( ` t ` ).
-- Also note that the definiens uses only primitive symbols. This double level definition will make
-- several proofs using it appear as doubled. Alternately, one could often first prove as a lemma
-- the same theorem with a disjoint variable condition on the substitute and the substituted
-- variables, and then prove the original theorem by applying this lemma twice in a row.
-- (Contributed by NM, 10-May-1993.) Revised from the original definition ~ dfsb1 . (Revised by BJ,
-- 22-Dec-2020.) -/
-- axiom df_sb_b {ph : setvar → wff} : ∀ x3, ⊦ wb (wsb (λ x3, ph x3) x3) (wal (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))))


/-- A substitution into a theorem yields a theorem. See ~ sbtALT for a shorter proof requiring more
axioms. See ~ chvar and ~ chvarv for versions using implicit substitution. (Contributed by NM,
21-Jan-2004.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen,
20-Jul-2018.) Revise ~ df-sb . (Revised by Steven Nguyen, 6-Jul-2023.) -/
theorem sbt {ph : setvar → wff} {t : setvar}
  (sbt_1 : ∀ x3, ⊦ ph x3) :
  ⊦ wsb (λ x3, ph x3) t :=
@mpbir (wsb (λ x3, ph x3) t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))))
  (@ax_gen (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))
    (λ y, @a1i (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wceq (cv y) (cv t))
      (@ax_gen (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))
        (λ x3, @a1i (ph x3) (wceq (cv x3) (cv y))
          (sbt_1 x3)))))
  (@df_sb (λ x3, ph x3) t)


/-- A substitution into a theorem yields a theorem. See ~ sbtALT for a shorter proof requiring more
axioms. See ~ chvar and ~ chvarv for versions using implicit substitution. (Contributed by NM,
21-Jan-2004.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen,
20-Jul-2018.) Revise ~ df-sb . (Revised by Steven Nguyen, 6-Jul-2023.) -/
theorem sbt_b {ph : setvar → wff}
  (sbt_1 : ∀ x3, ⊦ ph x3)
  (x3 : setvar) : ⊦ wsb (λ x3, ph x3) x3 :=
@mpbir (wsb (λ x3, ph x3) x3) (wal (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))))
  (@ax_gen (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))
    (λ y, @a1i (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wceq (cv y) (cv x3))
      (@ax_gen (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))
        (λ x3, @a1i (ph x3) (wceq (cv x3) (cv y))
          (sbt_1 x3)))))
  (@df_sb_b (λ x3, ph x3) x3)


/-- The specialization axiom of standard predicate calculus. It states that if a statement ` ph `
holds for all ` x ` , then it also holds for the specific case of ` t ` (properly) substituted for `
x ` . Translated to traditional notation, it can be read: " ` A. x ph ( x ) -> ph ( t ) ` , provided
that ` t ` is free for ` x ` in ` ph ( x ) ` ". Axiom 4 of [Mendelson] p. 69. See also ~ spsbc and ~
rspsbc . (Contributed by NM, 14-May-1993.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) -/
theorem stdpc4 {ph : setvar → wff} {t : setvar} :
  ⊦ wi (wal (λ x3, ph x3)) (wsb (λ x3, ph x3) t) :=
@sylibr (wal (λ x3, ph x3)) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))) (wsb (λ x3, ph x3) t)
  (@alrimiv (wal (λ x3, ph x3)) (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))
    (λ y, @a1d (wal (λ x3, ph x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wceq (cv y) (cv t))
      (@ala1 (λ x3, ph x3) (λ x3, wceq (cv x3) (cv y)))))
  (@df_sb (λ x3, ph x3) t)


/-- Distribute substitution over implication. (Contributed by NM, 14-May-1993.) Remove dependencies
on axioms. (Revised by Steven Nguyen, 24-Jul-2023.) -/
theorem sbi1 {ph ps : setvar → wff} {y : setvar} :
  ⊦ wi (wsb (λ x3, wi (ph x3) (ps x3)) y) (wi (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y)) :=
@sylbi (wsb (λ x3, wi (ph x3) (ps x3)) y) (wal (λ z, wi (wceq (cv z) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv z)) (wi (ph x3) (ps x3)))))) (wi (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y))
  (@df_sb (λ x3, wi (ph x3) (ps x3)) y)
  (@«3imtr4g» (wal (λ z, wi (wceq (cv z) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv z)) (wi (ph x3) (ps x3)))))) (wal (λ z, wi (wceq (cv z) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv z)) (ph x3))))) (wal (λ z, wi (wceq (cv z) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv z)) (ps x3))))) (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y)
    (@al2imi (λ z, wi (wceq (cv z) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv z)) (wi (ph x3) (ps x3))))) (λ z, wi (wceq (cv z) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv z)) (ph x3)))) (λ z, wi (wceq (cv z) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv z)) (ps x3))))
      (λ z, @imim3i (wal (λ x3, wi (wceq (cv x3) (cv z)) (wi (ph x3) (ps x3)))) (wal (λ x3, wi (wceq (cv x3) (cv z)) (ph x3))) (wal (λ x3, wi (wceq (cv x3) (cv z)) (ps x3))) (wceq (cv z) (cv y))
        (@al2imi (λ x3, wi (wceq (cv x3) (cv z)) (wi (ph x3) (ps x3))) (λ x3, wi (wceq (cv x3) (cv z)) (ph x3)) (λ x3, wi (wceq (cv x3) (cv z)) (ps x3))
          (λ x3, @ax_2 (wceq (cv x3) (cv z)) (ph x3) (ps x3)))))
    (@df_sb (λ x3, ph x3) y)
    (@df_sb (λ x3, ps x3) y))


/-- Distribute substitution over implication. Closed form of ~ sbimi . Specialization of
implication. (Contributed by NM, 5-Aug-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.)
Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) (Proof shortened by Steven Nguyen, 24-Jul-2023.) -/
theorem spsbim {ph ps : setvar → wff} {t : setvar} :
  ⊦ wi (wal (λ x3, wi (ph x3) (ps x3))) (wi (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t)) :=
@syl (wal (λ x3, wi (ph x3) (ps x3))) (wsb (λ x3, wi (ph x3) (ps x3)) t) (wi (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t))
  (@stdpc4 (λ x3, wi (ph x3) (ps x3)) t)
  (@sbi1 (λ x3, ph x3) (λ x3, ps x3) t)


/-- Biconditional property for substitution. Closed form of ~ sbbii . Specialization of
biconditional. (Contributed by NM, 2-Jun-1993.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) -/
theorem spsbbi {ph ps : setvar → wff} {t : setvar} :
  ⊦ wi (wal (λ x3, wb (ph x3) (ps x3))) (wb (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t)) :=
@impbid (wal (λ x3, wb (ph x3) (ps x3))) (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t)
  (@syl (wal (λ x3, wb (ph x3) (ps x3))) (wal (λ x3, wi (ph x3) (ps x3))) (wi (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t))
    (@alimi (λ x3, wb (ph x3) (ps x3)) (λ x3, wi (ph x3) (ps x3))
      (λ x3, @biimp (ph x3) (ps x3)))
    (@spsbim (λ x3, ph x3) (λ x3, ps x3) t))
  (@syl (wal (λ x3, wb (ph x3) (ps x3))) (wal (λ x3, wi (ps x3) (ph x3))) (wi (wsb (λ x3, ps x3) t) (wsb (λ x3, ph x3) t))
    (@alimi (λ x3, wb (ph x3) (ps x3)) (λ x3, wi (ps x3) (ph x3))
      (λ x3, @biimpr (ph x3) (ps x3)))
    (@spsbim (λ x3, ps x3) (λ x3, ph x3) t))


/-- Distribute substitution over implication. (Contributed by NM, 25-Jun-1998.) Revise ~ df-sb .
(Revised by BJ, 22-Dec-2020.) (Proof shortened by Steven Nguyen, 24-Jul-2023.) -/
theorem sbimi {ph ps : setvar → wff} {t : setvar}
  (sbimi_1 : ∀ x3, ⊦ wi (ph x3) (ps x3)) :
  ⊦ wi (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t) :=
@ax_mp (wsb (λ x3, wi (ph x3) (ps x3)) t) (wi (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t))
  (@sbt (λ x3, wi (ph x3) (ps x3)) t
    (λ x3, sbimi_1 x3))
  (@sbi1 (λ x3, ph x3) (λ x3, ps x3) t)


/-- Distribute substitution over implication. Compare ~ al2imi . (Contributed by Steven Nguyen,
13-Aug-2023.) -/
theorem sb2imi {ph ps ch : setvar → wff} {t : setvar}
  (sb2imi_1 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3))) :
  ⊦ wi (wsb (λ x3, ph x3) t) (wi (wsb (λ x3, ps x3) t) (wsb (λ x3, ch x3) t)) :=
@syl (wsb (λ x3, ph x3) t) (wsb (λ x3, wi (ps x3) (ch x3)) t) (wi (wsb (λ x3, ps x3) t) (wsb (λ x3, ch x3) t))
  (@sbimi (λ x3, ph x3) (λ x3, wi (ps x3) (ch x3)) t
    (λ x3, sb2imi_1 x3))
  (@sbi1 (λ x3, ps x3) (λ x3, ch x3) t)


/-- Infer substitution into both sides of a logical equivalence. (Contributed by NM, 14-May-1993.)
-/
theorem sbbii {ph ps : setvar → wff} {t : setvar}
  (sbbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t) :=
@impbii (wsb (λ x3, ph x3) t) (wsb (λ x3, ps x3) t)
  (@sbimi (λ x3, ph x3) (λ x3, ps x3) t
    (λ x3, @biimpi (ph x3) (ps x3)
      (sbbii_1 x3)))
  (@sbimi (λ x3, ps x3) (λ x3, ph x3) t
    (λ x3, @biimpri (ph x3) (ps x3)
      (sbbii_1 x3)))


/-- Deduction substituting both sides of an implication, with ` ph ` and ` x ` disjoint. See also ~
sbimd . (Contributed by Wolf Lammen, 6-May-2023.) Revise ~ df-sb . (Revised by Steven Nguyen,
6-Jul-2023.) -/
theorem sbimdv {ph : wff} {ps ch : setvar → wff} {t : setvar}
  (sbimdv_1 : ∀ x3, ⊦ wi ph (wi (ps x3) (ch x3))) :
  ⊦ wi ph (wi (wsb (λ x3, ps x3) t) (wsb (λ x3, ch x3) t)) :=
@syl ph (wal (λ x3, wi (ps x3) (ch x3))) (wi (wsb (λ x3, ps x3) t) (wsb (λ x3, ch x3) t))
  (@alrimiv ph (λ x3, wi (ps x3) (ch x3))
    (λ x3, sbimdv_1 x3))
  (@spsbim (λ x3, ps x3) (λ x3, ch x3) t)


/-- Deduction substituting both sides of a biconditional, with ` ph ` and ` x ` disjoint. See also ~
sbbid . (Contributed by Wolf Lammen, 6-May-2023.) (Proof shortened by Steven Nguyen, 6-Jul-2023.) -/
theorem sbbidv {ph : wff} {ps ch : setvar → wff} {t : setvar}
  (sbbidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wsb (λ x3, ps x3) t) (wsb (λ x3, ch x3) t)) :=
@syl ph (wal (λ x3, wb (ps x3) (ch x3))) (wb (wsb (λ x3, ps x3) t) (wsb (λ x3, ch x3) t))
  (@alrimiv ph (λ x3, wb (ps x3) (ch x3))
    (λ x3, sbbidv_1 x3))
  (@spsbbi (λ x3, ps x3) (λ x3, ch x3) t)


/-- Conjunction inside and outside of a substitution are equivalent. Compare ~ 19.26 . (Contributed
by NM, 14-May-1993.) (Proof shortened by Steven Nguyen, 13-Aug-2023.) -/
theorem sban {ph ps : setvar → wff} {y : setvar} :
  ⊦ wb (wsb (λ x3, wa (ph x3) (ps x3)) y) (wa (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y)) :=
@impbii (wsb (λ x3, wa (ph x3) (ps x3)) y) (wa (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y))
  (@jca (wsb (λ x3, wa (ph x3) (ps x3)) y) (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y)
    (@sbimi (λ x3, wa (ph x3) (ps x3)) (λ x3, ph x3) y
      (λ x3, @simpl (ph x3) (ps x3)))
    (@sbimi (λ x3, wa (ph x3) (ps x3)) (λ x3, ps x3) y
      (λ x3, @simpr (ph x3) (ps x3))))
  (@imp (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y) (wsb (λ x3, wa (ph x3) (ps x3)) y)
    (@sb2imi (λ x3, ph x3) (λ x3, ps x3) (λ x3, wa (ph x3) (ps x3)) y
      (λ x3, @pm3_2 (ph x3) (ps x3))))


/-- Existential generalization: if a proposition is true for a specific instance, then there exists
an instance where it is true. (Contributed by NM, 29-Jun-1993.) (Proof shortened by Wolf Lammen,
3-May-2018.) Revise ~ df-sb . (Revised by BJ, 22-Dec-2020.) (Proof shortened by Steven Nguyen,
11-Jul-2023.) -/
theorem spsbe {ph : setvar → wff} {t : setvar} :
  ⊦ wi (wsb (λ x3, ph x3) t) (wex (λ x3, ph x3)) :=
@sylbi (wsb (λ x3, ph x3) t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))) (wex (λ x3, ph x3))
  (@df_sb (λ x3, ph x3) t)
  (@syl (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))) (wex (λ y, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))) (wex (λ x3, ph x3))
    (@alequexv (λ y, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) t)
    (@exsbim (λ x3, ph x3)))


/-- Equality property for substitution, from Tarski's system. Used in proof of Theorem 9.7 in
[Megill] p. 449 (p. 16 of the preprint). (Contributed by NM, 14-May-1993.) Revise ~ df-sb . (Revised
by BJ, 30-Dec-2020.) -/
theorem sbequ {ph : setvar → setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wsb (λ z, ph x3 y z) x3) (wsb (λ z, ph x3 y z) y)) :=
@«3bitr4g» (wceq (cv x3) (cv y)) (wal (λ u, wi (wceq (cv u) (cv x3)) (wal (λ z, wi (wceq (cv z) (cv u)) (ph x3 y z))))) (wal (λ u, wi (wceq (cv u) (cv y)) (wal (λ z, wi (wceq (cv z) (cv u)) (ph x3 y z))))) (wsb (λ z, ph x3 y z) x3) (wsb (λ z, ph x3 y z) y)
  (@albidv (wceq (cv x3) (cv y)) (λ u, wi (wceq (cv u) (cv x3)) (wal (λ z, wi (wceq (cv z) (cv u)) (ph x3 y z)))) (λ u, wi (wceq (cv u) (cv y)) (wal (λ z, wi (wceq (cv z) (cv u)) (ph x3 y z))))
    (λ u, @imbi1d (wceq (cv x3) (cv y)) (wceq (cv u) (cv x3)) (wceq (cv u) (cv y)) (wal (λ z, wi (wceq (cv z) (cv u)) (ph x3 y z)))
      (@equequ2 x3 y u)))
  (@df_sb (λ z, ph x3 y z) x3)
  (@df_sb (λ z, ph x3 y z) y)


/-- Equality property for substitution, from Tarski's system. Used in proof of Theorem 9.7 in
[Megill] p. 449 (p. 16 of the preprint). (Contributed by NM, 14-May-1993.) Revise ~ df-sb . (Revised
by BJ, 30-Dec-2020.) -/
theorem sbequ_b {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wsb (λ x3, ph x3 y) x3) (wsb (λ x3, ph x3 y) y)) :=
@«3bitr4g» (wceq (cv x3) (cv y)) (wal (λ u, wi (wceq (cv u) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv u)) (ph x3 y))))) (wal (λ u, wi (wceq (cv u) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv u)) (ph x3 y))))) (wsb (λ x3, ph x3 y) x3) (wsb (λ x3, ph x3 y) y)
  (@albidv (wceq (cv x3) (cv y)) (λ u, wi (wceq (cv u) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv u)) (ph x3 y)))) (λ u, wi (wceq (cv u) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv u)) (ph x3 y))))
    (λ u, @imbi1d (wceq (cv x3) (cv y)) (wceq (cv u) (cv x3)) (wceq (cv u) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv u)) (ph x3 y)))
      (@equequ2 x3 y u)))
  (@df_sb_b (λ x3, ph x3 y) x3)
  (@df_sb (λ x3, ph x3 y) y)


/-- Equality property for substitution, from Tarski's system. Used in proof of Theorem 9.7 in
[Megill] p. 449 (p. 16 of the preprint). (Contributed by NM, 14-May-1993.) Revise ~ df-sb . (Revised
by BJ, 30-Dec-2020.) -/
theorem sbequ_b1 {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wsb (λ y, ph x3 y) x3) (wsb (λ y, ph x3 y) y)) :=
@«3bitr4g» (wceq (cv x3) (cv y)) (wal (λ u, wi (wceq (cv u) (cv x3)) (wal (λ y, wi (wceq (cv y) (cv u)) (ph x3 y))))) (wal (λ u, wi (wceq (cv u) (cv y)) (wal (λ y, wi (wceq (cv y) (cv u)) (ph x3 y))))) (wsb (λ y, ph x3 y) x3) (wsb (λ y, ph x3 y) y)
  (@albidv (wceq (cv x3) (cv y)) (λ u, wi (wceq (cv u) (cv x3)) (wal (λ y, wi (wceq (cv y) (cv u)) (ph x3 y)))) (λ u, wi (wceq (cv u) (cv y)) (wal (λ y, wi (wceq (cv y) (cv u)) (ph x3 y))))
    (λ u, @imbi1d (wceq (cv x3) (cv y)) (wceq (cv u) (cv x3)) (wceq (cv u) (cv y)) (wal (λ y, wi (wceq (cv y) (cv u)) (ph x3 y)))
      (@equequ2 x3 y u)))
  (@df_sb (λ y, ph x3 y) x3)
  (@df_sb_b (λ y, ph x3 y) y)


/-- Alternate definition of substitution when variables are disjoint. Compare Theorem 6.2 of [Quine]
p. 40. Also proved as Lemmas 16 and 17 of [Tarski] p. 70. The implication "to the left" also holds
without a disjoint variable condition ( ~ sb2 ). Theorem ~ sb6f replaces the disjoint variable
condition with a nonfreeness hypothesis. Theorem ~ sb4b replaces it with a distinctor antecedent.
(Contributed by NM, 18-Aug-1993.) (Proof shortened by Wolf Lammen, 21-Sep-2018.) Revise ~ df-sb .
(Revised by BJ, 22-Dec-2020.) Remove use of ~ ax-11 . (Revised by Steven Nguyen, 7-Jul-2023.) (Proof
shortened by Wolf Lammen, 16-Jul-2023.) -/
theorem sb6 {ph : setvar → setvar → wff}
  (t : setvar) : ⊦ wb (wsb (λ x3, ph x3 t) t) (wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t))) :=
@bitri (wsb (λ x3, ph x3 t) t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))) (wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t)))
  (@df_sb (λ x3, ph x3 t) t)
  (@equsalvw (λ y t, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))) (λ t, wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t)))
    (λ y t, @albidv (wceq (cv y) (cv t)) (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t)) (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t))
      (λ x3, @imbi1d (wceq (cv y) (cv t)) (wceq (cv x3) (cv y)) (wceq (cv x3) (cv t)) (ph x3 t)
        (@equequ2 y t x3))) t)


/-- Equivalence for double substitution. (Contributed by NM, 3-Feb-2005.) -/
theorem «2sb6» {ph : setvar → setvar → setvar → setvar → wff}
  (z w : setvar) : ⊦ wb (wsb (λ x3, wsb (λ y, ph x3 y z w) w) z) (wal (λ x3, wal (λ y, wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w)))) :=
@bitri (wsb (λ x3, wsb (λ y, ph x3 y z w) w) z) (wal (λ x3, wi (wceq (cv x3) (cv z)) (wsb (λ y, ph x3 y z w) w))) (wal (λ x3, wal (λ y, wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w))))
  (@sb6 (λ x3 z, wsb (λ y, ph x3 y z w) w) z)
  (@albii (λ x3, wi (wceq (cv x3) (cv z)) (wsb (λ y, ph x3 y z w) w)) (λ x3, wal (λ y, wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w)))
    (λ x3, @«3bitr4ri» (wal (λ y, wi (wceq (cv x3) (cv z)) (wi (wceq (cv y) (cv w)) (ph x3 y z w)))) (wi (wceq (cv x3) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y z w)))) (wal (λ y, wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w))) (wi (wceq (cv x3) (cv z)) (wsb (λ y, ph x3 y z w) w))
      (@«19_21v» (wceq (cv x3) (cv z)) (λ y, wi (wceq (cv y) (cv w)) (ph x3 y z w)))
      (@albii (λ y, wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w)) (λ y, wi (wceq (cv x3) (cv z)) (wi (wceq (cv y) (cv w)) (ph x3 y z w)))
        (λ y, @impexp (wceq (cv x3) (cv z)) (wceq (cv y) (cv w)) (ph x3 y z w)))
      (@imbi2i (wsb (λ y, ph x3 y z w) w) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y z w))) (wceq (cv x3) (cv z))
        (@sb6 (λ y w, ph x3 y z w) w))))


/-- Substitution for a variable not occurring in a proposition. See ~ sbf for a version without
disjoint variable condition on ` x , ph ` . If one adds a disjoint variable condition on ` x , t ` ,
then ~ sbv can be proved directly by chaining ~ equsv with ~ sb6 . (Contributed by BJ, 22-Dec-2020.)
-/
theorem sbv {ph : wff} {t : setvar} :
  ⊦ wb (wsb (λ x3, ph) t) ph :=
@impbii (wsb (λ x3, ph) t) ph
  (@syl (wsb (λ x3, ph) t) (wex (λ x3, ph)) ph
    (@spsbe (λ x3, ph) t)
    (@ax5e ph))
  (@syl ph (wal (λ x3, ph)) (wsb (λ x3, ph) t)
    (@ax_5 ph)
    (@stdpc4 (λ x3, ph) t))


/-- Common proof template for ~ sbrimvw and ~ sbrimv . The hypothesis is an instance of ~ 19.21 .
(Contributed by Wolf Lammen, 29-Jan-2024.) -/
theorem sbrimvlem {ph ps : setvar → setvar → wff}
  (sbrimvlem_1 : ∀ x3 y, ⊦ wb (wal (λ x3, wi (ph x3 y) (wi (wceq (cv x3) (cv y)) (ps x3 y)))) (wi (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ps x3 y)))))
  (x3 y : setvar) : ⊦ wb (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wi (ph x3 y) (wsb (λ x3, ps x3 y) y)) :=
@bitr4i (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wi (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ps x3 y)))) (wi (ph x3 y) (wsb (λ x3, ps x3 y) y))
  (@«3bitr2i» (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))) (wal (λ x3, wi (ph x3 y) (wi (wceq (cv x3) (cv y)) (ps x3 y)))) (wi (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ps x3 y))))
    (@sb6 (λ x3 y, wi (ph x3 y) (ps x3 y)) y)
    (@albii (λ x3, wi (ph x3 y) (wi (wceq (cv x3) (cv y)) (ps x3 y))) (λ x3, wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
      (λ x3, @bi2_04 (ph x3 y) (wceq (cv x3) (cv y)) (ps x3 y)))
    (sbrimvlem_1 x3 y))
  (@imbi2i (wsb (λ x3, ps x3 y) y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ps x3 y))) (ph x3 y)
    (@sb6 (λ x3 y, ps x3 y) y))


/-- Conversion of implicit substitution to explicit substitution. Version of ~ sbie and ~ sbiev with
more disjoint variable conditions, requiring fewer axioms. (Contributed by NM, 30-Jun-1994.)
(Revised by BJ, 18-Jul-2023.) -/
theorem sbievw {ph : setvar → setvar → wff} {ps : setvar → wff}
  (sbievw_is : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps y)))
  (y : setvar) : ⊦ wb (wsb (λ x3, ph x3 y) y) (ps y) :=
@bitri (wsb (λ x3, ph x3 y) y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (ps y)
  (@sb6 (λ x3 y, ph x3 y) y)
  (@equsalvw (λ x3 y, ph x3 y) (λ y, ps y)
    (λ x3 y, sbievw_is x3 y) y)


/-- Substituting ` y ` for ` x ` and then ` z ` for ` y ` is equivalent to substituting ` z ` for
both ` x ` and ` y ` . Version of ~ sbcom3 with a disjoint variable condition using fewer axioms.
(Contributed by NM, 27-May-1997.) (Revised by Giovanni Mascellani, 8-Apr-2018.) (Revised by BJ,
30-Dec-2020.) (Proof shortened by Wolf Lammen, 19-Jan-2023.) -/
theorem sbcom3vv {ph : setvar → setvar → setvar → wff}
  (z : setvar) : ⊦ wb (wsb (λ y, wsb (λ x3, ph x3 y z) y) z) (wsb (λ y, wsb (λ x3, ph x3 y z) z) z) :=
@«3bitr4i» (wal (λ y, wi (wceq (cv y) (cv z)) (wsb (λ x3, ph x3 y z) y))) (wal (λ y, wi (wceq (cv y) (cv z)) (wsb (λ x3, ph x3 y z) z))) (wsb (λ y, wsb (λ x3, ph x3 y z) y) z) (wsb (λ y, wsb (λ x3, ph x3 y z) z) z)
  (@albii (λ y, wi (wceq (cv y) (cv z)) (wsb (λ x3, ph x3 y z) y)) (λ y, wi (wceq (cv y) (cv z)) (wsb (λ x3, ph x3 y z) z))
    (λ y, @pm5_74i (wceq (cv y) (cv z)) (wsb (λ x3, ph x3 y z) y) (wsb (λ x3, ph x3 y z) z)
      (@sbequ (λ y z x3, ph x3 y z) y z)))
  (@sb6 (λ y z, wsb (λ x3, ph x3 y z) y) z)
  (@sb6 (λ y z, wsb (λ x3, ph x3 y z) z) z)


/-- Substituting ` y ` for ` x ` and then ` z ` for ` y ` is equivalent to substituting ` z ` for
both ` x ` and ` y ` . Version of ~ sbcom3 with a disjoint variable condition using fewer axioms.
(Contributed by NM, 27-May-1997.) (Revised by Giovanni Mascellani, 8-Apr-2018.) (Revised by BJ,
30-Dec-2020.) (Proof shortened by Wolf Lammen, 19-Jan-2023.) -/
theorem sbcom3vv_b {ph : setvar → setvar → wff}
  (x3 : setvar) : ⊦ wb (wsb (λ y, wsb (λ x3, ph x3 y) y) x3) (wsb (λ y, wsb (λ x3, ph x3 y) x3) x3) :=
@«3bitr4i» (wal (λ y, wi (wceq (cv y) (cv x3)) (wsb (λ x3, ph x3 y) y))) (wal (λ y, wi (wceq (cv y) (cv x3)) (wsb (λ x3, ph x3 y) x3))) (wsb (λ y, wsb (λ x3, ph x3 y) y) x3) (wsb (λ y, wsb (λ x3, ph x3 y) x3) x3)
  (@albii (λ y, wi (wceq (cv y) (cv x3)) (wsb (λ x3, ph x3 y) y)) (λ y, wi (wceq (cv y) (cv x3)) (wsb (λ x3, ph x3 y) x3))
    (λ y, @pm5_74i (wceq (cv y) (cv x3)) (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ph x3 y) x3)
      (@sbequ_b1 (λ y x3, ph x3 y) y x3)))
  (@sb6 (λ y x3, wsb (λ x3, ph x3 y) y) x3)
  (@sb6 (λ y x3, wsb (λ x3, ph x3 y) x3) x3)


/-- ~ sbievw applied twice, avoiding a DV condition on ` x ` , ` y ` . Based on proofs by Wolf
Lammen. (Contributed by Steven Nguyen, 29-Jul-2023.) -/
theorem sbievw2 {ph ps ch : setvar → setvar → wff}
  (sbievw2_1 : ∀ x3 y w, ⊦ wi (wceq (cv x3) (cv w)) (wb (ph x3 y) (ch y w)))
  (sbievw2_2 : ∀ x3 y w, ⊦ wi (wceq (cv w) (cv y)) (wb (ch y w) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wsb (λ x3, ph x3 y) y) (ps x3 y) :=
@bitr3i (wsb (λ x3, ph x3 y) y) (wsb (λ w, ch y w) y) (ps x3 y)
  (@«3bitr3i» (wsb (λ w, wsb (λ x3, ph x3 y) w) y) (wsb (λ w, wsb (λ x3, ph x3 y) y) y) (wsb (λ w, ch y w) y) (wsb (λ x3, ph x3 y) y)
    (@sbcom3vv (λ x3 w y, ph x3 y) y)
    (@sbbii (λ w, wsb (λ x3, ph x3 y) w) (λ w, ch y w) y
      (λ w, @sbievw (λ x3 w, ph x3 y) (λ w, ch y w)
        (λ x3 w, sbievw2_1 x3 y w) w))
    (@sbv (wsb (λ x3, ph x3 y) y) y))
  (@sbievw (λ w y, ch y w) (λ y, ps x3 y)
    (λ w y, sbievw2_2 x3 y w) y)


/-- A composition law for substitution. Version of ~ sbco2 with disjoint variable conditions and
fewer axioms. (Contributed by NM, 30-Jun-1994.) (Revised by BJ, 22-Dec-2020.) (Proof shortened by
Wolf Lammen, 29-Apr-2023.) -/
theorem sbco2vv {ph : setvar → setvar → wff}
  (y : setvar) : ⊦ wb (wsb (λ z, wsb (λ x3, ph x3 y) z) y) (wsb (λ x3, ph x3 y) y) :=
setvar.forget $ λ z : setvar,
  show ⊦ wb (wsb (λ z, wsb (λ x3, ph x3 y) z) y) (wsb (λ x3, ph x3 y) y), from
  @sbievw2 (λ z y, wsb (λ x3, ph x3 y) z) (λ z y, wsb (λ x3, ph x3 y) y) (λ y w, wsb (λ x3, ph x3 y) w)
    (λ z y w, @sbequ (λ z w x3, ph x3 y) z w)
    (λ z y w, @sbequ (λ w y x3, ph x3 y) w y) z y


/-- Substitution in an equality. (Contributed by Raph Levien and FL, 4-Dec-2005.) Reduce axiom
usage. (Revised by Wolf Lammen, 23-Jul-2023.) -/
theorem equsb3 {z : setvar}
  (y : setvar) : ⊦ wb (wsb (λ x3, wceq (cv x3) (cv z)) y) (wceq (cv y) (cv z)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wsb (λ x3, wceq (cv x3) (cv z)) y) (wceq (cv y) (cv z)), from
  @sbievw2 (λ x3 y, wceq (cv x3) (cv z)) (λ x3 y, wceq (cv y) (cv z)) (λ y w, wceq (cv w) (cv z))
    (λ x3 y w, @equequ1 z x3 w)
    (λ x3 y w, @equequ1 z w y) x3 y


/-- Substitution in an equality. (Contributed by Raph Levien and FL, 4-Dec-2005.) Reduce axiom
usage. (Revised by Wolf Lammen, 23-Jul-2023.) -/
theorem equsb3_b
  (y : setvar) : ⊦ wb (wsb (λ x3, wceq (cv x3) (cv y)) y) (wceq (cv y) (cv y)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wsb (λ x3, wceq (cv x3) (cv y)) y) (wceq (cv y) (cv y)), from
  @sbievw2 (λ x3 y, wceq (cv x3) (cv y)) (λ x3 y, wceq (cv y) (cv y)) (λ y w, wceq (cv w) (cv y))
    (λ x3 y w, @equequ1 y x3 w)
    (λ x3 y w, @equequ1_b1 w y) x3 y


/-- Any substitution in an always false formula is false. (Contributed by Steven Nguyen,
3-May-2023.) -/
theorem nsb {ph : setvar → wff} {t : setvar} :
  ⊦ wi (wal (λ x3, wn (ph x3))) (wn (wsb (λ x3, ph x3) t)) :=
@nsyl (wal (λ x3, wn (ph x3))) (wex (λ x3, ph x3)) (wsb (λ x3, ph x3) t)
  (@biimpi (wal (λ x3, wn (ph x3))) (wn (wex (λ x3, ph x3)))
    (@alnex (λ x3, ph x3)))
  (@spsbe (λ x3, ph x3) t)


-- /-- Extend wff definition to include the membership connective between classes. For a general
-- discussion of the theory of classes, see ~ mmset.html#class . The purpose of introducing ` wff A
-- e. B ` here is to allow us to prove the ~ wel of predicate calculus in terms of the ~ wcel of set
-- theory, so that we do not overload the ` e. ` connective with two syntax definitions. This is
-- done to prevent ambiguity that would complicate some Metamath parsers. The class variables ` A `
-- and ` B ` are introduced temporarily for the purpose of this definition but otherwise not used in
-- predicate calculus. See ~ df-clab for more information on the set theory usage of ~ wcel . -/
-- constant wcel : «class» → «class» → wff


-- /-- Axiom of Left Equality for Binary Predicate. One of the equality and substitution axioms for
-- a non-logical predicate in our predicate calculus with equality. It substitutes equal variables
-- into the left-hand side of an arbitrary binary predicate ` e. ` , which we will use for the set
-- membership relation when set theory is introduced. This axiom scheme is a sub-scheme of Axiom
-- Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our
-- notation. Also appears as Axiom scheme C12' in [Megill] p. 448 (p. 16 of the preprint).
-- "Non-logical" means that the predicate is not a primitive of predicate calculus proper but
-- instead is an extension to it. "Binary" means that the predicate has two arguments. In a system
-- of predicate calculus with equality, like ours, equality is not usually considered to be a
-- non-logical predicate. In systems of predicate calculus without equality, it typically would be.
-- We prove in ~ ax8 that this axiom can be recovered from its weakened version ~ ax8v where ` x `
-- and ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~
-- ax-8 should be ~ ax8v . See the comment of ~ ax8v for more details on these matters. (Contributed
-- by NM, 30-Jun-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax8 instead. (New usage is discouraged.)
-- -/
-- axiom ax_8 {x3 y z : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv z)) (wcel (cv y) (cv z)))


-- /-- Axiom of Left Equality for Binary Predicate. One of the equality and substitution axioms for
-- a non-logical predicate in our predicate calculus with equality. It substitutes equal variables
-- into the left-hand side of an arbitrary binary predicate ` e. ` , which we will use for the set
-- membership relation when set theory is introduced. This axiom scheme is a sub-scheme of Axiom
-- Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our
-- notation. Also appears as Axiom scheme C12' in [Megill] p. 448 (p. 16 of the preprint).
-- "Non-logical" means that the predicate is not a primitive of predicate calculus proper but
-- instead is an extension to it. "Binary" means that the predicate has two arguments. In a system
-- of predicate calculus with equality, like ours, equality is not usually considered to be a
-- non-logical predicate. In systems of predicate calculus without equality, it typically would be.
-- We prove in ~ ax8 that this axiom can be recovered from its weakened version ~ ax8v where ` x `
-- and ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~
-- ax-8 should be ~ ax8v . See the comment of ~ ax8v for more details on these matters. (Contributed
-- by NM, 30-Jun-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax8 instead. (New usage is discouraged.)
-- -/
-- axiom ax_8_b {x3 y : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3)))


-- /-- Axiom of Left Equality for Binary Predicate. One of the equality and substitution axioms for
-- a non-logical predicate in our predicate calculus with equality. It substitutes equal variables
-- into the left-hand side of an arbitrary binary predicate ` e. ` , which we will use for the set
-- membership relation when set theory is introduced. This axiom scheme is a sub-scheme of Axiom
-- Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our
-- notation. Also appears as Axiom scheme C12' in [Megill] p. 448 (p. 16 of the preprint).
-- "Non-logical" means that the predicate is not a primitive of predicate calculus proper but
-- instead is an extension to it. "Binary" means that the predicate has two arguments. In a system
-- of predicate calculus with equality, like ours, equality is not usually considered to be a
-- non-logical predicate. In systems of predicate calculus without equality, it typically would be.
-- We prove in ~ ax8 that this axiom can be recovered from its weakened version ~ ax8v where ` x `
-- and ` y ` are assumed to be disjoint variables. In particular, the only theorem referencing ~
-- ax-8 should be ~ ax8v . See the comment of ~ ax8v for more details on these matters. (Contributed
-- by NM, 30-Jun-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax8 instead. (New usage is discouraged.)
-- -/
-- axiom ax_8_b1 {x3 y : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv y)) (wcel (cv y) (cv y)))


/-- Weakened version of ~ ax-8 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-8 , and it should be referenced only by its two weakened versions ~
ax8v1 and ~ ax8v2 , from which ~ ax-8 is then rederived as ~ ax8 , which shows that either ~ ax8v or
the conjunction of ~ ax8v1 and ~ ax8v2 is sufficient. (Contributed by BJ, 7-Dec-2020.) Use ~ ax8
instead. (New usage is discouraged.) -/
theorem ax8v {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv z)) (wcel (cv y) (cv z))) :=
@ax_8 x3 y z


/-- Weakened version of ~ ax-8 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-8 , and it should be referenced only by its two weakened versions ~
ax8v1 and ~ ax8v2 , from which ~ ax-8 is then rederived as ~ ax8 , which shows that either ~ ax8v or
the conjunction of ~ ax8v1 and ~ ax8v2 is sufficient. (Contributed by BJ, 7-Dec-2020.) Use ~ ax8
instead. (New usage is discouraged.) -/
theorem ax8v_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3))) :=
@ax_8_b x3 y


/-- Weakened version of ~ ax-8 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-8 , and it should be referenced only by its two weakened versions ~
ax8v1 and ~ ax8v2 , from which ~ ax-8 is then rederived as ~ ax8 , which shows that either ~ ax8v or
the conjunction of ~ ax8v1 and ~ ax8v2 is sufficient. (Contributed by BJ, 7-Dec-2020.) Use ~ ax8
instead. (New usage is discouraged.) -/
theorem ax8v_b1 {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv y)) (wcel (cv y) (cv y))) :=
@ax_8_b1 x3 y


/-- First of two weakened versions of ~ ax8v , with an extra disjoint variable condition on ` x , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax8v1 {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv z)) (wcel (cv y) (cv z))) :=
@ax8v x3 y z


/-- First of two weakened versions of ~ ax8v , with an extra disjoint variable condition on ` x , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax8v1_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv y)) (wcel (cv y) (cv y))) :=
@ax8v_b1 x3 y


/-- Second of two weakened versions of ~ ax8v , with an extra disjoint variable condition on ` y , z
` see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax8v2 {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv z)) (wcel (cv y) (cv z))) :=
@ax8v x3 y z


/-- Second of two weakened versions of ~ ax8v , with an extra disjoint variable condition on ` y , z
` see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax8v2_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3))) :=
@ax8v_b x3 y


/-- Proof of ~ ax-8 from ~ ax8v1 and ~ ax8v2 , proving sufficiency of the conjunction of the latter
two weakened versions of ~ ax8v , which is itself a weakened version of ~ ax-8 . (Contributed by BJ,
7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.) -/
theorem ax8 {y z : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv z)) (wcel (cv y) (cv z))) :=
@sylbi (wceq (cv x3) (cv y)) (wex (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y)))) (wi (wcel (cv x3) (cv z)) (wcel (cv y) (cv z)))
  (@equvinv y x3)
  (@exlimiv (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y))) (wi (wcel (cv x3) (cv z)) (wcel (cv y) (cv z)))
    (λ t, @sylan9 (wceq (cv t) (cv x3)) (wcel (cv x3) (cv z)) (wcel (cv t) (cv z)) (wceq (cv t) (cv y)) (wcel (cv y) (cv z))
      (@equcoms (λ x3 t, wi (wcel (cv x3) (cv z)) (wcel (cv t) (cv z)))
        (λ x3 t, @ax8v2 x3 t z) x3 t)
      (@ax8v1 t y z)))


/-- Proof of ~ ax-8 from ~ ax8v1 and ~ ax8v2 , proving sufficiency of the conjunction of the latter
two weakened versions of ~ ax8v , which is itself a weakened version of ~ ax-8 . (Contributed by BJ,
7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.) -/
theorem ax8_b {y : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3))) :=
@sylbi (wceq (cv x3) (cv y)) (wex (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y)))) (wi (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3)))
  (@equvinv y x3)
  (@exlimiv (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y))) (wi (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3)))
    (λ t, @sylan9 (wceq (cv t) (cv x3)) (wcel (cv x3) (cv x3)) (wcel (cv t) (cv x3)) (wceq (cv t) (cv y)) (wcel (cv y) (cv x3))
      (@equcoms (λ x3 t, wi (wcel (cv x3) (cv x3)) (wcel (cv t) (cv x3)))
        (λ x3 t, @ax8v2_b x3 t) x3 t)
      (@ax8v1 t y x3)))


/-- Proof of ~ ax-8 from ~ ax8v1 and ~ ax8v2 , proving sufficiency of the conjunction of the latter
two weakened versions of ~ ax8v , which is itself a weakened version of ~ ax-8 . (Contributed by BJ,
7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.) -/
theorem ax8_b1 {y : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv y)) (wcel (cv y) (cv y))) :=
@sylbi (wceq (cv x3) (cv y)) (wex (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y)))) (wi (wcel (cv x3) (cv y)) (wcel (cv y) (cv y)))
  (@equvinv y x3)
  (@exlimiv (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y))) (wi (wcel (cv x3) (cv y)) (wcel (cv y) (cv y)))
    (λ t, @sylan9 (wceq (cv t) (cv x3)) (wcel (cv x3) (cv y)) (wcel (cv t) (cv y)) (wceq (cv t) (cv y)) (wcel (cv y) (cv y))
      (@equcoms (λ x3 t, wi (wcel (cv x3) (cv y)) (wcel (cv t) (cv y)))
        (λ x3 t, @ax8v2 x3 t y) x3 t)
      (@ax8v1_b t y)))


/-- An identity law for the non-logical predicate. (Contributed by NM, 30-Jun-1993.) -/
theorem elequ1 {z : setvar}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv x3) (cv z)) (wcel (cv y) (cv z))) :=
@impbid (wceq (cv x3) (cv y)) (wcel (cv x3) (cv z)) (wcel (cv y) (cv z))
  (@ax8 y z x3)
  (@equcoms (λ y x3, wi (wcel (cv y) (cv z)) (wcel (cv x3) (cv z)))
    (λ y x3, @ax8 x3 z y) y x3)


/-- An identity law for the non-logical predicate. (Contributed by NM, 30-Jun-1993.) -/
theorem elequ1_b
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3))) :=
@impbid (wceq (cv x3) (cv y)) (wcel (cv x3) (cv x3)) (wcel (cv y) (cv x3))
  (@ax8_b y x3)
  (@equcoms (λ y x3, wi (wcel (cv y) (cv x3)) (wcel (cv x3) (cv x3)))
    (λ y x3, @ax8_b1 x3 y) y x3)


/-- An identity law for the non-logical predicate. (Contributed by NM, 30-Jun-1993.) -/
theorem elequ1_b1
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv x3) (cv y)) (wcel (cv y) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wcel (cv x3) (cv y)) (wcel (cv y) (cv y))
  (@ax8_b1 y x3)
  (@equcoms (λ y x3, wi (wcel (cv y) (cv y)) (wcel (cv x3) (cv y)))
    (λ y x3, @ax8_b x3 y) y x3)


/-- When the class variables in Definition ~ df-clel are replaced with setvar variables, this
theorem of predicate calculus is the result. This theorem provides part of the justification for the
consistency of that definition, which "overloads" the setvar variables in ~ wel with the class
variables in ~ wcel . (Contributed by NM, 28-Jan-2004.) Revised to use ~ equsexvw in order to remove
dependencies on ~ ax-10 , ~ ax-12 , ~ ax-13 . Note that there is no disjoint variable condition on `
x , y ` , that is, on the variables of the left-hand side, as should be the case for definitions.
(Revised by BJ, 29-Dec-2020.) -/
theorem cleljust {y : setvar}
  (x3 : setvar) : ⊦ wb (wcel (cv x3) (cv y)) (wex (λ z, wa (wceq (cv z) (cv x3)) (wcel (cv z) (cv y)))) :=
@bicomi (wex (λ z, wa (wceq (cv z) (cv x3)) (wcel (cv z) (cv y)))) (wcel (cv x3) (cv y))
  (@equsexvw (λ z x3, wcel (cv z) (cv y)) (λ x3, wcel (cv x3) (cv y))
    (λ z x3, @elequ1 y z x3) x3)


/-- When the class variables in Definition ~ df-clel are replaced with setvar variables, this
theorem of predicate calculus is the result. This theorem provides part of the justification for the
consistency of that definition, which "overloads" the setvar variables in ~ wel with the class
variables in ~ wcel . (Contributed by NM, 28-Jan-2004.) Revised to use ~ equsexvw in order to remove
dependencies on ~ ax-10 , ~ ax-12 , ~ ax-13 . Note that there is no disjoint variable condition on `
x , y ` , that is, on the variables of the left-hand side, as should be the case for definitions.
(Revised by BJ, 29-Dec-2020.) -/
theorem cleljust_b
  (x3 : setvar) : ⊦ wb (wcel (cv x3) (cv x3)) (wex (λ z, wa (wceq (cv z) (cv x3)) (wcel (cv z) (cv x3)))) :=
@bicomi (wex (λ z, wa (wceq (cv z) (cv x3)) (wcel (cv z) (cv x3)))) (wcel (cv x3) (cv x3))
  (@equsexvw (λ z x3, wcel (cv z) (cv x3)) (λ x3, wcel (cv x3) (cv x3))
    (λ z x3, @elequ1_b1 z x3) x3)


-- /-- Axiom of Right Equality for Binary Predicate. One of the equality and substitution axioms for
-- a non-logical predicate in our predicate calculus with equality. It substitutes equal variables
-- into the right-hand side of an arbitrary binary predicate ` e. ` , which we will use for the set
-- membership relation when set theory is introduced. This axiom scheme is a sub-scheme of Axiom
-- Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our
-- notation. Also appears as Axiom scheme C13' in [Megill] p. 448 (p. 16 of the preprint). We prove
-- in ~ ax9 that this axiom can be recovered from its weakened version ~ ax9v where ` x ` and ` y `
-- are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-9 should
-- be ~ ax9v . See the comment of ~ ax9v for more details on these matters. (Contributed by NM,
-- 21-Jun-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax9 instead. (New usage is discouraged.) -/
-- axiom ax_9 {x3 y z : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))


-- /-- Axiom of Right Equality for Binary Predicate. One of the equality and substitution axioms for
-- a non-logical predicate in our predicate calculus with equality. It substitutes equal variables
-- into the right-hand side of an arbitrary binary predicate ` e. ` , which we will use for the set
-- membership relation when set theory is introduced. This axiom scheme is a sub-scheme of Axiom
-- Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our
-- notation. Also appears as Axiom scheme C13' in [Megill] p. 448 (p. 16 of the preprint). We prove
-- in ~ ax9 that this axiom can be recovered from its weakened version ~ ax9v where ` x ` and ` y `
-- are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-9 should
-- be ~ ax9v . See the comment of ~ ax9v for more details on these matters. (Contributed by NM,
-- 21-Jun-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax9 instead. (New usage is discouraged.) -/
-- axiom ax_9_b {x3 y : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y)))


-- /-- Axiom of Right Equality for Binary Predicate. One of the equality and substitution axioms for
-- a non-logical predicate in our predicate calculus with equality. It substitutes equal variables
-- into the right-hand side of an arbitrary binary predicate ` e. ` , which we will use for the set
-- membership relation when set theory is introduced. This axiom scheme is a sub-scheme of Axiom
-- Scheme B8 of system S2 of [Tarski], p. 75, whose general form cannot be represented with our
-- notation. Also appears as Axiom scheme C13' in [Megill] p. 448 (p. 16 of the preprint). We prove
-- in ~ ax9 that this axiom can be recovered from its weakened version ~ ax9v where ` x ` and ` y `
-- are assumed to be disjoint variables. In particular, the only theorem referencing ~ ax-9 should
-- be ~ ax9v . See the comment of ~ ax9v for more details on these matters. (Contributed by NM,
-- 21-Jun-1993.) (Revised by BJ, 7-Dec-2020.) Use ~ ax9 instead. (New usage is discouraged.) -/
-- axiom ax_9_b1 {x3 y : setvar} : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv y) (cv x3)) (wcel (cv y) (cv y)))


/-- Weakened version of ~ ax-9 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-9 , and it should be referenced only by its two weakened versions ~
ax9v1 and ~ ax9v2 , from which ~ ax-9 is then rederived as ~ ax9 , which shows that either ~ ax9v or
the conjunction of ~ ax9v1 and ~ ax9v2 is sufficient. (Contributed by BJ, 7-Dec-2020.) Use ~ ax9
instead. (New usage is discouraged.) -/
theorem ax9v {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))) :=
@ax_9 x3 y z


/-- Weakened version of ~ ax-9 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-9 , and it should be referenced only by its two weakened versions ~
ax9v1 and ~ ax9v2 , from which ~ ax-9 is then rederived as ~ ax9 , which shows that either ~ ax9v or
the conjunction of ~ ax9v1 and ~ ax9v2 is sufficient. (Contributed by BJ, 7-Dec-2020.) Use ~ ax9
instead. (New usage is discouraged.) -/
theorem ax9v_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y))) :=
@ax_9_b x3 y


/-- Weakened version of ~ ax-9 , with a disjoint variable condition on ` x , y ` . This should be
the only proof referencing ~ ax-9 , and it should be referenced only by its two weakened versions ~
ax9v1 and ~ ax9v2 , from which ~ ax-9 is then rederived as ~ ax9 , which shows that either ~ ax9v or
the conjunction of ~ ax9v1 and ~ ax9v2 is sufficient. (Contributed by BJ, 7-Dec-2020.) Use ~ ax9
instead. (New usage is discouraged.) -/
theorem ax9v_b1 {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv y) (cv x3)) (wcel (cv y) (cv y))) :=
@ax_9_b1 x3 y


/-- First of two weakened versions of ~ ax9v , with an extra disjoint variable condition on ` x , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax9v1 {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))) :=
@ax9v x3 y z


/-- First of two weakened versions of ~ ax9v , with an extra disjoint variable condition on ` x , z
` , see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax9v1_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv y) (cv x3)) (wcel (cv y) (cv y))) :=
@ax9v_b1 x3 y


/-- Second of two weakened versions of ~ ax9v , with an extra disjoint variable condition on ` y , z
` see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax9v2 {x3 y z : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))) :=
@ax9v x3 y z


/-- Second of two weakened versions of ~ ax9v , with an extra disjoint variable condition on ` y , z
` see comments there. (Contributed by BJ, 7-Dec-2020.) -/
theorem ax9v2_b {x3 y : setvar} :
  ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y))) :=
@ax9v_b x3 y


/-- Proof of ~ ax-9 from ~ ax9v1 and ~ ax9v2 , proving sufficiency of the conjunction of the latter
two weakened versions of ~ ax9v , which is itself a weakened version of ~ ax-9 . (Contributed by BJ,
7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.) -/
theorem ax9 {y z : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))) :=
@sylbi (wceq (cv x3) (cv y)) (wex (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y)))) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))
  (@equvinv y x3)
  (@exlimiv (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y))) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))
    (λ t, @sylan9 (wceq (cv t) (cv x3)) (wcel (cv z) (cv x3)) (wcel (cv z) (cv t)) (wceq (cv t) (cv y)) (wcel (cv z) (cv y))
      (@equcoms (λ x3 t, wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv t)))
        (λ x3 t, @ax9v2 x3 t z) x3 t)
      (@ax9v1 t y z)))


/-- Proof of ~ ax-9 from ~ ax9v1 and ~ ax9v2 , proving sufficiency of the conjunction of the latter
two weakened versions of ~ ax9v , which is itself a weakened version of ~ ax-9 . (Contributed by BJ,
7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.) -/
theorem ax9_b {z : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3))) :=
@sylbi (wceq (cv x3) (cv x3)) (wex (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv x3)))) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))
  (@equvinv_b x3)
  (@exlimiv (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv x3))) (wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))
    (λ t, @sylan9 (wceq (cv t) (cv x3)) (wcel (cv z) (cv x3)) (wcel (cv z) (cv t)) (wceq (cv t) (cv x3)) (wcel (cv z) (cv x3))
      (@equcoms (λ x3 t, wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv t)))
        (λ x3 t, @ax9v2 x3 t z) x3 t)
      (@ax9v1 t x3 z)))


/-- Proof of ~ ax-9 from ~ ax9v1 and ~ ax9v2 , proving sufficiency of the conjunction of the latter
two weakened versions of ~ ax9v , which is itself a weakened version of ~ ax-9 . (Contributed by BJ,
7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.) -/
theorem ax9_b1 {y : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y))) :=
@sylbi (wceq (cv x3) (cv y)) (wex (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y)))) (wi (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y)))
  (@equvinv y x3)
  (@exlimiv (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y))) (wi (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y)))
    (λ t, @sylan9 (wceq (cv t) (cv x3)) (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv t)) (wceq (cv t) (cv y)) (wcel (cv x3) (cv y))
      (@equcoms (λ x3 t, wi (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv t)))
        (λ x3 t, @ax9v2_b x3 t) x3 t)
      (@ax9v1 t y x3)))


/-- Proof of ~ ax-9 from ~ ax9v1 and ~ ax9v2 , proving sufficiency of the conjunction of the latter
two weakened versions of ~ ax9v , which is itself a weakened version of ~ ax-9 . (Contributed by BJ,
7-Dec-2020.) (Proof shortened by Wolf Lammen, 11-Apr-2021.) -/
theorem ax9_b2 {y : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (wcel (cv y) (cv x3)) (wcel (cv y) (cv y))) :=
@sylbi (wceq (cv x3) (cv y)) (wex (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y)))) (wi (wcel (cv y) (cv x3)) (wcel (cv y) (cv y)))
  (@equvinv y x3)
  (@exlimiv (λ t, wa (wceq (cv t) (cv x3)) (wceq (cv t) (cv y))) (wi (wcel (cv y) (cv x3)) (wcel (cv y) (cv y)))
    (λ t, @sylan9 (wceq (cv t) (cv x3)) (wcel (cv y) (cv x3)) (wcel (cv y) (cv t)) (wceq (cv t) (cv y)) (wcel (cv y) (cv y))
      (@equcoms (λ x3 t, wi (wcel (cv y) (cv x3)) (wcel (cv y) (cv t)))
        (λ x3 t, @ax9v2 x3 t y) x3 t)
      (@ax9v1_b t y)))


/-- An identity law for the non-logical predicate. (Contributed by NM, 21-Jun-1993.) -/
theorem elequ2 {z : setvar}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))
  (@ax9 y z x3)
  (@equcoms (λ y x3, wi (wcel (cv z) (cv y)) (wcel (cv z) (cv x3)))
    (λ y x3, @ax9 x3 z y) y x3)


/-- An identity law for the non-logical predicate. (Contributed by NM, 21-Jun-1993.) -/
theorem elequ2_b {z : setvar}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3))) :=
@impbid (wceq (cv x3) (cv x3)) (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3))
  (@ax9_b z x3)
  (@equcoms_b (λ x3, wi (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))
    (λ x3, @ax9_b z x3) x3)


/-- An identity law for the non-logical predicate. (Contributed by NM, 21-Jun-1993.) -/
theorem elequ2_b1
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wcel (cv x3) (cv x3)) (wcel (cv x3) (cv y))
  (@ax9_b1 y x3)
  (@equcoms (λ y x3, wi (wcel (cv x3) (cv y)) (wcel (cv x3) (cv x3)))
    (λ y x3, @ax9_b2 x3 y) y x3)


/-- An identity law for the non-logical predicate. (Contributed by NM, 21-Jun-1993.) -/
theorem elequ2_b2
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv y) (cv x3)) (wcel (cv y) (cv y))) :=
@impbid (wceq (cv x3) (cv y)) (wcel (cv y) (cv x3)) (wcel (cv y) (cv y))
  (@ax9_b2 y x3)
  (@equcoms (λ y x3, wi (wcel (cv y) (cv y)) (wcel (cv y) (cv x3)))
    (λ y x3, @ax9_b1 x3 y) y x3)


/-- A form of ~ elequ2 with a universal quantifier. Its converse is the axiom of extensionality ~
ax-ext . (Contributed by BJ, 3-Oct-2019.) -/
theorem elequ2g
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))) :=
@alrimiv (wceq (cv x3) (cv y)) (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))
  (λ z, @elequ2 z x3 y)


/-- A form of ~ elequ2 with a universal quantifier. Its converse is the axiom of extensionality ~
ax-ext . (Contributed by BJ, 3-Oct-2019.) -/
theorem elequ2g_b
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))) :=
@alrimiv (wceq (cv x3) (cv x3)) (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))
  (λ z, @elequ2_b z x3)


-- /-- Axiom of Quantified Negation. Axiom C5-2 of [Monk2] p. 113. This axiom scheme is logically
-- redundant (see ~ ax10w ) but is used as an auxiliary axiom scheme to achieve scheme completeness.
-- It means that ` x ` is not free in ` -. A. x ph ` . (Contributed by NM, 21-May-2008.) Use its
-- alias ~ hbn1 instead if you must use it. Any theorem in first-order logic (FOL) that contains
-- only set variables that are all mutually distinct, and has no wff variables, can be proved
-- *without* using ~ ax-10 through ~ ax-13 , by invoking ~ ax10w through ~ ax13w . We encourage
-- proving theorems *without* ~ ax-10 through ~ ax-13 and moving them up to the ~ ax-4 through ~
-- ax-9 section. (New usage is discouraged.) -/
-- axiom ax_10 {ph : setvar → wff} : ⊦ wi (wn (wal (λ x3, ph x3))) (wal (λ x3, wn (wal (λ x3, ph x3))))


/-- Alias for ~ ax-10 to be used instead of it. (Contributed by NM, 24-Jan-1993.) (Proof shortened
by Wolf Lammen, 18-Aug-2014.) -/
theorem hbn1 {ph : setvar → wff} :
  ⊦ wi (wn (wal (λ x3, ph x3))) (wal (λ x3, wn (wal (λ x3, ph x3)))) :=
@ax_10 (λ x3, ph x3)


/-- The setvar ` x ` is not free in ` E. x ph ` . Corresponds to the axiom (5) of modal logic (see
also ~ modal5 ). (Contributed by NM, 24-Jan-1993.) -/
theorem hbe1 {ph : setvar → wff} :
  ⊦ wi (wex (λ x3, ph x3)) (wal (λ x3, wex (λ x3, ph x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wex (λ x3, ph x3)) (wal (λ x3, wex (λ x3, ph x3))), from
  @hbxfrbi (λ x3, wex (λ x3, ph x3)) (λ x3, wn (wal (λ x3, wn (ph x3))))
    (λ x3, @df_ex (λ x3, ph x3))
    (λ x3, @hbn1 (λ x3, wn (ph x3))) x3


/-- Dual statement of ~ hbe1 . Modified version of ~ axc7e with a universally quantified consequent.
(Contributed by Wolf Lammen, 15-Sep-2021.) -/
theorem hbe1a {ph : setvar → wff} :
  ⊦ wi (wex (λ x3, wal (λ x3, ph x3))) (wal (λ x3, ph x3)) :=
@sylbi (wex (λ x3, wal (λ x3, ph x3))) (wn (wal (λ x3, wn (wal (λ x3, ph x3))))) (wal (λ x3, ph x3))
  (@df_ex (λ x3, wal (λ x3, ph x3)))
  (@con1i (wal (λ x3, ph x3)) (wal (λ x3, wn (wal (λ x3, ph x3))))
    (@hbn1 (λ x3, ph x3)))


/-- One direction of ~ nf5 can be proved with a smaller footprint on axiom usage. (Contributed by
Wolf Lammen, 16-Sep-2021.) -/
theorem nf5_1 {ph : setvar → wff} :
  ⊦ wi (wal (λ x3, wi (ph x3) (wal (λ x3, ph x3)))) (wnf (λ x3, ph x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wal (λ x3, wi (ph x3) (wal (λ x3, ph x3)))) (wnf (λ x3, ph x3)), from
  @nfd (λ x3, wal (λ x3, wi (ph x3) (wal (λ x3, ph x3)))) (λ x3, ph x3)
    (λ x3, @syl6 (wal (λ x3, wi (ph x3) (wal (λ x3, ph x3)))) (wex (λ x3, ph x3)) (wex (λ x3, wal (λ x3, ph x3))) (wal (λ x3, ph x3))
      (@exim (λ x3, ph x3) (λ x3, wal (λ x3, ph x3)))
      (@hbe1a (λ x3, ph x3))) x3


/-- Deduce that ` x ` is not free in ` ph ` from the definition. (Contributed by Mario Carneiro,
11-Aug-2016.) -/
theorem nf5i {ph : setvar → wff}
  (nf5i_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3))) :
  ⊦ wnf (λ x3, ph x3) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wnf (λ x3, ph x3), from
  @mpg (λ x3, wi (ph x3) (wal (λ x3, ph x3))) (λ x3, wnf (λ x3, ph x3))
    (λ x3, @nf5_1 (λ x3, ph x3))
    (λ x3, nf5i_1 x3) x3


/-- All variables are effectively bound in a distinct variable specifier. Version of ~ nfnae with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by Mario Carneiro,
11-Aug-2016.) (Revised by Gino Giotto, 10-Jan-2024.) (Proof shortened by Wolf Lammen, 25-Sep-2024.)
-/
theorem nfnaew
  (y : setvar) : ⊦ wnf (λ z, wn (wal (λ x3, wceq (cv x3) (cv y)))) :=
@nf5i (λ z, wn (wal (λ x3, wceq (cv x3) (cv y))))
  (λ z, @hbnaev y)


/-- All variables are effectively bound in a distinct variable specifier. Version of ~ nfnae with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by Mario Carneiro,
11-Aug-2016.) (Revised by Gino Giotto, 10-Jan-2024.) (Proof shortened by Wolf Lammen, 25-Sep-2024.)
-/
theorem nfnaew_b :
  ⊦ wnf (λ y, wn (wal (λ x3, wceq (cv x3) (cv y)))) :=
@nf5i (λ y, wn (wal (λ x3, wceq (cv x3) (cv y))))
  (λ y, @hbnaev_b y)


/-- The setvar ` x ` is not free in ` E. x ph ` . (Contributed by Mario Carneiro, 11-Aug-2016.) -/
theorem nfe1 {ph : setvar → wff} :
  ⊦ wnf (λ x3, wex (λ x3, ph x3)) :=
@nf5i (λ x3, wex (λ x3, ph x3))
  (λ x3, @hbe1 (λ x3, ph x3))


/-- The setvar ` x ` is not free in ` A. x ph ` . (Contributed by Mario Carneiro, 11-Aug-2016.) ~
df-nf changed. (Revised by Wolf Lammen, 11-Sep-2021.) Remove dependency on ~ ax-12 . (Revised by
Wolf Lammen, 12-Oct-2021.) -/
theorem nfa1 {ph : setvar → wff} :
  ⊦ wnf (λ x3, wal (λ x3, ph x3)) :=
@nfxfr (λ x3, wal (λ x3, ph x3)) (λ x3, wn (wex (λ x3, wn (ph x3))))
  (λ x3, @alex (λ x3, ph x3))
  (@nfn (λ x3, wex (λ x3, wn (ph x3)))
    (@nfe1 (λ x3, wn (ph x3))))


/-- Lemma 23 of [Monk2] p. 114. (Contributed by Mario Carneiro, 24-Sep-2016.) -/
theorem nfia1 {ph ps : setvar → wff} :
  ⊦ wnf (λ x3, wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3))) :=
@nfim (λ x3, wal (λ x3, ph x3)) (λ x3, wal (λ x3, ps x3))
  (@nfa1 (λ x3, ph x3))
  (@nfa1 (λ x3, ps x3))


/-- The setvar ` x ` is not free in ` F/ x ph ` . (Contributed by Mario Carneiro, 11-Aug-2016.)
Remove dependency on ~ ax-12 . (Revised by Wolf Lammen, 12-Oct-2021.) -/
theorem nfnf1 {ph : setvar → wff} :
  ⊦ wnf (λ x3, wnf (λ x3, ph x3)) :=
@nfxfr (λ x3, wnf (λ x3, ph x3)) (λ x3, wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3)))
  (λ x3, @df_nf (λ x3, ph x3))
  (@nfim (λ x3, wex (λ x3, ph x3)) (λ x3, wal (λ x3, ph x3))
    (@nfe1 (λ x3, ph x3))
    (@nfa1 (λ x3, ph x3)))


/-- The setvar ` x ` is not free in ` [ y / x ] ph ` when ` x ` and ` y ` are distinct. (Contributed
by Mario Carneiro, 11-Aug-2016.) Shorten ~ nfs1v and ~ hbs1 combined. (Revised by Wolf Lammen,
28-Jul-2022.) -/
theorem nfs1v {ph : setvar → setvar → wff}
  (y : setvar) : ⊦ wnf (λ x3, wsb (λ x3, ph x3 y) y) :=
@nfxfr (λ x3, wsb (λ x3, ph x3 y) y) (λ x3, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y)))
  (λ x3, @sb6 (λ x3 y, ph x3 y) y)
  (@nfa1 (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y)))


-- /-- Axiom of Quantifier Commutation. This axiom says universal quantifiers can be swapped. Axiom
-- scheme C6' in [Megill] p. 448 (p. 16 of the preprint). Also appears as Lemma 12 of [Monk2] p. 109
-- and Axiom C5-3 of [Monk2] p. 113. This axiom scheme is logically redundant (see ~ ax11w ) but is
-- used as an auxiliary axiom scheme to achieve metalogical completeness. (Contributed by NM,
-- 12-Mar-1993.) -/
-- axiom ax_11 {ph : setvar → setvar → wff} : ⊦ wi (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ y, wal (λ x3, ph x3 y)))


-- /-- Axiom of Quantifier Commutation. This axiom says universal quantifiers can be swapped. Axiom
-- scheme C6' in [Megill] p. 448 (p. 16 of the preprint). Also appears as Lemma 12 of [Monk2] p. 109
-- and Axiom C5-3 of [Monk2] p. 113. This axiom scheme is logically redundant (see ~ ax11w ) but is
-- used as an auxiliary axiom scheme to achieve metalogical completeness. (Contributed by NM,
-- 12-Mar-1993.) -/
-- axiom ax_11_b {ph : setvar → wff} : ⊦ wi (wal (λ x3, wal (λ x3, ph x3))) (wal (λ x3, wal (λ x3, ph x3)))


/-- Swap quantifiers in an antecedent. (Contributed by NM, 11-May-1993.) -/
theorem alcoms {ph ps : setvar → setvar → wff}
  (alcoms_1 : ∀ x3 y, ⊦ wi (wal (λ x3, wal (λ y, ph x3 y))) (ps x3 y))
  (x3 y : setvar) : ⊦ wi (wal (λ y, wal (λ x3, ph x3 y))) (ps x3 y) :=
@syl (wal (λ y, wal (λ x3, ph x3 y))) (wal (λ x3, wal (λ y, ph x3 y))) (ps x3 y)
  (@ax_11 (λ y x3, ph x3 y))
  (alcoms_1 x3 y)


/-- Theorem 19.5 of [Margaris] p. 89. (Contributed by NM, 30-Jun-1993.) -/
theorem alcom {ph : setvar → setvar → wff} :
  ⊦ wb (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ y, wal (λ x3, ph x3 y))) :=
@impbii (wal (λ x3, wal (λ y, ph x3 y))) (wal (λ y, wal (λ x3, ph x3 y)))
  (@ax_11 (λ x3 y, ph x3 y))
  (@ax_11 (λ y x3, ph x3 y))


/-- Theorem *11.21 in [WhiteheadRussell] p. 160. (Contributed by Andrew Salmon, 24-May-2011.) -/
theorem alrot3 {ph : setvar → setvar → setvar → wff} :
  ⊦ wb (wal (λ x3, wal (λ y, wal (λ z, ph x3 y z)))) (wal (λ y, wal (λ z, wal (λ x3, ph x3 y z)))) :=
@bitri (wal (λ x3, wal (λ y, wal (λ z, ph x3 y z)))) (wal (λ y, wal (λ x3, wal (λ z, ph x3 y z)))) (wal (λ y, wal (λ z, wal (λ x3, ph x3 y z))))
  (@alcom (λ x3 y, wal (λ z, ph x3 y z)))
  (@albii (λ y, wal (λ x3, wal (λ z, ph x3 y z))) (λ y, wal (λ z, wal (λ x3, ph x3 y z)))
    (λ y, @alcom (λ x3 z, ph x3 y z)))


/-- Move universal quantifier in and out of substitution. (Contributed by NM, 16-May-1993.) (Proof
shortened by Wolf Lammen, 29-Sep-2018.) Reduce dependencies on axioms. (Revised by Steven Nguyen,
13-Aug-2023.) -/
theorem sbal {ph : setvar → setvar → wff} {z : setvar} :
  ⊦ wb (wsb (λ y, wal (λ x3, ph x3 y)) z) (wal (λ x3, wsb (λ y, ph x3 y) z)) :=
@«3bitr4i» (wal (λ w, wal (λ x3, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))))) (wal (λ x3, wal (λ w, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))))) (wsb (λ y, wal (λ x3, ph x3 y)) z) (wal (λ x3, wsb (λ y, ph x3 y) z))
  (@alcom (λ w x3, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))))
  (@«3bitr4i» (wal (λ w, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (wal (λ x3, ph x3 y)))))) (wal (λ w, wi (wceq (cv w) (cv z)) (wal (λ x3, wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))))) (wsb (λ y, wal (λ x3, ph x3 y)) z) (wal (λ w, wal (λ x3, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y))))))
    (@albii (λ w, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (wal (λ x3, ph x3 y))))) (λ w, wi (wceq (cv w) (cv z)) (wal (λ x3, wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))))
      (λ w, @imbi2i (wal (λ y, wi (wceq (cv y) (cv w)) (wal (λ x3, ph x3 y)))) (wal (λ x3, wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))) (wceq (cv w) (cv z))
        (@bitr3i (wal (λ y, wi (wceq (cv y) (cv w)) (wal (λ x3, ph x3 y)))) (wal (λ y, wal (λ x3, wi (wceq (cv y) (cv w)) (ph x3 y)))) (wal (λ x3, wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y))))
          (@albii (λ y, wal (λ x3, wi (wceq (cv y) (cv w)) (ph x3 y))) (λ y, wi (wceq (cv y) (cv w)) (wal (λ x3, ph x3 y)))
            (λ y, @«19_21v» (wceq (cv y) (cv w)) (λ x3, ph x3 y)))
          (@alcom (λ y x3, wi (wceq (cv y) (cv w)) (ph x3 y))))))
    (@df_sb (λ y, wal (λ x3, ph x3 y)) z)
    (@albii (λ w, wal (λ x3, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y))))) (λ w, wi (wceq (cv w) (cv z)) (wal (λ x3, wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))))
      (λ w, @«19_21v» (wceq (cv w) (cv z)) (λ x3, wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y))))))
  (@albii (λ x3, wsb (λ y, ph x3 y) z) (λ x3, wal (λ w, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)))))
    (λ x3, @df_sb (λ y, ph x3 y) z))


/-- Quantify with new variable inside substitution. (Contributed by NM, 18-Aug-1993.) -/
theorem sbalv {ph ps : setvar → setvar → setvar → wff}
  (sbalv_1 : ∀ x3 y z, ⊦ wb (wsb (λ x3, ph x3 y z) y) (ps x3 y z))
  (x3 y : setvar) : ⊦ wb (wsb (λ x3, wal (λ z, ph x3 y z)) y) (wal (λ z, ps x3 y z)) :=
@bitri (wsb (λ x3, wal (λ z, ph x3 y z)) y) (wal (λ z, wsb (λ x3, ph x3 y z) y)) (wal (λ z, ps x3 y z))
  (@sbal (λ z x3, ph x3 y z) y)
  (@albii (λ z, wsb (λ x3, ph x3 y z) y) (λ z, ps x3 y z)
    (λ z, sbalv_1 x3 y z))


/-- Commutativity law for substitution. Used in proof of Theorem 9.7 of [Megill] p. 449 (p. 16 of
the preprint). (Contributed by NM, 27-May-1997.) (Proof shortened by Wolf Lammen, 23-Dec-2022.) -/
theorem sbcom2 {ph : setvar → setvar → setvar → setvar → wff}
  (y w : setvar) : ⊦ wb (wsb (λ z, wsb (λ x3, ph x3 y z w) y) w) (wsb (λ x3, wsb (λ z, ph x3 y z w) w) y) :=
@exlimiiv (λ v, wceq (cv v) (cv w)) (wb (wsb (λ z, wsb (λ x3, ph x3 y z w) y) w) (wsb (λ x3, wsb (λ z, ph x3 y z w) w) y))
  (λ v, @exlimiiv (λ u, wceq (cv u) (cv y)) (wi (wceq (cv v) (cv w)) (wb (wsb (λ z, wsb (λ x3, ph x3 y z w) y) w) (wsb (λ x3, wsb (λ z, ph x3 y z w) w) y)))
    (λ u, @ex (wceq (cv u) (cv y)) (wceq (cv v) (cv w)) (wb (wsb (λ z, wsb (λ x3, ph x3 y z w) y) w) (wsb (λ x3, wsb (λ z, ph x3 y z w) w) y))
      (@bitr3d (wa (wceq (cv u) (cv y)) (wceq (cv v) (cv w))) (wsb (λ x3, wsb (λ z, ph x3 y z w) v) u) (wsb (λ z, wsb (λ x3, ph x3 y z w) y) w) (wsb (λ x3, wsb (λ z, ph x3 y z w) w) y)
        (@sylan9bb (wceq (cv u) (cv y)) (wsb (λ x3, wsb (λ z, ph x3 y z w) v) u) (wsb (λ z, wsb (λ x3, ph x3 y z w) y) v) (wceq (cv v) (cv w)) (wsb (λ z, wsb (λ x3, ph x3 y z w) y) w)
          (@bitr3id (wsb (λ x3, wsb (λ z, ph x3 y z w) v) u) (wsb (λ z, wsb (λ x3, ph x3 y z w) u) v) (wceq (cv u) (cv y)) (wsb (λ z, wsb (λ x3, ph x3 y z w) y) v)
            (@bitr4i (wsb (λ z, wsb (λ x3, ph x3 y z w) u) v) (wal (λ x3, wal (λ z, wi (wa (wceq (cv x3) (cv u)) (wceq (cv z) (cv v))) (ph x3 y z w)))) (wsb (λ x3, wsb (λ z, ph x3 y z w) v) u)
              (@«3bitri» (wsb (λ z, wsb (λ x3, ph x3 y z w) u) v) (wal (λ z, wal (λ x3, wi (wa (wceq (cv z) (cv v)) (wceq (cv x3) (cv u))) (ph x3 y z w)))) (wal (λ x3, wal (λ z, wi (wa (wceq (cv z) (cv v)) (wceq (cv x3) (cv u))) (ph x3 y z w)))) (wal (λ x3, wal (λ z, wi (wa (wceq (cv x3) (cv u)) (wceq (cv z) (cv v))) (ph x3 y z w))))
                (@«2sb6» (λ z x3 v u, ph x3 y z w) v u)
                (@alcom (λ z x3, wi (wa (wceq (cv z) (cv v)) (wceq (cv x3) (cv u))) (ph x3 y z w)))
                (@«2albii» (λ x3 z, wi (wa (wceq (cv z) (cv v)) (wceq (cv x3) (cv u))) (ph x3 y z w)) (λ x3 z, wi (wa (wceq (cv x3) (cv u)) (wceq (cv z) (cv v))) (ph x3 y z w))
                  (λ x3 z, @ancomst (wceq (cv z) (cv v)) (wceq (cv x3) (cv u)) (ph x3 y z w))))
              (@«2sb6» (λ x3 z u v, ph x3 y z w) u v))
            (@sbbidv (wceq (cv u) (cv y)) (λ z, wsb (λ x3, ph x3 y z w) u) (λ z, wsb (λ x3, ph x3 y z w) y) v
              (λ z, @sbequ (λ u y x3, ph x3 y z w) u y)))
          (@sbequ (λ v w z, wsb (λ x3, ph x3 y z w) y) v w))
        (@sylan9bbr (wceq (cv v) (cv w)) (wsb (λ x3, wsb (λ z, ph x3 y z w) v) u) (wsb (λ x3, wsb (λ z, ph x3 y z w) w) u) (wceq (cv u) (cv y)) (wsb (λ x3, wsb (λ z, ph x3 y z w) w) y)
          (@sbbidv (wceq (cv v) (cv w)) (λ x3, wsb (λ z, ph x3 y z w) v) (λ x3, wsb (λ z, ph x3 y z w) w) u
            (λ x3, @sbequ (λ v w z, ph x3 y z w) v w))
          (@sbequ (λ u y x3, wsb (λ z, ph x3 y z w) w) u y))))
    (@ax6ev y))
  (@ax6ev w)


/-- Theorem 19.11 of [Margaris] p. 89. (Contributed by NM, 5-Aug-1993.) Remove dependencies on ~
ax-5 , ~ ax-6 , ~ ax-7 , ~ ax-10 , ~ ax-12 . (Revised by Wolf Lammen, 8-Jan-2018.) (Proof shortened
by Wolf Lammen, 22-Aug-2020.) -/
theorem excom {ph : setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ y, wex (λ x3, ph x3 y))) :=
@«3bitr4i» (wn (wal (λ x3, wal (λ y, wn (ph x3 y))))) (wn (wal (λ y, wal (λ x3, wn (ph x3 y))))) (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ y, wex (λ x3, ph x3 y)))
  (@notbii (wal (λ x3, wal (λ y, wn (ph x3 y)))) (wal (λ y, wal (λ x3, wn (ph x3 y))))
    (@alcom (λ x3 y, wn (ph x3 y))))
  (@«2exnaln» (λ x3 y, ph x3 y))
  (@«2exnaln» (λ y x3, ph x3 y))


/-- One direction of Theorem 19.11 of [Margaris] p. 89. (Contributed by NM, 5-Aug-1993.) (Revised by
Mario Carneiro, 24-Sep-2016.) Remove dependencies on ~ ax-5 , ~ ax-6 , ~ ax-7 , ~ ax-10 , ~ ax-12 .
(Revised by Wolf Lammen, 8-Jan-2018.) -/
theorem excomim {ph : setvar → setvar → wff} :
  ⊦ wi (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ y, wex (λ x3, ph x3 y))) :=
@biimpi (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ y, wex (λ x3, ph x3 y)))
  (@excom (λ x3 y, ph x3 y))


/-- Swap 1st and 3rd existential quantifiers. (Contributed by NM, 9-Mar-1995.) -/
theorem excom13 {ph : setvar → setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wex (λ z, ph x3 y z)))) (wex (λ z, wex (λ y, wex (λ x3, ph x3 y z)))) :=
@«3bitri» (wex (λ x3, wex (λ y, wex (λ z, ph x3 y z)))) (wex (λ y, wex (λ x3, wex (λ z, ph x3 y z)))) (wex (λ y, wex (λ z, wex (λ x3, ph x3 y z)))) (wex (λ z, wex (λ y, wex (λ x3, ph x3 y z))))
  (@excom (λ x3 y, wex (λ z, ph x3 y z)))
  (@exbii (λ y, wex (λ x3, wex (λ z, ph x3 y z))) (λ y, wex (λ z, wex (λ x3, ph x3 y z)))
    (λ y, @excom (λ x3 z, ph x3 y z)))
  (@excom (λ y z, wex (λ x3, ph x3 y z)))


/-- Rotate existential quantifiers. (Contributed by NM, 17-Mar-1995.) -/
theorem exrot3 {ph : setvar → setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wex (λ z, ph x3 y z)))) (wex (λ y, wex (λ z, wex (λ x3, ph x3 y z)))) :=
@bitri (wex (λ x3, wex (λ y, wex (λ z, ph x3 y z)))) (wex (λ z, wex (λ y, wex (λ x3, ph x3 y z)))) (wex (λ y, wex (λ z, wex (λ x3, ph x3 y z))))
  (@excom13 (λ x3 y z, ph x3 y z))
  (@excom (λ z y, wex (λ x3, ph x3 y z)))


/-- Rotate existential quantifiers twice. (Contributed by NM, 9-Mar-1995.) -/
theorem exrot4 {ph : setvar → setvar → setvar → setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wex (λ z, wex (λ w, ph x3 y z w))))) (wex (λ z, wex (λ w, wex (λ x3, wex (λ y, ph x3 y z w))))) :=
@bitri (wex (λ x3, wex (λ y, wex (λ z, wex (λ w, ph x3 y z w))))) (wex (λ x3, wex (λ w, wex (λ z, wex (λ y, ph x3 y z w))))) (wex (λ z, wex (λ w, wex (λ x3, wex (λ y, ph x3 y z w)))))
  (@exbii (λ x3, wex (λ y, wex (λ z, wex (λ w, ph x3 y z w)))) (λ x3, wex (λ w, wex (λ z, wex (λ y, ph x3 y z w))))
    (λ x3, @excom13 (λ y z w, ph x3 y z w)))
  (@excom13 (λ x3 w z, wex (λ y, ph x3 y z w)))


/-- If ` x ` is not free in ` ph ` , it is not free in ` A. y ph ` . (Contributed by NM,
12-Mar-1993.) -/
theorem hbal {ph : setvar → setvar → wff}
  (hbal_1 : ∀ x3 y, ⊦ wi (ph x3 y) (wal (λ x3, ph x3 y)))
  (x3 : setvar) : ⊦ wi (wal (λ y, ph x3 y)) (wal (λ x3, wal (λ y, ph x3 y))) :=
@syl (wal (λ y, ph x3 y)) (wal (λ y, wal (λ x3, ph x3 y))) (wal (λ x3, wal (λ y, ph x3 y)))
  (@alimi (λ y, ph x3 y) (λ y, wal (λ x3, ph x3 y))
    (λ y, hbal_1 x3 y))
  (@ax_11 (λ y x3, ph x3 y))


/-- If ` z ` is not free in ` ph ` , it is not free in ` [ y / x ] ph ` when ` y ` and ` z ` are
distinct. Version of ~ hbsb with a disjoint variable condition, which requires fewer axioms.
(Contributed by NM, 12-Aug-1993.) (Revised by Gino Giotto, 23-May-2024.) -/
theorem hbsbw {ph : setvar → setvar → wff} {y : setvar}
  (hbsbw_1 : ∀ x3 z, ⊦ wi (ph x3 z) (wal (λ z, ph x3 z)))
  (z : setvar) : ⊦ wi (wsb (λ x3, ph x3 z) y) (wal (λ z, wsb (λ x3, ph x3 z) y)) :=
@hbxfrbi (λ z, wsb (λ x3, ph x3 z) y) (λ z, wal (λ w, wi (wceq (cv w) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))))
  (λ z, @df_sb (λ x3, ph x3 z) y)
  (λ z, @hbal (λ z w, wi (wceq (cv w) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))
    (λ z w, @sylibr (wi (wceq (cv w) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))) (wi (wceq (cv w) (cv y)) (wal (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))) (wal (λ z, wi (wceq (cv w) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))))
      (@imim2i (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))) (wal (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))) (wceq (cv w) (cv y))
        (@«3syl» (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))) (wal (λ x3, wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z)))) (wal (λ x3, wal (λ z, wi (wceq (cv x3) (cv w)) (ph x3 z)))) (wal (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))
          (@alimi (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)) (λ x3, wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z)))
            (λ x3, @imim2i (ph x3 z) (wal (λ z, ph x3 z)) (wceq (cv x3) (cv w))
              (hbsbw_1 x3 z)))
          (@alimi (λ x3, wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z))) (λ x3, wal (λ z, wi (wceq (cv x3) (cv w)) (ph x3 z)))
            (λ x3, @biimpri (wal (λ z, wi (wceq (cv x3) (cv w)) (ph x3 z))) (wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z)))
              (@«19_21v» (wceq (cv x3) (cv w)) (λ z, ph x3 z))))
          (@ax_11 (λ x3 z, wi (wceq (cv x3) (cv w)) (ph x3 z)))))
      (@«19_21v» (wceq (cv w) (cv y)) (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))) z) z


/-- If ` z ` is not free in ` ph ` , it is not free in ` [ y / x ] ph ` when ` y ` and ` z ` are
distinct. Version of ~ hbsb with a disjoint variable condition, which requires fewer axioms.
(Contributed by NM, 12-Aug-1993.) (Revised by Gino Giotto, 23-May-2024.) -/
theorem hbsbw_b {ph : setvar → setvar → wff}
  (hbsbw_1 : ∀ x3 z, ⊦ wi (ph x3 z) (wal (λ z, ph x3 z)))
  (x3 z : setvar) : ⊦ wi (wsb (λ x3, ph x3 z) x3) (wal (λ z, wsb (λ x3, ph x3 z) x3)) :=
@hbxfrbi (λ z, wsb (λ x3, ph x3 z) x3) (λ z, wal (λ w, wi (wceq (cv w) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))))
  (λ z, @df_sb_b (λ x3, ph x3 z) x3)
  (λ z, @hbal (λ z w, wi (wceq (cv w) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))
    (λ z w, @sylibr (wi (wceq (cv w) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))) (wi (wceq (cv w) (cv x3)) (wal (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))) (wal (λ z, wi (wceq (cv w) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))))
      (@imim2i (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))) (wal (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))) (wceq (cv w) (cv x3))
        (@«3syl» (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))) (wal (λ x3, wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z)))) (wal (λ x3, wal (λ z, wi (wceq (cv x3) (cv w)) (ph x3 z)))) (wal (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))
          (@alimi (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)) (λ x3, wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z)))
            (λ x3, @imim2i (ph x3 z) (wal (λ z, ph x3 z)) (wceq (cv x3) (cv w))
              (hbsbw_1 x3 z)))
          (@alimi (λ x3, wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z))) (λ x3, wal (λ z, wi (wceq (cv x3) (cv w)) (ph x3 z)))
            (λ x3, @biimpri (wal (λ z, wi (wceq (cv x3) (cv w)) (ph x3 z))) (wi (wceq (cv x3) (cv w)) (wal (λ z, ph x3 z)))
              (@«19_21v» (wceq (cv x3) (cv w)) (λ z, ph x3 z))))
          (@ax_11 (λ x3 z, wi (wceq (cv x3) (cv w)) (ph x3 z)))))
      (@«19_21v» (wceq (cv w) (cv x3)) (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))) z) z


/-- Lemma 24 of [Monk2] p. 114. (Contributed by Mario Carneiro, 24-Sep-2016.) Remove dependency on ~
ax-12 . (Revised by Wolf Lammen, 18-Oct-2021.) -/
theorem nfa2 {ph : setvar → setvar → wff} :
  ⊦ wnf (λ x3, wal (λ y, wal (λ x3, ph x3 y))) :=
@nfxfr (λ x3, wal (λ y, wal (λ x3, ph x3 y))) (λ x3, wal (λ x3, wal (λ y, ph x3 y)))
  (λ x3, @alcom (λ y x3, ph x3 y))
  (@nfa1 (λ x3, wal (λ y, ph x3 y)))


-- /-- Axiom of Substitution. One of the 5 equality axioms of predicate calculus. The final
-- consequent ` A. x ( x = y -> ph ) ` is a way of expressing " ` y ` substituted for ` x ` in wff `
-- ph ` " (cf. ~ sb6 ). It is based on Lemma 16 of [Tarski] p. 70 and Axiom C8 of [Monk2] p. 105,
-- from which it can be proved by cases. The original version of this axiom was ~ ax-c15 and was
-- replaced with this shorter ~ ax-12 in Jan. 2007. The old axiom is proved from this one as Theorem
-- ~ axc15 . Conversely, this axiom is proved from ~ ax-c15 as Theorem ~ ax12 . Juha Arpiainen
-- proved the metalogical independence of this axiom (in the form of the older axiom ~ ax-c15 ) from
-- the others on 19-Jan-2006. See item 9a at ~ https://us.metamath.org/award2003.html . See ~ ax12v
-- and ~ ax12v2 for other equivalents of this axiom that (unlike this axiom) have distinct variable
-- restrictions. This axiom scheme is logically redundant (see ~ ax12w ) but is used as an auxiliary
-- axiom scheme to achieve scheme completeness. (Contributed by NM, 22-Jan-2007.) (New usage is
-- discouraged.) -/
-- axiom ax_12 {ph : setvar → setvar → wff} : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (wal (λ y, ph x3 y)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))))


-- /-- Axiom of Substitution. One of the 5 equality axioms of predicate calculus. The final
-- consequent ` A. x ( x = y -> ph ) ` is a way of expressing " ` y ` substituted for ` x ` in wff `
-- ph ` " (cf. ~ sb6 ). It is based on Lemma 16 of [Tarski] p. 70 and Axiom C8 of [Monk2] p. 105,
-- from which it can be proved by cases. The original version of this axiom was ~ ax-c15 and was
-- replaced with this shorter ~ ax-12 in Jan. 2007. The old axiom is proved from this one as Theorem
-- ~ axc15 . Conversely, this axiom is proved from ~ ax-c15 as Theorem ~ ax12 . Juha Arpiainen
-- proved the metalogical independence of this axiom (in the form of the older axiom ~ ax-c15 ) from
-- the others on 19-Jan-2006. See item 9a at ~ https://us.metamath.org/award2003.html . See ~ ax12v
-- and ~ ax12v2 for other equivalents of this axiom that (unlike this axiom) have distinct variable
-- restrictions. This axiom scheme is logically redundant (see ~ ax12w ) but is used as an auxiliary
-- axiom scheme to achieve scheme completeness. (Contributed by NM, 22-Jan-2007.) (New usage is
-- discouraged.) -/
-- axiom ax_12_b {ph : setvar → wff} : ∀ x3, ⊦ wi (wceq (cv x3) (cv x3)) (wi (wal (λ x3, ph x3)) (wal (λ x3, wi (wceq (cv x3) (cv x3)) (ph x3))))


/-- This is essentially Axiom ~ ax-12 weakened by additional restrictions on variables. Besides ~
axc11r , this theorem should be the only one referencing ~ ax-12 directly. Both restrictions on
variables have their own value. If for a moment we assume ` x ` could be set to ` y ` , then, after
elimination of the tautology ` y = y ` , immediately we have ` ph -> A. y ph ` for all ` ph ` and `
y ` , that is ~ ax-5 , a degenerate result. The second restriction is not necessary, but a
simplification that makes the following interpretation easier to see. Since ` ph ` textually at most
depends on ` x ` , we can look at it at some given 'fixed' ` y ` . This theorem now states that the
truth value of ` ph ` will stay constant, as long as we 'vary ` x ` around ` y ` ' only such that `
x = y ` still holds. Or in other words, equality is the finest grained logical expression. If you
cannot differ two sets by ` = ` , you won't find a whatever sophisticated expression that does. One
might wonder how the described variation of ` x ` is possible at all. Note that Metamath is a text
processor that easily sees a difference between text chunks ` { x | -. x = x } ` and ` { y | -. y =
y } ` . Our usual interpretation is to abstract from textual variations of the same set, but we are
free to interpret Metamath's formalism differently, and in fact let ` x ` run through all textual
representations of sets. Had we allowed ` ph ` to depend also on ` y ` , this idea is both harder to
see, and it is less clear that this extra freedom introduces effects not covered by other axioms.
(Contributed by Wolf Lammen, 8-Aug-2020.) -/
theorem ax12v {ph : setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))) :=
@syl5 (ph x3) (wal (λ y, ph x3)) (wceq (cv x3) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))
  (@ax_5 (ph x3))
  (@ax_12 (λ x3 y, ph x3) x3 y)


/-- It is possible to remove any restriction on ` ph ` in ~ ax12v . Same as Axiom C8 of [Monk2] p.
105. Use ~ ax12v instead when sufficient. (Contributed by NM, 5-Aug-1993.) Remove dependencies on ~
ax-10 and ~ ax-13 . (Revised by Jim Kingdon, 15-Dec-2017.) (Proof shortened by Wolf Lammen,
8-Dec-2019.) -/
theorem ax12v2 {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y)))) :=
@exlimiiv (λ z, wceq (cv y) (cv z)) (wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y)))))
  (λ z, @syld (wceq (cv y) (cv z)) (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z)) (wi (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))))
    (@equtrr z y x3)
    (@syl9r (wceq (cv x3) (cv z)) (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv z)) (ph x3 y))) (wceq (cv y) (cv z)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y)))
      (@ax12v (λ x3, ph x3 y) x3 z)
      (@alimdv (wceq (cv y) (cv z)) (λ x3, wi (wceq (cv x3) (cv z)) (ph x3 y)) (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))
        (λ x3, @imim1d (wceq (cv y) (cv z)) (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z)) (ph x3 y)
          (@equtrr z y x3)))))
  (@ax6evr y)


/-- If a wff is true, it is true for at least one instance. Special case of Theorem 19.8 of
[Margaris] p. 89. See ~ 19.8v for a version with a disjoint variable condition requiring fewer
axioms. (Contributed by NM, 9-Jan-1993.) Allow a shortening of ~ sp . (Revised by Wolf Lammen,
13-Jan-2018.) (Proof shortened by Wolf Lammen, 8-Dec-2019.) -/
theorem «19_8a» {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (ph x3) (wex (λ x3, ph x3)) :=
@exlimiiv (λ y, wceq (cv x3) (cv y)) (wi (ph x3) (wex (λ x3, ph x3)))
  (λ y, @syl6 (wceq (cv x3) (cv y)) (ph x3) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wex (λ x3, ph x3))
    (@ax12v (λ x3, ph x3) x3 y)
    (@alequexv (λ x3, ph x3) y))
  (@ax6evr x3)


/-- If a wff is true, it is true for at least one instance. Deduction form of ~ 19.8a . (Contributed
by DAW, 13-Feb-2017.) -/
theorem «19_8ad» {ph ps : setvar → wff}
  («19_8ad_1» : ∀ x3, ⊦ wi (ph x3) (ps x3))
  (x3 : setvar) : ⊦ wi (ph x3) (wex (λ x3, ps x3)) :=
@syl (ph x3) (ps x3) (wex (λ x3, ps x3))
  («19_8ad_1» x3)
  (@«19_8a» (λ x3, ps x3) x3)


/-- Specialization. A universally quantified wff implies the wff without a quantifier. Axiom scheme
B5 of [Tarski] p. 67 (under his system S2, defined in the last paragraph on p. 77). Also appears as
Axiom scheme C5' in [Megill] p. 448 (p. 16 of the preprint). This corresponds to the axiom (T) of
modal logic. For the axiom of specialization presented in many logic textbooks, see Theorem ~ stdpc4
. This theorem shows that our obsolete axiom ~ ax-c5 can be derived from the others. The proof uses
ideas from the proof of Lemma 21 of [Monk2] p. 114. It appears that this scheme cannot be derived
directly from Tarski's axioms without auxiliary axiom scheme ~ ax-12 . It is thought the best we can
do using only Tarski's axioms is ~ spw . Also see ~ spvw where ` x ` and ` ph ` are disjoint, using
fewer axioms. (Contributed by NM, 21-May-2008.) (Proof shortened by Scott Fenton, 24-Jan-2011.)
(Proof shortened by Wolf Lammen, 13-Jan-2018.) -/
theorem sp {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wal (λ x3, ph x3)) (ph x3) :=
@sylbi (wal (λ x3, ph x3)) (wn (wex (λ x3, wn (ph x3)))) (ph x3)
  (@alex (λ x3, ph x3))
  (@con1i (ph x3) (wex (λ x3, wn (ph x3)))
    (@«19_8a» (λ x3, wn (ph x3)) x3))


/-- Generalization of antecedent. (Contributed by NM, 5-Jan-1993.) -/
theorem sps {ph ps : setvar → wff}
  (sps_1 : ∀ x3, ⊦ wi (ph x3) (ps x3))
  (x3 : setvar) : ⊦ wi (wal (λ x3, ph x3)) (ps x3) :=
@syl (wal (λ x3, ph x3)) (ph x3) (ps x3)
  (@sp (λ x3, ph x3) x3)
  (sps_1 x3)


/-- A double specialization (see ~ sp ). Another double specialization, closer to PM*11.1, is ~
2stdpc4 . (Contributed by BJ, 15-Sep-2018.) -/
theorem «2sp» {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wal (λ y, ph x3 y))) (ph x3 y) :=
@sps (λ x3, wal (λ y, ph x3 y)) (λ x3, ph x3 y)
  (λ x3, @sp (λ y, ph x3 y) y) x3


/-- Deduction generalizing antecedent. (Contributed by NM, 17-Aug-1994.) -/
theorem spsd {ph ps ch : setvar → wff}
  (spsd_1 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wal (λ x3, ps x3)) (ch x3)) :=
@syl5 (wal (λ x3, ps x3)) (ps x3) (ph x3) (ch x3)
  (@sp (λ x3, ps x3) x3)
  (spsd_1 x3)


/-- Inference form of ~ 19.21 and also deduction form of ~ sp . (Contributed by NM, 26-May-1993.) -/
theorem «19_21bi» {ph ps : setvar → wff}
  («19_21bi_1» : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (ps x3) :=
@syl (ph x3) (wal (λ x3, ps x3)) (ps x3)
  («19_21bi_1» x3)
  (@sp (λ x3, ps x3) x3)


/-- Inference removing two universal quantifiers. Version of ~ 19.21bi with two quantifiers.
(Contributed by NM, 20-Apr-1994.) -/
theorem «19_21bbi» {ph ps : setvar → setvar → wff}
  («19_21bbi_1» : ∀ x3 y, ⊦ wi (ph x3 y) (wal (λ x3, wal (λ y, ps x3 y))))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (ps x3 y) :=
@«19_21bi» (λ y, ph x3 y) (λ y, ps x3 y)
  (λ y, @«19_21bi» (λ x3, ph x3 y) (λ x3, wal (λ y, ps x3 y))
    (λ x3, «19_21bbi_1» x3 y) x3) y


/-- Inference form of Theorem 19.23 of [Margaris] p. 90, see ~ 19.23 . (Contributed by NM,
12-Mar-1993.) -/
theorem «19_23bi» {ph ps : setvar → wff}
  («19_23bi_1» : ∀ x3, ⊦ wi (wex (λ x3, ph x3)) (ps x3))
  (x3 : setvar) : ⊦ wi (ph x3) (ps x3) :=
@syl (ph x3) (wex (λ x3, ph x3)) (ps x3)
  (@«19_8a» (λ x3, ph x3) x3)
  («19_23bi_1» x3)


/-- Consequence of the definition of not-free. (Contributed by Mario Carneiro, 26-Sep-2016.) ~ df-nf
changed. (Revised by Wolf Lammen, 11-Sep-2021.) (Proof shortened by Wolf Lammen, 23-Nov-2023.) -/
theorem nf5r {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wnf (λ x3, ph x3)) (wi (ph x3) (wal (λ x3, ph x3))) :=
@syl5 (ph x3) (wex (λ x3, ph x3)) (wnf (λ x3, ph x3)) (wal (λ x3, ph x3))
  (@«19_8a» (λ x3, ph x3) x3)
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3))), from
    @nfrd (λ x3, wnf (λ x3, ph x3)) (λ x3, ph x3)
      (λ x3, @id (wnf (λ x3, ph x3))) x3)


/-- Consequence of the definition of not-free. (Contributed by Mario Carneiro, 11-Aug-2016.) (Proof
shortened by Wolf Lammen, 15-Mar-2023.) -/
theorem nf5ri {ph : setvar → wff}
  (nf5ri_1 : ⊦ wnf (λ x3, ph x3))
  (x3 : setvar) : ⊦ wi (ph x3) (wal (λ x3, ph x3)) :=
@«19_23bi» (λ x3, ph x3) (λ x3, wal (λ x3, ph x3))
  (λ x3, @nfri (λ x3, ph x3)
    nf5ri_1) x3


/-- Consequence of the definition of not-free in a context. (Contributed by Mario Carneiro,
11-Aug-2016.) -/
theorem nf5rd {ph ps : setvar → wff}
  (nf5rd_1 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (ps x3) (wal (λ x3, ps x3))) :=
@syl (ph x3) (wnf (λ x3, ps x3)) (wi (ps x3) (wal (λ x3, ps x3)))
  (nf5rd_1 x3)
  (@nf5r (λ x3, ps x3) x3)


/-- A closed form of ~ nfim . (Contributed by NM, 2-Jun-1993.) (Revised by Mario Carneiro,
24-Sep-2016.) (Proof shortened by Wolf Lammen, 2-Jan-2018.) ~ df-nf changed. (Revised by Wolf
Lammen, 18-Sep-2021.) -/
theorem nfim1 {ph ps : setvar → wff}
  (nfim1_1 : ⊦ wnf (λ x3, ph x3))
  (nfim1_2 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3))) :
  ⊦ wnf (λ x3, wi (ph x3) (ps x3)) :=
@ax_mp (wo (wal (λ x3, ph x3)) (wal (λ x3, wn (ph x3)))) (wnf (λ x3, wi (ph x3) (ps x3)))
  (@mpbi (wnf (λ x3, ph x3)) (wo (wal (λ x3, ph x3)) (wal (λ x3, wn (ph x3))))
    nfim1_1
    (@nf3 (λ x3, ph x3)))
  (@jaoi (wal (λ x3, ph x3)) (wnf (λ x3, wi (ph x3) (ps x3))) (wal (λ x3, wn (ph x3)))
    (setvar.forget $ λ x3 : setvar,
      show ⊦ wi (wal (λ x3, ph x3)) (wnf (λ x3, wi (ph x3) (ps x3))), from
      @nfimd (λ x3, wal (λ x3, ph x3)) (λ x3, ph x3) (λ x3, ps x3)
        (λ x3, @nftht (λ x3, ph x3))
        (λ x3, setvar.forget $ λ x3 : setvar,
          show ⊦ wi (wal (λ x3, ph x3)) (wnf (λ x3, ps x3)), from
          @sps (λ x3, ph x3) (λ x3, wnf (λ x3, ps x3))
            (λ x3, nfim1_2 x3) x3) x3)
    (@syl (wal (λ x3, wn (ph x3))) (wal (λ x3, wi (ph x3) (ps x3))) (wnf (λ x3, wi (ph x3) (ps x3)))
      (@alimi (λ x3, wn (ph x3)) (λ x3, wi (ph x3) (ps x3))
        (λ x3, @pm2_21 (ph x3) (ps x3)))
      (@nftht (λ x3, wi (ph x3) (ps x3)))))


/-- A closed form of ~ nfan . (Contributed by Mario Carneiro, 3-Oct-2016.) ~ df-nf changed. (Revised
by Wolf Lammen, 18-Sep-2021.) (Proof shortened by Wolf Lammen, 7-Jul-2022.) -/
theorem nfan1 {ph ps : setvar → wff}
  (nfim1_1 : ⊦ wnf (λ x3, ph x3))
  (nfim1_2 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3))) :
  ⊦ wnf (λ x3, wa (ph x3) (ps x3)) :=
@nfxfr (λ x3, wa (ph x3) (ps x3)) (λ x3, wn (wi (ph x3) (wn (ps x3))))
  (λ x3, @df_an (ph x3) (ps x3))
  (@nfn (λ x3, wi (ph x3) (wn (ps x3)))
    (@nfim1 (λ x3, ph x3) (λ x3, wn (ps x3))
      nfim1_1
      (λ x3, @nfnd (λ x3, ph x3) (λ x3, ps x3)
        (λ x3, nfim1_2 x3) x3)))


/-- Closed form of ~ 19.3 and version of ~ 19.9t with a universal quantifier. (Contributed by NM,
9-Nov-2020.) (Proof shortened by BJ, 9-Oct-2022.) -/
theorem «19_3t» {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wnf (λ x3, ph x3)) (wb (wal (λ x3, ph x3)) (ph x3)) :=
@impbid2 (wnf (λ x3, ph x3)) (wal (λ x3, ph x3)) (ph x3)
  (@sp (λ x3, ph x3) x3)
  (@nf5r (λ x3, ph x3) x3)


/-- A wff may be quantified with a variable not free in it. Version of ~ 19.9 with a universal
quantifier. Theorem 19.3 of [Margaris] p. 89. See ~ 19.3v for a version requiring fewer axioms.
(Contributed by NM, 12-Mar-1993.) (Revised by Mario Carneiro, 24-Sep-2016.) -/
theorem «19_3» {ph : setvar → wff}
  («19_3_1» : ⊦ wnf (λ x3, ph x3))
  (x3 : setvar) : ⊦ wb (wal (λ x3, ph x3)) (ph x3) :=
@impbii (wal (λ x3, ph x3)) (ph x3)
  (@sp (λ x3, ph x3) x3)
  (@nf5ri (λ x3, ph x3)
    «19_3_1» x3)


/-- A deduction version of one direction of ~ 19.9 . (Contributed by NM, 14-May-1993.) (Revised by
Mario Carneiro, 24-Sep-2016.) Revised to shorten other proofs. (Revised by Wolf Lammen,
14-Jul-2020.) ~ df-nf changed. (Revised by Wolf Lammen, 11-Sep-2021.) (Proof shortened by Wolf
Lammen, 8-Jul-2022.) -/
theorem «19_9d» {ph ps : setvar → wff}
  («19_9d_1» : ∀ x3, ⊦ wi (ps x3) (wnf (λ x3, ph x3)))
  (x3 : setvar) : ⊦ wi (ps x3) (wi (wex (λ x3, ph x3)) (ph x3)) :=
@syl6 (ps x3) (wex (λ x3, ph x3)) (wal (λ x3, ph x3)) (ph x3)
  (@nfrd (λ x3, ps x3) (λ x3, ph x3)
    (λ x3, «19_9d_1» x3) x3)
  (@sp (λ x3, ph x3) x3)


/-- Closed form of ~ 19.9 and version of ~ 19.3t with an existential quantifier. (Contributed by NM,
13-May-1993.) (Revised by Mario Carneiro, 24-Sep-2016.) (Proof shortened by Wolf Lammen,
14-Jul-2020.) -/
theorem «19_9t» {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wnf (λ x3, ph x3)) (wb (wex (λ x3, ph x3)) (ph x3)) :=
@impbid1 (wnf (λ x3, ph x3)) (wex (λ x3, ph x3)) (ph x3)
  (@«19_9d» (λ x3, ph x3) (λ x3, wnf (λ x3, ph x3))
    (λ x3, @id (wnf (λ x3, ph x3))) x3)
  (@«19_8a» (λ x3, ph x3) x3)


/-- A wff may be existentially quantified with a variable not free in it. Version of ~ 19.3 with an
existential quantifier. Theorem 19.9 of [Margaris] p. 89. See ~ 19.9v for a version requiring fewer
axioms. (Contributed by FL, 24-Mar-2007.) (Revised by Mario Carneiro, 24-Sep-2016.) (Proof shortened
by Wolf Lammen, 30-Dec-2017.) Revised to shorten other proofs. (Revised by Wolf Lammen,
14-Jul-2020.) -/
theorem «19_9» {ph : setvar → wff}
  («19_9_1» : ⊦ wnf (λ x3, ph x3))
  (x3 : setvar) : ⊦ wb (wex (λ x3, ph x3)) (ph x3) :=
@ax_mp (wnf (λ x3, ph x3)) (wb (wex (λ x3, ph x3)) (ph x3))
  «19_9_1»
  (@«19_9t» (λ x3, ph x3) x3)


/-- Closed form of Theorem 19.21 of [Margaris] p. 90, see ~ 19.21 . (Contributed by NM,
27-May-1997.) (Revised by Mario Carneiro, 24-Sep-2016.) (Proof shortened by Wolf Lammen,
3-Jan-2018.) ~ df-nf changed. (Revised by Wolf Lammen, 11-Sep-2021.) (Proof shortened by BJ,
3-Nov-2021.) -/
theorem «19_21t» {ph ps : setvar → wff}
  (x3 : setvar) : ⊦ wi (wnf (λ x3, ph x3)) (wb (wal (λ x3, wi (ph x3) (ps x3))) (wi (ph x3) (wal (λ x3, ps x3)))) :=
@bitr3d (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, wi (ph x3) (ps x3))) (wi (ph x3) (wal (λ x3, ps x3)))
  (@«19_38a» (λ x3, ph x3) (λ x3, ps x3))
  (@imbi1d (wnf (λ x3, ph x3)) (wex (λ x3, ph x3)) (ph x3) (wal (λ x3, ps x3))
    (@«19_9t» (λ x3, ph x3) x3))


/-- Theorem 19.21 of [Margaris] p. 90. The hypothesis can be thought of as " ` x ` is not free in `
ph ` ". See ~ 19.21v for a version requiring fewer axioms. See also ~ 19.21h . (Contributed by NM,
14-May-1993.) (Revised by Mario Carneiro, 24-Sep-2016.) ~ df-nf changed. (Revised by Wolf Lammen,
18-Sep-2021.) -/
theorem «19_21» {ph ps : setvar → wff}
  («19_21_1» : ⊦ wnf (λ x3, ph x3))
  (x3 : setvar) : ⊦ wb (wal (λ x3, wi (ph x3) (ps x3))) (wi (ph x3) (wal (λ x3, ps x3))) :=
@ax_mp (wnf (λ x3, ph x3)) (wb (wal (λ x3, wi (ph x3) (ps x3))) (wi (ph x3) (wal (λ x3, ps x3))))
  «19_21_1»
  (@«19_21t» (λ x3, ph x3) (λ x3, ps x3) x3)


/-- Closed form of Theorem 19.23 of [Margaris] p. 90. See ~ 19.23 . (Contributed by NM, 7-Nov-2005.)
(Proof shortened by Wolf Lammen, 13-Aug-2020.) ~ df-nf changed. (Revised by Wolf Lammen,
11-Sep-2021.) (Proof shortened by BJ, 8-Oct-2022.) -/
theorem «19_23t» {ph ps : setvar → wff}
  (x3 : setvar) : ⊦ wi (wnf (λ x3, ps x3)) (wb (wal (λ x3, wi (ph x3) (ps x3))) (wi (wex (λ x3, ph x3)) (ps x3))) :=
@bitr3d (wnf (λ x3, ps x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ps x3))) (wal (λ x3, wi (ph x3) (ps x3))) (wi (wex (λ x3, ph x3)) (ps x3))
  (@«19_38b» (λ x3, ph x3) (λ x3, ps x3))
  (@imbi2d (wnf (λ x3, ps x3)) (wal (λ x3, ps x3)) (ps x3) (wex (λ x3, ph x3))
    (@«19_3t» (λ x3, ps x3) x3))


/-- Theorem 19.23 of [Margaris] p. 90. See ~ 19.23v for a version requiring fewer axioms.
(Contributed by NM, 24-Jan-1993.) (Revised by Mario Carneiro, 24-Sep-2016.) -/
theorem «19_23» {ph ps : setvar → wff}
  («19_23_1» : ⊦ wnf (λ x3, ps x3))
  (x3 : setvar) : ⊦ wb (wal (λ x3, wi (ph x3) (ps x3))) (wi (wex (λ x3, ph x3)) (ps x3)) :=
@ax_mp (wnf (λ x3, ps x3)) (wb (wal (λ x3, wi (ph x3) (ps x3))) (wi (wex (λ x3, ph x3)) (ps x3)))
  «19_23_1»
  (@«19_23t» (λ x3, ph x3) (λ x3, ps x3) x3)


/-- Deduction form of Theorem 19.20 of [Margaris] p. 90, see ~ alim . See ~ alimdh , ~ alimdv for
variants requiring fewer axioms. (Contributed by Mario Carneiro, 24-Sep-2016.) -/
theorem alimd {ph ps ch : setvar → wff}
  (alimd_1 : ⊦ wnf (λ x3, ph x3))
  (alimd_2 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wal (λ x3, ps x3)) (wal (λ x3, ch x3))) :=
@alimdh (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
  (λ x3, @nf5ri (λ x3, ph x3)
    alimd_1 x3)
  (λ x3, alimd_2 x3) x3


/-- Inference form of Theorem 19.21 of [Margaris] p. 90, see ~ 19.21 . (Contributed by Mario
Carneiro, 24-Sep-2016.) -/
theorem alrimi {ph ps : setvar → wff}
  (alrimi_1 : ⊦ wnf (λ x3, ph x3))
  (alrimi_2 : ∀ x3, ⊦ wi (ph x3) (ps x3))
  (x3 : setvar) : ⊦ wi (ph x3) (wal (λ x3, ps x3)) :=
@alrimih (λ x3, ph x3) (λ x3, ps x3)
  (λ x3, @nf5ri (λ x3, ph x3)
    alrimi_1 x3)
  (λ x3, alrimi_2 x3) x3


/-- Deduction form of Theorem 19.21 of [Margaris] p. 90, see ~ 19.21 . (Contributed by Mario
Carneiro, 24-Sep-2016.) -/
theorem alrimdd {ph ps ch : setvar → wff}
  (alrimdd_1 : ⊦ wnf (λ x3, ph x3))
  (alrimdd_2 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ps x3)))
  (alrimdd_3 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (ps x3) (wal (λ x3, ch x3))) :=
@syld (ph x3) (ps x3) (wal (λ x3, ps x3)) (wal (λ x3, ch x3))
  (@nf5rd (λ x3, ph x3) (λ x3, ps x3)
    (λ x3, alrimdd_2 x3) x3)
  (@alimd (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    alrimdd_1
    (λ x3, alrimdd_3 x3) x3)


/-- Deduction form of Theorem 19.21 of [Margaris] p. 90, see ~ 19.21 . (Contributed by Mario
Carneiro, 24-Sep-2016.) -/
theorem alrimd {ph ps ch : setvar → wff}
  (alrimd_1 : ⊦ wnf (λ x3, ph x3))
  (alrimd_2 : ⊦ wnf (λ x3, ps x3))
  (alrimd_3 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (ps x3) (wal (λ x3, ch x3))) :=
@alrimdd (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
  alrimd_1
  (λ x3, @a1i (wnf (λ x3, ps x3)) (ph x3)
    alrimd_2)
  (λ x3, alrimd_3 x3) x3


/-- Deduction form of Theorem 19.22 of [Margaris] p. 90, see ~ exim . (Contributed by NM,
29-Jun-1993.) (Revised by Mario Carneiro, 24-Sep-2016.) -/
theorem eximd {ph ps ch : setvar → wff}
  (eximd_1 : ⊦ wnf (λ x3, ph x3))
  (eximd_2 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
@eximdh (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
  (λ x3, @nf5ri (λ x3, ph x3)
    eximd_1 x3)
  (λ x3, eximd_2 x3) x3


/-- Inference associated with ~ 19.23 . See ~ exlimiv for a version with a disjoint variable
condition requiring fewer axioms. (Contributed by NM, 10-Jan-1993.) (Revised by Mario Carneiro,
24-Sep-2016.) -/
theorem exlimi {ph ps : setvar → wff}
  (exlimi_1 : ⊦ wnf (λ x3, ps x3))
  (exlimi_2 : ∀ x3, ⊦ wi (ph x3) (ps x3))
  (x3 : setvar) : ⊦ wi (wex (λ x3, ph x3)) (ps x3) :=
@mpgbi (λ x3, wi (ph x3) (ps x3)) (λ x3, wi (wex (λ x3, ph x3)) (ps x3))
  (λ x3, @«19_23» (λ x3, ph x3) (λ x3, ps x3)
    exlimi_1 x3)
  (λ x3, exlimi_2 x3) x3


/-- Deduction form of Theorem 19.9 of [Margaris] p. 89. (Contributed by NM, 23-Jan-1993.) (Revised
by Mario Carneiro, 24-Sep-2016.) (Proof shortened by Wolf Lammen, 12-Jan-2018.) -/
theorem exlimd {ph ps ch : setvar → wff}
  (exlimd_1 : ⊦ wnf (λ x3, ph x3))
  (exlimd_2 : ⊦ wnf (λ x3, ch x3))
  (exlimd_3 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wex (λ x3, ps x3)) (ch x3)) :=
@syl6ib (ph x3) (wex (λ x3, ps x3)) (wex (λ x3, ch x3)) (ch x3)
  (@eximd (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    exlimd_1
    (λ x3, exlimd_3 x3) x3)
  (@«19_9» (λ x3, ch x3)
    exlimd_2 x3)


/-- Existential elimination rule of natural deduction. (Contributed by ML, 17-Jul-2020.) Shorten ~
exlimdd . (Revised by Wolf Lammen, 3-Sep-2023.) -/
theorem exlimimdd {ph ps ch : setvar → wff}
  (exlimdd_1 : ⊦ wnf (λ x3, ph x3))
  (exlimdd_2 : ⊦ wnf (λ x3, ch x3))
  (exlimdd_3 : ∀ x3, ⊦ wi (ph x3) (wex (λ x3, ps x3)))
  (exlimimdd_4 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (ch x3) :=
@mpd (ph x3) (wex (λ x3, ps x3)) (ch x3)
  (exlimdd_3 x3)
  (@exlimd (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
    exlimdd_1
    exlimdd_2
    (λ x3, exlimimdd_4 x3) x3)


/-- Formula-building rule for universal quantifier (deduction form). (Contributed by Mario Carneiro,
24-Sep-2016.) -/
theorem albid {ph ps ch : setvar → wff}
  (albid_1 : ⊦ wnf (λ x3, ph x3))
  (albid_2 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wal (λ x3, ps x3)) (wal (λ x3, ch x3))) :=
@albidh (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
  (λ x3, @nf5ri (λ x3, ph x3)
    albid_1 x3)
  (λ x3, albid_2 x3) x3


/-- Formula-building rule for existential quantifier (deduction form). (Contributed by Mario
Carneiro, 24-Sep-2016.) -/
theorem exbid {ph ps ch : setvar → wff}
  (albid_1 : ⊦ wnf (λ x3, ph x3))
  (albid_2 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wex (λ x3, ps x3)) (wex (λ x3, ch x3))) :=
@exbidh (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
  (λ x3, @nf5ri (λ x3, ph x3)
    albid_1 x3)
  (λ x3, albid_2 x3) x3


/-- An equality theorem for effectively not free. (Contributed by Mario Carneiro, 4-Oct-2016.) ~
df-nf changed. (Revised by Wolf Lammen, 18-Sep-2021.) -/
theorem nfbidf {ph ps ch : setvar → wff}
  (albid_1 : ⊦ wnf (λ x3, ph x3))
  (albid_2 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wnf (λ x3, ps x3)) (wnf (λ x3, ch x3))) :=
@«3bitr4g» (ph x3) (wi (wex (λ x3, ps x3)) (wal (λ x3, ps x3))) (wi (wex (λ x3, ch x3)) (wal (λ x3, ch x3))) (wnf (λ x3, ps x3)) (wnf (λ x3, ch x3))
  (@imbi12d (ph x3) (wex (λ x3, ps x3)) (wex (λ x3, ch x3)) (wal (λ x3, ps x3)) (wal (λ x3, ch x3))
    (@exbid (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
      albid_1
      (λ x3, albid_2 x3) x3)
    (@albid (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3)
      albid_1
      (λ x3, albid_2 x3) x3))
  (@df_nf (λ x3, ps x3))
  (@df_nf (λ x3, ch x3))


/-- Theorem 19.36 of [Margaris] p. 90. See ~ 19.36v for a version requiring fewer axioms.
(Contributed by NM, 24-Jun-1993.) -/
theorem «19_36» {ph ps : setvar → wff}
  («19_36_1» : ⊦ wnf (λ x3, ps x3))
  (x3 : setvar) : ⊦ wb (wex (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (ps x3)) :=
@bitri (wex (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (wex (λ x3, ps x3))) (wi (wal (λ x3, ph x3)) (ps x3))
  (@«19_35» (λ x3, ph x3) (λ x3, ps x3))
  (@imbi2i (wex (λ x3, ps x3)) (ps x3) (wal (λ x3, ph x3))
    (@«19_9» (λ x3, ps x3)
      «19_36_1» x3))


/-- Inference associated with ~ 19.36 . See ~ 19.36iv for a version requiring fewer axioms.
(Contributed by NM, 24-Jun-1993.) -/
theorem «19_36i» {ph ps : setvar → wff}
  («19_36_1» : ⊦ wnf (λ x3, ps x3))
  («19_36i_2» : ⊦ wex (λ x3, wi (ph x3) (ps x3)))
  (x3 : setvar) : ⊦ wi (wal (λ x3, ph x3)) (ps x3) :=
@mpbi (wex (λ x3, wi (ph x3) (ps x3))) (wi (wal (λ x3, ph x3)) (ps x3))
  «19_36i_2»
  (@«19_36» (λ x3, ph x3) (λ x3, ps x3)
    «19_36_1» x3)


/-- Theorem 19.41 of [Margaris] p. 90. See ~ 19.41v for a version requiring fewer axioms.
(Contributed by NM, 14-May-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened
by Wolf Lammen, 12-Jan-2018.) -/
theorem «19_41» {ph ps : setvar → wff}
  («19_41_1» : ⊦ wnf (λ x3, ps x3))
  (x3 : setvar) : ⊦ wb (wex (λ x3, wa (ph x3) (ps x3))) (wa (wex (λ x3, ph x3)) (ps x3)) :=
@impbii (wex (λ x3, wa (ph x3) (ps x3))) (wa (wex (λ x3, ph x3)) (ps x3))
  (@sylib (wex (λ x3, wa (ph x3) (ps x3))) (wa (wex (λ x3, ph x3)) (wex (λ x3, ps x3))) (wa (wex (λ x3, ph x3)) (ps x3))
    (@«19_40» (λ x3, ph x3) (λ x3, ps x3))
    (@anbi2i (wex (λ x3, ps x3)) (ps x3) (wex (λ x3, ph x3))
      (@«19_9» (λ x3, ps x3)
        «19_41_1» x3)))
  (@impcom (ps x3) (wex (λ x3, ph x3)) (wex (λ x3, wa (ph x3) (ps x3)))
    (@eximd (λ x3, ps x3) (λ x3, ph x3) (λ x3, wa (ph x3) (ps x3))
      «19_41_1»
      (λ x3, @pm3_21 (ps x3) (ph x3)) x3))


/-- Theorem 19.42 of [Margaris] p. 90. See ~ 19.42v for a version requiring fewer axioms. See ~ exan
for an immediate version. (Contributed by NM, 18-Aug-1993.) -/
theorem «19_42» {ph ps : setvar → wff}
  («19_42_1» : ⊦ wnf (λ x3, ph x3))
  (x3 : setvar) : ⊦ wb (wex (λ x3, wa (ph x3) (ps x3))) (wa (ph x3) (wex (λ x3, ps x3))) :=
@«3bitr4i» (wex (λ x3, wa (ps x3) (ph x3))) (wa (wex (λ x3, ps x3)) (ph x3)) (wex (λ x3, wa (ph x3) (ps x3))) (wa (ph x3) (wex (λ x3, ps x3)))
  (@«19_41» (λ x3, ps x3) (λ x3, ph x3)
    «19_42_1» x3)
  (@exancom (λ x3, ph x3) (λ x3, ps x3))
  (@ancom (ph x3) (wex (λ x3, ps x3)))


/-- Specialization, using implicit substitution. Version of ~ spim with a disjoint variable
condition, which does not require ~ ax-13 . See ~ spimvw for a version with two disjoint variable
conditions, requiring fewer axioms, and ~ spimv for another variant. (Contributed by NM,
10-Jan-1993.) (Revised by BJ, 31-May-2019.) -/
theorem spimfv {ph ps : setvar → setvar → wff}
  (spimfv_nf : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (spimfv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, ph x3 y)) (ps x3 y) :=
@«19_36i» (λ x3, ph x3 y) (λ x3, ps x3 y)
  (spimfv_nf y)
  (@eximii (λ x3, wceq (cv x3) (cv y)) (λ x3, wi (ph x3 y) (ps x3 y))
    (@ax6ev y)
    (λ x3, spimfv_1 x3 y)) x3


/-- Implicit substitution of ` y ` for ` x ` into a theorem. Version of ~ chvar with a disjoint
variable condition, which does not require ~ ax-13 . (Contributed by Raph Levien, 9-Jul-2003.)
(Revised by BJ, 31-May-2019.) -/
theorem chvarfv {ph ps : setvar → setvar → wff}
  (chvarfv_nf : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (chvarfv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (chvarfv_2 : ∀ x3 y, ⊦ ph x3 y)
  (x3 y : setvar) : ⊦ ps x3 y :=
@mpg (λ x3, ph x3 y) (λ x3, ps x3 y)
  (λ x3, @spimfv (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ y, chvarfv_nf y)
    (λ x3 y, @biimpd (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
      (chvarfv_1 x3 y)) x3 y)
  (λ x3, chvarfv_2 x3 y) x3


/-- Equivalence of two ways to express proper substitution of a setvar for another setvar disjoint
from it in a formula. This proof of their equivalence does not use ~ df-sb . That both sides of the
biconditional express proper substitution is proved by ~ sb5 and ~ sb6 . The implication "to the
left" is ~ equs4v and does not require ~ ax-10 nor ~ ax-12 . It also holds without disjoint variable
condition if we allow more axioms (see ~ equs4 ). Theorem 6.2 of [Quine] p. 40. Theorem ~ equs5
replaces the disjoint variable condition with a distinctor antecedent. Theorem ~ equs45f replaces
the disjoint variable condition on ` x , t ` with the nonfreeness hypothesis of ` t ` in ` ph ` .
(Contributed by NM, 14-Apr-2008.) Revised to use ~ equsexv in place of ~ equsex in order to remove
dependency on ~ ax-13 . (Revised by BJ, 20-Dec-2020.) Revise to remove dependency on ~ df-sb .
(Revised by BJ, 21-Sep-2024.) -/
theorem sbalex {ph : setvar → setvar → wff}
  (t : setvar) : ⊦ wb (wex (λ x3, wa (wceq (cv x3) (cv t)) (ph x3 t))) (wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t))) :=
@impbii (wex (λ x3, wa (wceq (cv x3) (cv t)) (ph x3 t))) (wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t)))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi (wex (λ x3, wa (wceq (cv x3) (cv t)) (ph x3 t))) (wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t))), from
    @exlimi (λ x3, wa (wceq (cv x3) (cv t)) (ph x3 t)) (λ x3, wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t)))
      (@nfa1 (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t)))
      (λ x3, @imp (wceq (cv x3) (cv t)) (ph x3 t) (wal (λ x3, wi (wceq (cv x3) (cv t)) (ph x3 t)))
        (@ax12v2 (λ x3 t, ph x3 t) x3 t)) x3)
  (@equs4v (λ x3, ph x3 t) t)


/-- An equality theorem for substitution. (Contributed by NM, 16-May-1993.) Revise ~ df-sb .
(Revised by BJ, 22-Dec-2020.) -/
theorem sbequ1 {ph : setvar → setvar → wff}
  (x3 t : setvar) : ⊦ wi (wceq (cv x3) (cv t)) (wi (ph x3 t) (wsb (λ x3, ph x3 t) t)) :=
@syl6ibr (wceq (cv x3) (cv t)) (ph x3 t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))) (wsb (λ x3, ph x3 t) t)
  (@alrimdv (wceq (cv x3) (cv t)) (ph x3 t) (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))
    (λ y, @com23 (wceq (cv x3) (cv t)) (wceq (cv y) (cv t)) (ph x3 t) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t)))
      (@syl6 (wceq (cv x3) (cv t)) (wceq (cv y) (cv t)) (wceq (cv x3) (cv y)) (wi (ph x3 t) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))
        (@equeucl x3 y t)
        (@ax12v (λ x3, ph x3 t) x3 y))))
  (@df_sb (λ x3, ph x3 t) t)


/-- An equality theorem for substitution. (Contributed by NM, 16-May-1993.) Revise ~ df-sb .
(Revised by BJ, 22-Dec-2020.) -/
theorem sbequ1_b {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (ph x3) (wsb (λ x3, ph x3) x3)) :=
@syl6ibr (wceq (cv x3) (cv x3)) (ph x3) (wal (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))) (wsb (λ x3, ph x3) x3)
  (@alrimdv (wceq (cv x3) (cv x3)) (ph x3) (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))
    (λ y, @com23 (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3)) (ph x3) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))
      (@syl6 (wceq (cv x3) (cv x3)) (wceq (cv y) (cv x3)) (wceq (cv x3) (cv y)) (wi (ph x3) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))
        (@equeucl_b1 x3 y)
        (@ax12v (λ x3, ph x3) x3 y))))
  (@df_sb_b (λ x3, ph x3) x3)


/-- An equality theorem for substitution. (Contributed by NM, 16-May-1993.) Revise ~ df-sb .
(Revised by BJ, 22-Dec-2020.) (Proof shortened by Wolf Lammen, 3-Feb-2024.) -/
theorem sbequ2 {ph : setvar → setvar → wff}
  (x3 t : setvar) : ⊦ wi (wceq (cv x3) (cv t)) (wi (wsb (λ x3, ph x3 t) t) (ph x3 t)) :=
@syl6com (wsb (λ x3, ph x3 t) t) (wceq (cv x3) (cv t)) (wex (λ y, ph x3 t)) (ph x3 t)
  (@syl2im (wsb (λ x3, ph x3 t) t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))) (wceq (cv x3) (cv t)) (wex (λ y, wa (wceq (cv x3) (cv y)) (wceq (cv t) (cv y)))) (wex (λ y, ph x3 t))
    (@biimpi (wsb (λ x3, ph x3 t) t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t)))))
      (@df_sb (λ x3, ph x3 t) t))
    (@equvinva x3 t)
    (@aleximi (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t)))) (λ y, wa (wceq (cv x3) (cv y)) (wceq (cv t) (cv y))) (λ y, ph x3 t)
      (λ y, @impcomd (wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t)))) (wceq (cv t) (cv y)) (wceq (cv x3) (cv y)) (ph x3 t)
        (@imim12i (wceq (cv t) (cv y)) (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))) (wi (wceq (cv x3) (cv y)) (ph x3 t))
          (@equcomi t y)
          (@sp (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t)) x3)))))
  (@ax5e (ph x3 t))


/-- An equality theorem for substitution. (Contributed by NM, 16-May-1993.) Revise ~ df-sb .
(Revised by BJ, 22-Dec-2020.) (Proof shortened by Wolf Lammen, 3-Feb-2024.) -/
theorem sbequ2_b {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wi (wsb (λ x3, ph x3) x3) (ph x3)) :=
@syl6com (wsb (λ x3, ph x3) x3) (wceq (cv x3) (cv x3)) (wex (λ y, ph x3)) (ph x3)
  (@syl2im (wsb (λ x3, ph x3) x3) (wal (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))))) (wceq (cv x3) (cv x3)) (wex (λ y, wa (wceq (cv x3) (cv y)) (wceq (cv x3) (cv y)))) (wex (λ y, ph x3))
    (@biimpi (wsb (λ x3, ph x3) x3) (wal (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))))
      (@df_sb_b (λ x3, ph x3) x3))
    (@equvinva_b x3)
    (@aleximi (λ y, wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))) (λ y, wa (wceq (cv x3) (cv y)) (wceq (cv x3) (cv y))) (λ y, ph x3)
      (λ y, @impcomd (wi (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))) (wceq (cv x3) (cv y)) (wceq (cv x3) (cv y)) (ph x3)
        (@imim12i (wceq (cv x3) (cv y)) (wceq (cv y) (cv x3)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))) (wi (wceq (cv x3) (cv y)) (ph x3))
          (@equcomi x3 y)
          (@sp (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)) x3)))))
  (@ax5e (ph x3))


/-- An equality theorem for substitution. (Contributed by NM, 14-May-1993.) -/
theorem sbequ12 {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (wsb (λ x3, ph x3 y) y)) :=
@impbid (wceq (cv x3) (cv y)) (ph x3 y) (wsb (λ x3, ph x3 y) y)
  (@sbequ1 (λ x3 y, ph x3 y) x3 y)
  (@sbequ2 (λ x3 y, ph x3 y) x3 y)


/-- An equality theorem for substitution. (Contributed by NM, 14-May-1993.) -/
theorem sbequ12_b {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wb (ph x3) (wsb (λ x3, ph x3) x3)) :=
@impbid (wceq (cv x3) (cv x3)) (ph x3) (wsb (λ x3, ph x3) x3)
  (@sbequ1_b (λ x3, ph x3) x3)
  (@sbequ2_b (λ x3, ph x3) x3)


/-- An equality theorem for substitution. (Contributed by NM, 6-Oct-2004.) (Proof shortened by
Andrew Salmon, 21-Jun-2011.) -/
theorem sbequ12r {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wsb (λ y, ph x3 y) x3) (ph x3 y)) :=
@equcoms (λ y x3, wb (wsb (λ y, ph x3 y) x3) (ph x3 y))
  (λ y x3, @bicomd (wceq (cv y) (cv x3)) (ph x3 y) (wsb (λ y, ph x3 y) x3)
    (@sbequ12 (λ y x3, ph x3 y) y x3)) y x3


/-- An equality theorem for substitution. (Contributed by NM, 6-Oct-2004.) (Proof shortened by
Andrew Salmon, 21-Jun-2011.) -/
theorem sbequ12r_b {ph : setvar → wff}
  (x3 : setvar) : ⊦ wi (wceq (cv x3) (cv x3)) (wb (wsb (λ x3, ph x3) x3) (ph x3)) :=
@equcoms_b (λ x3, wb (wsb (λ x3, ph x3) x3) (ph x3))
  (λ x3, @bicomd (wceq (cv x3) (cv x3)) (ph x3) (wsb (λ x3, ph x3) x3)
    (@sbequ12_b (λ x3, ph x3) x3)) x3


/-- An identity theorem for substitution. Remark 9.1 in [Megill] p. 447 (p. 15 of the preprint).
(Contributed by NM, 26-May-1993.) (Proof shortened by Wolf Lammen, 30-Sep-2018.) -/
theorem sbid {ph : setvar → wff}
  (x3 : setvar) : ⊦ wb (wsb (λ x3, ph x3) x3) (ph x3) :=
@ax_mp (wceq (cv x3) (cv x3)) (wb (wsb (λ x3, ph x3) x3) (ph x3))
  (@equid x3)
  (@sbequ12r_b (λ x3, ph x3) x3)


/-- Generalization of ~ axc16 . Use the latter when sufficient. This proof only requires, on top of
{ ~ ax-1 -- ~ ax-7 }, Theorem ~ ax12v . (Contributed by NM, 15-May-1993.) (Proof shortened by Andrew
Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 18-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 7-Jul-2021.) Shorten ~
axc11rv . (Revised by Wolf Lammen, 11-Oct-2021.) -/
theorem axc16g {ph : setvar → setvar → setvar → wff}
  (x3 y z : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (ph x3 y z) (wal (λ z, ph x3 y z))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (ph x3 y z) (wal (λ z, ph x3 y z))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ z, wceq (cv z) (cv w))) (wi (ph x3 y z) (wal (λ z, ph x3 y z)))
    (@aevlem y w)
    (@syld (wal (λ z, wceq (cv z) (cv w))) (ph x3 y z) (wal (λ z, wi (wceq (cv z) (cv w)) (ph x3 y z))) (wal (λ z, ph x3 y z))
      (@sps (λ z, wceq (cv z) (cv w)) (λ z, wi (ph x3 y z) (wal (λ z, wi (wceq (cv z) (cv w)) (ph x3 y z))))
        (λ z, @ax12v (λ z, ph x3 y z) z w) z)
      (@al2imi (λ z, wceq (cv z) (cv w)) (λ z, wi (wceq (cv z) (cv w)) (ph x3 y z)) (λ z, ph x3 y z)
        (λ z, @pm2_27 (wceq (cv z) (cv w)) (ph x3 y z))))


/-- Generalization of ~ axc16 . Use the latter when sufficient. This proof only requires, on top of
{ ~ ax-1 -- ~ ax-7 }, Theorem ~ ax12v . (Contributed by NM, 15-May-1993.) (Proof shortened by Andrew
Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 18-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 7-Jul-2021.) Shorten ~
axc11rv . (Revised by Wolf Lammen, 11-Oct-2021.) -/
theorem axc16g_b {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (ph x3 y) (wal (λ x3, ph x3 y))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (ph x3 y) (wal (λ x3, ph x3 y))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wceq (cv x3) (cv w))) (wi (ph x3 y) (wal (λ x3, ph x3 y)))
    (@aevlem_b y w)
    (@syld (wal (λ x3, wceq (cv x3) (cv w))) (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 y))) (wal (λ x3, ph x3 y))
      (@sps (λ x3, wceq (cv x3) (cv w)) (λ x3, wi (ph x3 y) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 y))))
        (λ x3, @ax12v (λ x3, ph x3 y) x3 w) x3)
      (@al2imi (λ x3, wceq (cv x3) (cv w)) (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 y)) (λ x3, ph x3 y)
        (λ x3, @pm2_27 (wceq (cv x3) (cv w)) (ph x3 y))))


/-- Generalization of ~ axc16 . Use the latter when sufficient. This proof only requires, on top of
{ ~ ax-1 -- ~ ax-7 }, Theorem ~ ax12v . (Contributed by NM, 15-May-1993.) (Proof shortened by Andrew
Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 18-Feb-2018.) Remove dependency on ~ ax-13 ,
along an idea of BJ. (Revised by Wolf Lammen, 30-Nov-2019.) (Revised by BJ, 7-Jul-2021.) Shorten ~
axc11rv . (Revised by Wolf Lammen, 11-Oct-2021.) -/
theorem axc16g_b1 {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (ph x3 y) (wal (λ y, ph x3 y))) :=
setvar.forget $ λ w : setvar,
  show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (ph x3 y) (wal (λ y, ph x3 y))), from
  @syl (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ y, wceq (cv y) (cv w))) (wi (ph x3 y) (wal (λ y, ph x3 y)))
    (@aevlem_b2 y w)
    (@syld (wal (λ y, wceq (cv y) (cv w))) (ph x3 y) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y))) (wal (λ y, ph x3 y))
      (@sps (λ y, wceq (cv y) (cv w)) (λ y, wi (ph x3 y) (wal (λ y, wi (wceq (cv y) (cv w)) (ph x3 y))))
        (λ y, @ax12v (λ y, ph x3 y) y w) y)
      (@al2imi (λ y, wceq (cv y) (cv w)) (λ y, wi (wceq (cv y) (cv w)) (ph x3 y)) (λ y, ph x3 y)
        (λ y, @pm2_27 (wceq (cv y) (cv w)) (ph x3 y))))


/-- Proof of older axiom ~ ax-c16 . (Contributed by NM, 8-Nov-2006.) (Revised by NM, 22-Sep-2017.)
-/
theorem axc16 {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (ph x3 y) (wal (λ x3, ph x3 y))) :=
@axc16g_b (λ x3 y, ph x3 y) x3 y


/-- Version of ~ axc11 with a disjoint variable condition on ` x ` and ` y ` , which is provable, on
top of { ~ ax-1 -- ~ ax-7 }, from ~ ax12v (contrary to ~ axc11 which seems to require the full ~
ax-12 and ~ ax-13 ). (Contributed by NM, 16-May-2008.) (Revised by BJ, 6-Jul-2021.) (Proof shortened
by Wolf Lammen, 11-Oct-2021.) -/
theorem axc11v {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (wal (λ x3, ph x3 y)) (wal (λ y, ph x3 y))) :=
@spsd (λ x3, wal (λ x3, wceq (cv x3) (cv y))) (λ x3, ph x3 y) (λ x3, wal (λ y, ph x3 y))
  (λ x3, @axc16g_b1 (λ x3 y, ph x3 y) x3 y) x3


/-- Version of ~ axc11r with a disjoint variable condition on ` x ` and ` y ` , which is provable,
on top of { ~ ax-1 -- ~ ax-7 }, from ~ ax12v (contrary to ~ axc11 which seems to require the full ~
ax-12 and ~ ax-13 , and to ~ axc11r which seems to require the full ~ ax-12 ). (Contributed by BJ,
6-Jul-2021.) (Proof shortened by Wolf Lammen, 11-Oct-2021.) -/
theorem axc11rv {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wi (wal (λ y, ph x3 y)) (wal (λ x3, ph x3 y))) :=
@spsd (λ y, wal (λ x3, wceq (cv x3) (cv y))) (λ y, ph x3 y) (λ y, wal (λ x3, ph x3 y))
  (λ y, @axc16 (λ x3 y, ph x3 y) x3 y) y


/-- An equivalence related to implicit substitution. Version of ~ equsal with a disjoint variable
condition, which does not require ~ ax-13 . See ~ equsalvw for a version with two disjoint variable
conditions requiring fewer axioms. See also the dual form ~ equsexv . (Contributed by NM,
2-Jun-1993.) (Revised by BJ, 31-May-2019.) -/
theorem equsalv {ph ps : setvar → setvar → wff}
  (equsalv_nf : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (equsalv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (ps x3 y) :=
@«3bitr4i» (wal (λ x3, wi (wceq (cv x3) (cv y)) (ps x3 y))) (wi (wex (λ x3, wceq (cv x3) (cv y))) (ps x3 y)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (ps x3 y)
  (@«19_23» (λ x3, wceq (cv x3) (cv y)) (λ x3, ps x3 y)
    (equsalv_nf y) x3)
  (@albii (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y)) (λ x3, wi (wceq (cv x3) (cv y)) (ps x3 y))
    (λ x3, @pm5_74i (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
      (equsalv_1 x3 y)))
  (@a1bi (wex (λ x3, wceq (cv x3) (cv y))) (ps x3 y)
    (@ax6ev y))


/-- An equivalence related to implicit substitution. Version of ~ equsex with a disjoint variable
condition, which does not require ~ ax-13 . See ~ equsexvw for a version with two disjoint variable
conditions requiring fewer axioms. See also the dual form ~ equsalv . (Contributed by NM,
5-Aug-1993.) (Revised by BJ, 31-May-2019.) -/
theorem equsexv {ph ps : setvar → setvar → wff}
  (equsalv_nf : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (equsalv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 y))) (ps x3 y) :=
@bitri (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 y))) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (ps x3 y)
  (@sbalex (λ x3 y, ph x3 y) y)
  (@equsalv (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ y, equsalv_nf y)
    (λ x3 y, equsalv_1 x3 y) x3 y)


/-- Substitution has no effect on a nonfree variable. (Contributed by NM, 30-May-2009.) (Revised by
Mario Carneiro, 12-Oct-2016.) (Proof shortened by Wolf Lammen, 3-May-2018.) -/
theorem sbft {ph : setvar → wff} {y : setvar}
  (x3 : setvar) : ⊦ wi (wnf (λ x3, ph x3)) (wb (wsb (λ x3, ph x3) y) (ph x3)) :=
@impbid (wnf (λ x3, ph x3)) (wsb (λ x3, ph x3) y) (ph x3)
  (@syl5ib (wsb (λ x3, ph x3) y) (wex (λ x3, ph x3)) (wnf (λ x3, ph x3)) (ph x3)
    (@spsbe (λ x3, ph x3) y)
    (@«19_9t» (λ x3, ph x3) x3))
  (@syl6 (wnf (λ x3, ph x3)) (ph x3) (wal (λ x3, ph x3)) (wsb (λ x3, ph x3) y)
    (@nf5r (λ x3, ph x3) x3)
    (@stdpc4 (λ x3, ph x3) y))


/-- The setvar ` x ` is not free in ` [ y / x ] ph ` when ` x ` and ` y ` are distinct. (Contributed
by NM, 26-May-1993.) -/
theorem hbs1 {ph : setvar → setvar → wff}
  (y : setvar) : ⊦ wi (wsb (λ x3, ph x3 y) y) (wal (λ x3, wsb (λ x3, ph x3 y) y)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wsb (λ x3, ph x3 y) y) (wal (λ x3, wsb (λ x3, ph x3 y) y)), from
  @nf5ri (λ x3, wsb (λ x3, ph x3 y) y)
    (@nfs1v (λ x3 y, ph x3 y) y) x3


/-- Alternate definition of substitution when variables are disjoint. Similar to Theorem 6.1 of
[Quine] p. 40. The implication "to the right" is ~ sb1v and even needs no disjoint variable
condition, see ~ sb1 . Theorem ~ sb5f replaces the disjoint variable condition with a nonfreeness
hypothesis. (Contributed by NM, 18-Aug-1993.) (Revised by Wolf Lammen, 4-Sep-2023.) -/
theorem sb5 {ph : setvar → setvar → wff}
  (y : setvar) : ⊦ wb (wsb (λ x3, ph x3 y) y) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 y))) :=
@bitr4i (wsb (λ x3, ph x3 y) y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 y)))
  (@sb6 (λ x3 y, ph x3 y) y)
  (@sbalex (λ x3 y, ph x3 y) y)


/-- Equivalence for double substitution. (Contributed by NM, 3-Feb-2005.) -/
theorem «2sb5» {ph : setvar → setvar → setvar → setvar → wff}
  (z w : setvar) : ⊦ wb (wsb (λ x3, wsb (λ y, ph x3 y z w) w) z) (wex (λ x3, wex (λ y, wa (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w)))) :=
@bitri (wsb (λ x3, wsb (λ y, ph x3 y z w) w) z) (wex (λ x3, wa (wceq (cv x3) (cv z)) (wsb (λ y, ph x3 y z w) w))) (wex (λ x3, wex (λ y, wa (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w))))
  (@sb5 (λ x3 z, wsb (λ y, ph x3 y z w) w) z)
  (@exbii (λ x3, wa (wceq (cv x3) (cv z)) (wsb (λ y, ph x3 y z w) w)) (λ x3, wex (λ y, wa (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w)))
    (λ x3, @«3bitr4ri» (wex (λ y, wa (wceq (cv x3) (cv z)) (wa (wceq (cv y) (cv w)) (ph x3 y z w)))) (wa (wceq (cv x3) (cv z)) (wex (λ y, wa (wceq (cv y) (cv w)) (ph x3 y z w)))) (wex (λ y, wa (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w))) (wa (wceq (cv x3) (cv z)) (wsb (λ y, ph x3 y z w) w))
      (@«19_42v» (wceq (cv x3) (cv z)) (λ y, wa (wceq (cv y) (cv w)) (ph x3 y z w)))
      (@exbii (λ y, wa (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w)) (λ y, wa (wceq (cv x3) (cv z)) (wa (wceq (cv y) (cv w)) (ph x3 y z w)))
        (λ y, @anass (wceq (cv x3) (cv z)) (wceq (cv y) (cv w)) (ph x3 y z w)))
      (@anbi2i (wsb (λ y, ph x3 y z w) w) (wex (λ y, wa (wceq (cv y) (cv w)) (ph x3 y z w))) (wceq (cv x3) (cv z))
        (@sb5 (λ y w, ph x3 y z w) w))))


/-- An alternate definition of proper substitution ~ df-sb . By introducing a dummy variable ` y `
in the definiens, we are able to eliminate any distinct variable restrictions among the variables `
t ` , ` x ` , and ` ph ` of the definiendum. No distinct variable conflicts arise because ` y `
effectively insulates ` t ` from ` x ` . To achieve this, we use a chain of two substitutions in the
form of ~ sb5 , first ` y ` for ` x ` then ` t ` for ` y ` . Compare Definition 2.1'' of [Quine] p.
17, which is obtained from this theorem by applying ~ df-clab . Theorem ~ sb7h provides a version
where ` ph ` and ` y ` don't have to be distinct. (Contributed by NM, 28-Jan-2004.) Revise ~ df-sb .
(Revised by BJ, 25-Dec-2020.) (Proof shortened by Wolf Lammen, 3-Sep-2023.) -/
theorem dfsb7 {ph : setvar → setvar → wff}
  (t : setvar) : ⊦ wb (wsb (λ x3, ph x3 t) t) (wex (λ y, wa (wceq (cv y) (cv t)) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t))))) :=
@«3bitr4ri» (wex (λ y, wa (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))) (wex (λ y, wa (wceq (cv y) (cv t)) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t))))) (wsb (λ x3, ph x3 t) t)
  (@sbalex (λ y t, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))) t)
  (@exbii (λ y, wa (wceq (cv y) (cv t)) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t)))) (λ y, wa (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))))
    (λ y, @anbi2i (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t))) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 t))) (wceq (cv y) (cv t))
      (@sbalex (λ x3 y, ph x3 t) y)))
  (@df_sb (λ x3, ph x3 t) t)


/-- Negation inside and outside of substitution are equivalent. (Contributed by NM, 14-May-1993.)
(Proof shortened by Wolf Lammen, 30-Apr-2018.) Revise ~ df-sb . (Revised by BJ, 25-Dec-2020.) -/
theorem sbn {ph : setvar → setvar → wff}
  (t : setvar) : ⊦ wb (wsb (λ x3, wn (ph x3 t)) t) (wn (wsb (λ x3, ph x3 t) t)) :=
@«3bitri» (wsb (λ x3, wn (ph x3 t)) t) (wal (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (wn (ph x3 t)))))) (wal (λ y, wi (wceq (cv y) (cv t)) (wn (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t)))))) (wn (wsb (λ x3, ph x3 t) t))
  (@df_sb (λ x3, wn (ph x3 t)) t)
  (@albii (λ y, wi (wceq (cv y) (cv t)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (wn (ph x3 t))))) (λ y, wi (wceq (cv y) (cv t)) (wn (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t)))))
    (λ y, @imbi2i (wal (λ x3, wi (wceq (cv x3) (cv y)) (wn (ph x3 t)))) (wn (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t)))) (wceq (cv y) (cv t))
      (@alinexa (λ x3, wceq (cv x3) (cv y)) (λ x3, ph x3 t))))
  (@xchbinxr (wal (λ y, wi (wceq (cv y) (cv t)) (wn (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t)))))) (wex (λ y, wa (wceq (cv y) (cv t)) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t))))) (wsb (λ x3, ph x3 t) t)
    (@alinexa (λ y, wceq (cv y) (cv t)) (λ y, wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3 t))))
    (@dfsb7 (λ x3 t, ph x3 t) t))


/-- Move existential quantifier in and out of substitution. (Contributed by NM, 27-Sep-2003.) -/
theorem sbex {ph : setvar → setvar → setvar → wff}
  (z : setvar) : ⊦ wb (wsb (λ y, wex (λ x3, ph x3 y z)) z) (wex (λ x3, wsb (λ y, ph x3 y z) z)) :=
@«3bitr4i» (wsb (λ y, wn (wal (λ x3, wn (ph x3 y z)))) z) (wn (wal (λ x3, wn (wsb (λ y, ph x3 y z) z)))) (wsb (λ y, wex (λ x3, ph x3 y z)) z) (wex (λ x3, wsb (λ y, ph x3 y z) z))
  (@xchbinx (wsb (λ y, wn (wal (λ x3, wn (ph x3 y z)))) z) (wsb (λ y, wal (λ x3, wn (ph x3 y z))) z) (wal (λ x3, wn (wsb (λ y, ph x3 y z) z)))
    (@sbn (λ y z, wal (λ x3, wn (ph x3 y z))) z)
    (setvar.forget $ λ y : setvar,
      show ⊦ wb (wsb (λ y, wal (λ x3, wn (ph x3 y z))) z) (wal (λ x3, wn (wsb (λ y, ph x3 y z) z))), from
      @sbalv (λ y z x3, wn (ph x3 y z)) (λ y z x3, wn (wsb (λ y, ph x3 y z) z))
        (λ y z x3, @sbn (λ y z, ph x3 y z) z) y z))
  (@sbbii (λ y, wex (λ x3, ph x3 y z)) (λ y, wn (wal (λ x3, wn (ph x3 y z)))) z
    (λ y, @df_ex (λ x3, ph x3 y z)))
  (@df_ex (λ x3, wsb (λ y, ph x3 y z) z))


/-- Alternate definition of ~ df-nf . (Contributed by Mario Carneiro, 11-Aug-2016.) ~ df-nf changed.
(Revised by Wolf Lammen, 11-Sep-2021.) -/
theorem nf5 {ph : setvar → wff} :
  ⊦ wb (wnf (λ x3, ph x3)) (wal (λ x3, wi (ph x3) (wal (λ x3, ph x3)))) :=
@bitr4i (wnf (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3))) (wal (λ x3, wi (ph x3) (wal (λ x3, ph x3))))
  (@df_nf (λ x3, ph x3))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wb (wal (λ x3, wi (ph x3) (wal (λ x3, ph x3)))) (wi (wex (λ x3, ph x3)) (wal (λ x3, ph x3))), from
    @«19_23» (λ x3, ph x3) (λ x3, wal (λ x3, ph x3))
      (@nfa1 (λ x3, ph x3)) x3)


/-- Introduction of implication into substitution. (Contributed by NM, 14-May-1993.) -/
theorem sbi2 {ph ps : setvar → setvar → wff}
  (y : setvar) : ⊦ wi (wi (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y)) (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) :=
@ja (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y) (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y)
  (@sylbir (wn (wsb (λ x3, ph x3 y) y)) (wsb (λ x3, wn (ph x3 y)) y) (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y)
    (@sbn (λ x3 y, ph x3 y) y)
    (@sbimi (λ x3, wn (ph x3 y)) (λ x3, wi (ph x3 y) (ps x3 y)) y
      (λ x3, @pm2_21 (ph x3 y) (ps x3 y))))
  (@sbimi (λ x3, ps x3 y) (λ x3, wi (ph x3 y) (ps x3 y)) y
    (λ x3, @ax_1 (ps x3 y) (ph x3 y)))


/-- Implication inside and outside of a substitution are equivalent. (Contributed by NM,
14-May-1993.) -/
theorem sbim {ph ps : setvar → setvar → wff}
  (y : setvar) : ⊦ wb (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wi (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y)) :=
@impbii (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wi (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y))
  (@sbi1 (λ x3, ph x3 y) (λ x3, ps x3 y) y)
  (@sbi2 (λ x3 y, ph x3 y) (λ x3 y, ps x3 y) y)


/-- Substitution in an implication with a variable not free in the antecedent affects only the
consequent. Version of ~ sbrim not depending on ~ ax-10 , but with disjoint variables. (Contributed
by Wolf Lammen, 28-Jan-2024.) -/
theorem sbrimv {ph ps : setvar → setvar → wff}
  (sbrim_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y))
  (x3 y : setvar) : ⊦ wb (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wi (ph x3 y) (wsb (λ x3, ps x3 y) y)) :=
@sbrimvlem (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
  (λ x3 y, @«19_21» (λ x3, ph x3 y) (λ x3, wi (wceq (cv x3) (cv y)) (ps x3 y))
    (sbrim_1 y) x3) x3 y


/-- Disjunction inside and outside of a substitution are equivalent. (Contributed by NM,
29-Sep-2002.) -/
theorem sbor {ph ps : setvar → setvar → wff}
  (y : setvar) : ⊦ wb (wsb (λ x3, wo (ph x3 y) (ps x3 y)) y) (wo (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y)) :=
@«3bitr4i» (wsb (λ x3, wi (wn (ph x3 y)) (ps x3 y)) y) (wi (wn (wsb (λ x3, ph x3 y) y)) (wsb (λ x3, ps x3 y) y)) (wsb (λ x3, wo (ph x3 y) (ps x3 y)) y) (wo (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y))
  (@bitri (wsb (λ x3, wi (wn (ph x3 y)) (ps x3 y)) y) (wi (wsb (λ x3, wn (ph x3 y)) y) (wsb (λ x3, ps x3 y) y)) (wi (wn (wsb (λ x3, ph x3 y) y)) (wsb (λ x3, ps x3 y) y))
    (@sbim (λ x3 y, wn (ph x3 y)) (λ x3 y, ps x3 y) y)
    (@imbi1i (wsb (λ x3, wn (ph x3 y)) y) (wn (wsb (λ x3, ph x3 y) y)) (wsb (λ x3, ps x3 y) y)
      (@sbn (λ x3 y, ph x3 y) y)))
  (@sbbii (λ x3, wo (ph x3 y) (ps x3 y)) (λ x3, wi (wn (ph x3 y)) (ps x3 y)) y
    (λ x3, @df_or (ph x3 y) (ps x3 y)))
  (@df_or (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y))


/-- Equivalence inside and outside of a substitution are equivalent. (Contributed by NM,
14-May-1993.) -/
theorem sbbi {ph ps : setvar → setvar → wff}
  (y : setvar) : ⊦ wb (wsb (λ x3, wb (ph x3 y) (ps x3 y)) y) (wb (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y)) :=
@bitri (wsb (λ x3, wb (ph x3 y) (ps x3 y)) y) (wsb (λ x3, wa (wi (ph x3 y) (ps x3 y)) (wi (ps x3 y) (ph x3 y))) y) (wb (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y))
  (@sbbii (λ x3, wb (ph x3 y) (ps x3 y)) (λ x3, wa (wi (ph x3 y) (ps x3 y)) (wi (ps x3 y) (ph x3 y))) y
    (λ x3, @dfbi2 (ph x3 y) (ps x3 y)))
  (@«3bitr4i» (wa (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wsb (λ x3, wi (ps x3 y) (ph x3 y)) y)) (wa (wi (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y)) (wi (wsb (λ x3, ps x3 y) y) (wsb (λ x3, ph x3 y) y))) (wsb (λ x3, wa (wi (ph x3 y) (ps x3 y)) (wi (ps x3 y) (ph x3 y))) y) (wb (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y))
    (@anbi12i (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wi (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y)) (wsb (λ x3, wi (ps x3 y) (ph x3 y)) y) (wi (wsb (λ x3, ps x3 y) y) (wsb (λ x3, ph x3 y) y))
      (@sbim (λ x3 y, ph x3 y) (λ x3 y, ps x3 y) y)
      (@sbim (λ x3 y, ps x3 y) (λ x3 y, ph x3 y) y))
    (@sban (λ x3, wi (ph x3 y) (ps x3 y)) (λ x3, wi (ps x3 y) (ph x3 y)) y)
    (@dfbi2 (wsb (λ x3, ph x3 y) y) (wsb (λ x3, ps x3 y) y)))


/-- Conversion of implicit substitution to explicit substitution. Version of ~ sbie with a disjoint
variable condition, not requiring ~ ax-13 . See ~ sbievw for a version with a disjoint variable
condition requiring fewer axioms. (Contributed by NM, 30-Jun-1994.) (Revised by Wolf Lammen,
18-Jan-2023.) Remove dependence on ~ ax-10 and shorten proof. (Revised by BJ, 18-Jul-2023.) -/
theorem sbiev {ph ps : setvar → setvar → wff}
  (sbiev_1 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (sbiev_2 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wsb (λ x3, ph x3 y) y) (ps x3 y) :=
@bitri (wsb (λ x3, ph x3 y) y) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3 y))) (ps x3 y)
  (@sb6 (λ x3 y, ph x3 y) y)
  (@equsalv (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ y, sbiev_1 y)
    (λ x3 y, sbiev_2 x3 y) x3 y)


/-- Conversion of implicit substitution to explicit substitution (deduction version of ~ sbiev ).
Version of ~ sbied with a disjoint variable condition, requiring fewer axioms. (Contributed by NM,
30-Jun-1994.) (Revised by Gino Giotto, 10-Jan-2024.) Avoid ~ ax-10 . (Revised by Wolf Lammen,
28-Jan-2024.) -/
theorem sbiedw {ph ps ch : setvar → setvar → wff}
  (sbiedw_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y))
  (sbiedw_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ch x3 y)))
  (sbiedw_3 : ∀ x3 y, ⊦ wi (ph x3 y) (wi (wceq (cv x3) (cv y)) (wb (ps x3 y) (ch x3 y))))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wb (wsb (λ x3, ps x3 y) y) (ch x3 y)) :=
@pm5_74ri (ph x3 y) (wsb (λ x3, ps x3 y) y) (ch x3 y)
  (@bitr3i (wi (ph x3 y) (wsb (λ x3, ps x3 y) y)) (wsb (λ x3, wi (ph x3 y) (ps x3 y)) y) (wi (ph x3 y) (ch x3 y))
    (@sbrimv (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
      (λ y, sbiedw_1 y) x3 y)
    (@sbiev (λ x3 y, wi (ph x3 y) (ps x3 y)) (λ x3 y, wi (ph x3 y) (ch x3 y))
      (λ y, @nfim1 (λ x3, ph x3 y) (λ x3, ch x3 y)
        (sbiedw_1 y)
        (λ x3, sbiedw_2 x3 y))
      (λ x3 y, @pm5_74d (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y) (ch x3 y)
        (@com12 (ph x3 y) (wceq (cv x3) (cv y)) (wb (ps x3 y) (ch x3 y))
          (sbiedw_3 x3 y))) x3 y))


/-- Inference version of ~ axc4 . (Contributed by NM, 3-Jan-1993.) -/
theorem axc4i {ph ps : setvar → wff}
  (axc4i_1 : ∀ x3, ⊦ wi (wal (λ x3, ph x3)) (ps x3)) :
  ⊦ wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wal (λ x3, ph x3)) (wal (λ x3, ps x3)), from
  @alrimi (λ x3, wal (λ x3, ph x3)) (λ x3, ps x3)
    (@nfa1 (λ x3, ph x3))
    (λ x3, axc4i_1 x3) x3


/-- If ` x ` is not free in ` ph ` , it is not free in ` A. y ph ` . (Contributed by Mario Carneiro,
11-Aug-2016.) -/
theorem nfal {ph : setvar → setvar → wff}
  (nfal_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y)) :
  ⊦ wnf (λ x3, wal (λ y, ph x3 y)) :=
@nf5i (λ x3, wal (λ y, ph x3 y))
  (λ x3, @hbal (λ x3 y, ph x3 y)
    (λ x3 y, @nf5ri (λ x3, ph x3 y)
      (nfal_1 y) x3) x3)


/-- If ` x ` is not free in ` ph ` , it is not free in ` E. y ph ` . (Contributed by Mario Carneiro,
11-Aug-2016.) (Proof shortened by Wolf Lammen, 30-Dec-2017.) Reduce symbol count in ~ nfex , ~ hbex
. (Revised by Wolf Lammen, 16-Oct-2021.) -/
theorem nfex {ph : setvar → setvar → wff}
  (nfex_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y)) :
  ⊦ wnf (λ x3, wex (λ y, ph x3 y)) :=
@nfxfr (λ x3, wex (λ y, ph x3 y)) (λ x3, wn (wal (λ y, wn (ph x3 y))))
  (λ x3, @df_ex (λ y, ph x3 y))
  (@nfn (λ x3, wal (λ y, wn (ph x3 y)))
    (@nfal (λ x3 y, wn (ph x3 y))
      (λ y, @nfn (λ x3, ph x3 y)
        (nfex_1 y))))


/-- Theorem 19.12 of [Margaris] p. 89. Assuming the converse is a mistake sometimes made by
beginners! But sometimes the converse does hold, as in ~ 19.12vv and ~ r19.12sn . (Contributed by
NM, 12-Mar-1993.) (Proof shortened by Wolf Lammen, 3-Jan-2018.) -/
theorem «19_12» {ph : setvar → setvar → wff} :
  ⊦ wi (wex (λ x3, wal (λ y, ph x3 y))) (wal (λ y, wex (λ x3, ph x3 y))) :=
setvar.forget $ λ y : setvar,
  show ⊦ wi (wex (λ x3, wal (λ y, ph x3 y))) (wal (λ y, wex (λ x3, ph x3 y))), from
  @alrimi (λ y, wex (λ x3, wal (λ y, ph x3 y))) (λ y, wex (λ x3, ph x3 y))
    (@nfex (λ y x3, wal (λ y, ph x3 y))
      (λ x3, @nfa1 (λ y, ph x3 y)))
    (λ y, @eximi (λ x3, wal (λ y, ph x3 y)) (λ x3, ph x3 y)
      (λ x3, @sp (λ y, ph x3 y) y)) y


/-- Deduction form of ~ nfal . (Contributed by Mario Carneiro, 24-Sep-2016.) (Proof shortened by
Wolf Lammen, 16-Oct-2021.) -/
theorem nfald {ph ps : setvar → setvar → wff}
  (nfald_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (nfald_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ps x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnf (λ x3, wal (λ y, ps x3 y))) :=
@nfd (λ x3, ph x3 y) (λ x3, wal (λ y, ps x3 y))
  (λ x3, @syl56 (wex (λ x3, wal (λ y, ps x3 y))) (wal (λ y, wex (λ x3, ps x3 y))) (ph x3 y) (wal (λ y, wal (λ x3, ps x3 y))) (wal (λ x3, wal (λ y, ps x3 y)))
    (@«19_12» (λ x3 y, ps x3 y))
    (@alimd (λ y, ph x3 y) (λ y, wex (λ x3, ps x3 y)) (λ y, wal (λ x3, ps x3 y))
      (nfald_1 x3)
      (λ y, @nfrd (λ x3, ph x3 y) (λ x3, ps x3 y)
        (λ x3, nfald_2 x3 y) x3) y)
    (@ax_11 (λ y x3, ps x3 y))) x3


/-- If ` x ` is not free in ` ps ` , it is not free in ` E. y ps ` . (Contributed by Mario Carneiro,
24-Sep-2016.) -/
theorem nfexd {ph ps : setvar → setvar → wff}
  (nfald_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (nfald_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ps x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnf (λ x3, wex (λ y, ps x3 y))) :=
@nfxfrd (λ x3, wex (λ y, ps x3 y)) (λ x3, wn (wal (λ y, wn (ps x3 y)))) (λ x3, ph x3 y)
  (λ x3, @df_ex (λ y, ps x3 y))
  (λ x3, @nfnd (λ x3, ph x3 y) (λ x3, wal (λ y, wn (ps x3 y)))
    (λ x3, @nfald (λ x3 y, ph x3 y) (λ x3 y, wn (ps x3 y))
      (λ x3, nfald_1 x3)
      (λ x3 y, @nfnd (λ x3, ph x3 y) (λ x3, ps x3 y)
        (λ x3, nfald_2 x3 y) x3) x3 y) x3) x3


/-- If ` z ` is not free in ` ph ` , it is not free in ` [ y / x ] ph ` when ` z ` is distinct from
` x ` and ` y ` . Version of ~ nfsb requiring more disjoint variables, but fewer axioms.
(Contributed by Mario Carneiro, 11-Aug-2016.) (Revised by Wolf Lammen, 7-Feb-2023.) Remove disjoint
variable condition on ` x , y ` . (Revised by Steven Nguyen, 13-Aug-2023.) -/
theorem nfsbv {ph : setvar → setvar → wff} {y : setvar}
  (nfsbv_nf : ∀ x3, ⊦ wnf (λ z, ph x3 z)) :
  ⊦ wnf (λ z, wsb (λ x3, ph x3 z) y) :=
@nfxfr (λ z, wsb (λ x3, ph x3 z) y) (λ z, wal (λ w, wi (wceq (cv w) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))))
  (λ z, @df_sb (λ x3, ph x3 z) y)
  (@nfal (λ z w, wi (wceq (cv w) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z))))
    (λ w, @nfim (λ z, wceq (cv w) (cv y)) (λ z, wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 z)))
      (@nfv (wceq (cv w) (cv y)))
      (@nfal (λ z x3, wi (wceq (cv x3) (cv w)) (ph x3 z))
        (λ x3, @nfim (λ z, wceq (cv x3) (cv w)) (λ z, ph x3 z)
          (@nfv (wceq (cv x3) (cv w)))
          (nfsbv_nf x3)))))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbv3 with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM, 5-Aug-1993.)
(Revised by BJ, 31-May-2019.) -/
theorem cbv3v {ph ps : setvar → setvar → wff}
  (cbv3v_nf1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbv3v_nf2 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (cbv3v_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wi (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y)) :=
@alrimih (λ y, wal (λ x3, ph x3 y)) (λ y, ps x3 y)
  (λ y, @hbal (λ y x3, ph x3 y)
    (λ y x3, @nf5ri (λ y, ph x3 y)
      (cbv3v_nf1 x3) y) y)
  (λ y, @spimfv (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ y, cbv3v_nf2 y)
    (λ x3 y, cbv3v_1 x3 y) x3 y) y


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbv1 with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM, 5-Aug-1993.)
(Revised by BJ, 16-Jun-2019.) -/
theorem cbv1v {ph ps ch : setvar → setvar → wff}
  (cbv1v_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y))
  (cbv1v_2 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbv1v_3 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ y, ps x3 y)))
  (cbv1v_4 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ch x3 y)))
  (cbv1v_5 : ∀ x3 y, ⊦ wi (ph x3 y) (wi (wceq (cv x3) (cv y)) (wi (ps x3 y) (ch x3 y))))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wi (wal (λ x3, ps x3 y)) (wal (λ y, ch x3 y))) :=
@pm2_86i (ph x3 y) (wal (λ x3, ps x3 y)) (wal (λ y, ch x3 y))
  (@«3imtr3i» (wal (λ x3, wi (ph x3 y) (ps x3 y))) (wal (λ y, wi (ph x3 y) (ch x3 y))) (wi (ph x3 y) (wal (λ x3, ps x3 y))) (wi (ph x3 y) (wal (λ y, ch x3 y)))
    (@cbv3v (λ x3 y, wi (ph x3 y) (ps x3 y)) (λ x3 y, wi (ph x3 y) (ch x3 y))
      (λ x3, @nfim1 (λ y, ph x3 y) (λ y, ps x3 y)
        (cbv1v_2 x3)
        (λ y, cbv1v_3 x3 y))
      (λ y, @nfim1 (λ x3, ph x3 y) (λ x3, ch x3 y)
        (cbv1v_1 y)
        (λ x3, cbv1v_4 x3 y))
      (λ x3 y, @a2d (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y) (ch x3 y)
        (@com12 (ph x3 y) (wceq (cv x3) (cv y)) (wi (ps x3 y) (ch x3 y))
          (cbv1v_5 x3 y))) x3 y)
    (@«19_21» (λ x3, ph x3 y) (λ x3, ps x3 y)
      (cbv1v_1 y) x3)
    (@«19_21» (λ y, ph x3 y) (λ y, ch x3 y)
      (cbv1v_2 x3) y))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbv2 with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM, 5-Aug-1993.)
(Revised by Gino Giotto, 10-Jan-2024.) -/
theorem cbv2w {ph ps ch : setvar → setvar → wff}
  (cbv2w_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y))
  (cbv2w_2 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbv2w_3 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ y, ps x3 y)))
  (cbv2w_4 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ch x3 y)))
  (cbv2w_5 : ∀ x3 y, ⊦ wi (ph x3 y) (wi (wceq (cv x3) (cv y)) (wb (ps x3 y) (ch x3 y))))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wb (wal (λ x3, ps x3 y)) (wal (λ y, ch x3 y))) :=
@impbid (ph x3 y) (wal (λ x3, ps x3 y)) (wal (λ y, ch x3 y))
  (@cbv1v (λ x3 y, ph x3 y) (λ x3 y, ps x3 y) (λ x3 y, ch x3 y)
    (λ y, cbv2w_1 y)
    (λ x3, cbv2w_2 x3)
    (λ x3 y, cbv2w_3 x3 y)
    (λ x3 y, cbv2w_4 x3 y)
    (λ x3 y, @syl6 (ph x3 y) (wceq (cv x3) (cv y)) (wb (ps x3 y) (ch x3 y)) (wi (ps x3 y) (ch x3 y))
      (cbv2w_5 x3 y)
      (@biimp (ps x3 y) (ch x3 y))) x3 y)
  (@cbv1v (λ y x3, ph x3 y) (λ y x3, ch x3 y) (λ y x3, ps x3 y)
    (λ x3, cbv2w_2 x3)
    (λ y, cbv2w_1 y)
    (λ y x3, cbv2w_4 x3 y)
    (λ y x3, cbv2w_3 x3 y)
    (λ y x3, @syl56 (wceq (cv y) (cv x3)) (wceq (cv x3) (cv y)) (ph x3 y) (wb (ps x3 y) (ch x3 y)) (wi (ch x3 y) (ps x3 y))
      (@equcomi y x3)
      (cbv2w_5 x3 y)
      (@biimpr (ps x3 y) (ch x3 y))) y x3)


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbval with a
disjoint variable condition, which does not require ~ ax-13 . See ~ cbvalvw for a version with two
disjoint variable conditions, requiring fewer axioms, and ~ cbvalv for another variant. (Contributed
by NM, 13-May-1993.) (Revised by BJ, 31-May-2019.) -/
theorem cbvalv1 {ph ps : setvar → setvar → wff}
  (cbvalv1_nf1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbvalv1_nf2 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (cbvalv1_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y)) :=
@impbii (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y))
  (@cbv3v (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
    (λ x3, cbvalv1_nf1 x3)
    (λ y, cbvalv1_nf2 y)
    (λ x3 y, @biimpd (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
      (cbvalv1_1 x3 y)) x3 y)
  (@cbv3v (λ y x3, ps x3 y) (λ y x3, ph x3 y)
    (λ y, cbvalv1_nf2 y)
    (λ x3, cbvalv1_nf1 x3)
    (λ y x3, @equcoms (λ x3 y, wi (ps x3 y) (ph x3 y))
      (λ x3 y, @biimprd (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
        (cbvalv1_1 x3 y)) x3 y) y x3)


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbvex with a
disjoint variable condition, which does not require ~ ax-13 . See ~ cbvexvw for a version with two
disjoint variable conditions, requiring fewer axioms, and ~ cbvexv for another variant. (Contributed
by NM, 21-Jun-1993.) (Revised by BJ, 31-May-2019.) -/
theorem cbvexv1 {ph ps : setvar → setvar → wff}
  (cbvalv1_nf1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbvalv1_nf2 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (cbvalv1_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wex (λ x3, ph x3 y)) (wex (λ y, ps x3 y)) :=
@«3bitr4i» (wn (wal (λ x3, wn (ph x3 y)))) (wn (wal (λ y, wn (ps x3 y)))) (wex (λ x3, ph x3 y)) (wex (λ y, ps x3 y))
  (@notbii (wal (λ x3, wn (ph x3 y))) (wal (λ y, wn (ps x3 y)))
    (@cbvalv1 (λ x3 y, wn (ph x3 y)) (λ x3 y, wn (ps x3 y))
      (λ x3, @nfn (λ y, ph x3 y)
        (cbvalv1_nf1 x3))
      (λ y, @nfn (λ x3, ps x3 y)
        (cbvalv1_nf2 y))
      (λ x3 y, @notbid (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y)
        (cbvalv1_1 x3 y)) x3 y))
  (@df_ex (λ x3, ph x3 y))
  (@df_ex (λ y, ps x3 y))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbval2 with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM, 22-Dec-2003.)
(Revised by BJ, 16-Jun-2019.) (Proof shortened by Gino Giotto, 10-Jan-2024.) -/
theorem cbval2v {ph ps : setvar → setvar → setvar → setvar → wff}
  (cbval2v_1 : ∀ x3 y w, ⊦ wnf (λ z, ph x3 y z w))
  (cbval2v_2 : ∀ x3 y z, ⊦ wnf (λ w, ph x3 y z w))
  (cbval2v_3 : ∀ y z w, ⊦ wnf (λ x3, ps x3 y z w))
  (cbval2v_4 : ∀ x3 z w, ⊦ wnf (λ y, ps x3 y z w))
  (cbval2v_5 : ∀ x3 y z w, ⊦ wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (wb (ph x3 y z w) (ps x3 y z w)))
  (x3 y z w : setvar) : ⊦ wb (wal (λ x3, wal (λ y, ph x3 y z w))) (wal (λ z, wal (λ w, ps x3 y z w))) :=
@cbvalv1 (λ x3 z, wal (λ y, ph x3 y z w)) (λ x3 z, wal (λ w, ps x3 y z w))
  (λ x3, @nfal (λ z y, ph x3 y z w)
    (λ y, cbval2v_1 x3 y w))
  (λ z, @nfal (λ x3 w, ps x3 y z w)
    (λ w, cbval2v_3 y z w))
  (λ x3 z, @cbv2w (λ y w, wceq (cv x3) (cv z)) (λ y w, ph x3 y z w) (λ y w, ps x3 y z w)
    (λ w, @nfv (wceq (cv x3) (cv z)))
    (λ y, @nfv (wceq (cv x3) (cv z)))
    (λ y w, @a1i (wnf (λ w, ph x3 y z w)) (wceq (cv x3) (cv z))
      (cbval2v_2 x3 y z))
    (λ y w, @a1i (wnf (λ y, ps x3 y z w)) (wceq (cv x3) (cv z))
      (cbval2v_4 x3 z w))
    (λ y w, @ex (wceq (cv x3) (cv z)) (wceq (cv y) (cv w)) (wb (ph x3 y z w) (ps x3 y z w))
      (cbval2v_5 x3 y z w)) y w) x3 z


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbvex2 with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM, 14-Sep-2003.)
(Revised by BJ, 16-Jun-2019.) -/
theorem cbvex2v {ph ps : setvar → setvar → setvar → setvar → wff}
  (cbval2v_1 : ∀ x3 y w, ⊦ wnf (λ z, ph x3 y z w))
  (cbval2v_2 : ∀ x3 y z, ⊦ wnf (λ w, ph x3 y z w))
  (cbval2v_3 : ∀ y z w, ⊦ wnf (λ x3, ps x3 y z w))
  (cbval2v_4 : ∀ x3 z w, ⊦ wnf (λ y, ps x3 y z w))
  (cbval2v_5 : ∀ x3 y z w, ⊦ wi (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (wb (ph x3 y z w) (ps x3 y z w)))
  (x3 y z w : setvar) : ⊦ wb (wex (λ x3, wex (λ y, ph x3 y z w))) (wex (λ z, wex (λ w, ps x3 y z w))) :=
@«3bitr4i» (wn (wal (λ x3, wal (λ y, wn (ph x3 y z w))))) (wn (wal (λ z, wal (λ w, wn (ps x3 y z w))))) (wex (λ x3, wex (λ y, ph x3 y z w))) (wex (λ z, wex (λ w, ps x3 y z w)))
  (@notbii (wal (λ x3, wal (λ y, wn (ph x3 y z w)))) (wal (λ z, wal (λ w, wn (ps x3 y z w))))
    (@cbval2v (λ x3 y z w, wn (ph x3 y z w)) (λ x3 y z w, wn (ps x3 y z w))
      (λ x3 y w, @nfn (λ z, ph x3 y z w)
        (cbval2v_1 x3 y w))
      (λ x3 y z, @nfn (λ w, ph x3 y z w)
        (cbval2v_2 x3 y z))
      (λ y z w, @nfn (λ x3, ps x3 y z w)
        (cbval2v_3 y z w))
      (λ x3 z w, @nfn (λ y, ps x3 y z w)
        (cbval2v_4 x3 z w))
      (λ x3 y z w, @notbid (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv w))) (ph x3 y z w) (ps x3 y z w)
        (cbval2v_5 x3 y z w)) x3 y z w))
  (@«2exnaln» (λ x3 y, ph x3 y z w))
  (@«2exnaln» (λ z w, ps x3 y z w))


/-- Rearrange existential quantifiers. (Contributed by NM, 27-Oct-2010.) (Revised by Mario Carneiro,
6-Oct-2016.) -/
theorem eean {ph ps : setvar → setvar → wff}
  (eean_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (eean_2 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (x3 y : setvar) : ⊦ wb (wex (λ x3, wex (λ y, wa (ph x3 y) (ps x3 y)))) (wa (wex (λ x3, ph x3 y)) (wex (λ y, ps x3 y))) :=
@bitri (wex (λ x3, wex (λ y, wa (ph x3 y) (ps x3 y)))) (wex (λ x3, wa (ph x3 y) (wex (λ y, ps x3 y)))) (wa (wex (λ x3, ph x3 y)) (wex (λ y, ps x3 y)))
  (@exbii (λ x3, wex (λ y, wa (ph x3 y) (ps x3 y))) (λ x3, wa (ph x3 y) (wex (λ y, ps x3 y)))
    (λ x3, @«19_42» (λ y, ph x3 y) (λ y, ps x3 y)
      (eean_1 x3) y))
  (@«19_41» (λ x3, ph x3 y) (λ x3, wex (λ y, ps x3 y))
    (@nfex (λ x3 y, ps x3 y)
      (λ y, eean_2 y)) x3)


/-- Distribute a pair of existential quantifiers over a conjunction. Combination of ~ 19.41v and ~
19.42v . For a version requiring fewer axioms but with additional disjoint variable conditions, see
~ exdistrv . (Contributed by NM, 26-Jul-1995.) -/
theorem eeanv {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wa (wex (λ x3, ph x3)) (wex (λ y, ps y))) :=
setvar.forget $ λ x3 : setvar,
  setvar.forget $ λ y : setvar,
  show ⊦ wb (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wa (wex (λ x3, ph x3)) (wex (λ y, ps y))), from
  @eean (λ x3 y, ph x3) (λ x3 y, ps y)
    (λ x3, @nfv (ph x3))
    (λ y, @nfv (ps y)) x3 y


/-- Distribute three existential quantifiers over a conjunction. (Contributed by NM, 26-Jul-1995.)
(Proof shortened by Andrew Salmon, 25-May-2011.) Reduce distinct variable restrictions. (Revised by
Wolf Lammen, 20-Jan-2018.) -/
theorem eeeanv {ph ps ch : setvar → wff} :
  ⊦ wb (wex (λ x3, wex (λ y, wex (λ z, w3a (ph x3) (ps y) (ch z))))) (w3a (wex (λ x3, ph x3)) (wex (λ y, ps y)) (wex (λ z, ch z))) :=
@«3bitr4i» (wa (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wex (λ z, ch z))) (wa (wa (wex (λ x3, ph x3)) (wex (λ y, ps y))) (wex (λ z, ch z))) (wex (λ x3, wex (λ y, wex (λ z, w3a (ph x3) (ps y) (ch z))))) (w3a (wex (λ x3, ph x3)) (wex (λ y, ps y)) (wex (λ z, ch z)))
  (@anbi1i (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wa (wex (λ x3, ph x3)) (wex (λ y, ps y))) (wex (λ z, ch z))
    (@eeanv (λ x3, ph x3) (λ y, ps y)))
  (@«3bitri» (wex (λ x3, wex (λ y, wex (λ z, w3a (ph x3) (ps y) (ch z))))) (wex (λ x3, wex (λ y, wa (wa (ph x3) (ps y)) (wex (λ z, ch z))))) (wex (λ x3, wa (wex (λ y, wa (ph x3) (ps y))) (wex (λ z, ch z)))) (wa (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wex (λ z, ch z)))
    (@«2exbii» (λ x3 y, wex (λ z, w3a (ph x3) (ps y) (ch z))) (λ x3 y, wa (wa (ph x3) (ps y)) (wex (λ z, ch z)))
      (λ x3 y, @bitri (wex (λ z, w3a (ph x3) (ps y) (ch z))) (wex (λ z, wa (wa (ph x3) (ps y)) (ch z))) (wa (wa (ph x3) (ps y)) (wex (λ z, ch z)))
        (@exbii (λ z, w3a (ph x3) (ps y) (ch z)) (λ z, wa (wa (ph x3) (ps y)) (ch z))
          (λ z, @df_3an (ph x3) (ps y) (ch z)))
        (@«19_42v» (wa (ph x3) (ps y)) (λ z, ch z))))
    (@exbii (λ x3, wex (λ y, wa (wa (ph x3) (ps y)) (wex (λ z, ch z)))) (λ x3, wa (wex (λ y, wa (ph x3) (ps y))) (wex (λ z, ch z)))
      (λ x3, setvar.forget $ λ y : setvar,
        show ⊦ wb (wex (λ y, wa (wa (ph x3) (ps y)) (wex (λ z, ch z)))) (wa (wex (λ y, wa (ph x3) (ps y))) (wex (λ z, ch z))), from
        @«19_41» (λ y, wa (ph x3) (ps y)) (λ y, wex (λ z, ch z))
          (@nfex (λ y z, ch z)
            (λ z, @nfv (ch z))) y))
    (setvar.forget $ λ x3 : setvar,
      show ⊦ wb (wex (λ x3, wa (wex (λ y, wa (ph x3) (ps y))) (wex (λ z, ch z)))) (wa (wex (λ x3, wex (λ y, wa (ph x3) (ps y)))) (wex (λ z, ch z))), from
      @«19_41» (λ x3, wex (λ y, wa (ph x3) (ps y))) (λ x3, wex (λ z, ch z))
        (@nfex (λ x3 z, ch z)
          (λ z, @nfv (ch z))) x3))
  (@df_3an (wex (λ x3, ph x3)) (wex (λ y, ps y)) (wex (λ z, ch z)))


/-- Substitution of variable in existential quantifier. Version of ~ sb8e with a disjoint variable
condition, not requiring ~ ax-13 . (Contributed by NM, 12-Aug-1993.) (Revised by Wolf Lammen,
19-Jan-2023.) -/
theorem sb8ev {ph : setvar → setvar → wff}
  (sb8v_nf : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (y : setvar) : ⊦ wb (wex (λ x3, ph x3 y)) (wex (λ y, wsb (λ x3, ph x3 y) y)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wex (λ x3, ph x3 y)) (wex (λ y, wsb (λ x3, ph x3 y) y)), from
  @cbvexv1 (λ x3 y, ph x3 y) (λ x3 y, wsb (λ x3, ph x3 y) y)
    (λ x3, sb8v_nf x3)
    (λ y, @nfs1v (λ x3 y, ph x3 y) y)
    (λ x3 y, @sbequ12 (λ x3 y, ph x3 y) x3 y) x3 y


/-- Formula-building lemma for use with the Distinctor Reduction Theorem. Version of ~ dral1 with a
disjoint variable condition, which does not require ~ ax-13 . Remark: the corresponding versions for
~ dral2 and ~ drex2 are instances of ~ albidv and ~ exbidv respectively. (Contributed by NM,
24-Nov-1994.) (Revised by BJ, 17-Jun-2019.) Base the proof on ~ ax12v . (Revised by Wolf Lammen,
30-Mar-2024.) -/
theorem dral1v {ph ps : setvar → setvar → wff}
  (dral1v_1 : ∀ x3 y, ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wb (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y))) :=
@bitrd (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, ph x3 y)) (wal (λ x3, ps x3 y)) (wal (λ y, ps x3 y))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wb (wal (λ x3, ph x3 y)) (wal (λ x3, ps x3 y))), from
    @albid (λ x3, wal (λ x3, wceq (cv x3) (cv y))) (λ x3, ph x3 y) (λ x3, ps x3 y)
      (@nfa1 (λ x3, wceq (cv x3) (cv y)))
      (λ x3, dral1v_1 x3 y) x3)
  (@impbid (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, ps x3 y)) (wal (λ y, ps x3 y))
    (@axc11v (λ x3 y, ps x3 y) x3 y)
    (@axc11rv (λ x3 y, ps x3 y) x3 y))


/-- Formula-building lemma for use with the Distinctor Reduction Theorem. Version of ~ drex1 with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM, 27-Feb-2005.)
(Revised by BJ, 17-Jun-2019.) -/
theorem drex1v {ph ps : setvar → setvar → wff}
  (dral1v_1 : ∀ x3 y, ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wb (wex (λ x3, ph x3 y)) (wex (λ y, ps x3 y))) :=
@«3bitr4g» (wal (λ x3, wceq (cv x3) (cv y))) (wn (wal (λ x3, wn (ph x3 y)))) (wn (wal (λ y, wn (ps x3 y)))) (wex (λ x3, ph x3 y)) (wex (λ y, ps x3 y))
  (@notbid (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wn (ph x3 y))) (wal (λ y, wn (ps x3 y)))
    (@dral1v (λ x3 y, wn (ph x3 y)) (λ x3 y, wn (ps x3 y))
      (λ x3 y, @notbid (wal (λ x3, wceq (cv x3) (cv y))) (ph x3 y) (ps x3 y)
        (dral1v_1 x3 y)) x3 y))
  (@df_ex (λ x3, ph x3 y))
  (@df_ex (λ y, ps x3 y))


/-- Formula-building lemma for use with the Distinctor Reduction Theorem. Version of ~ drnf1 with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by Mario Carneiro,
4-Oct-2016.) (Revised by BJ, 17-Jun-2019.) -/
theorem drnf1v {ph ps : setvar → setvar → wff}
  (dral1v_1 : ∀ x3 y, ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wi (wal (λ x3, wceq (cv x3) (cv y))) (wb (wnf (λ x3, ph x3 y)) (wnf (λ y, ps x3 y))) :=
@«3bitr4g» (wal (λ x3, wceq (cv x3) (cv y))) (wal (λ x3, wi (ph x3 y) (wal (λ x3, ph x3 y)))) (wal (λ y, wi (ps x3 y) (wal (λ y, ps x3 y)))) (wnf (λ x3, ph x3 y)) (wnf (λ y, ps x3 y))
  (@dral1v (λ x3 y, wi (ph x3 y) (wal (λ x3, ph x3 y))) (λ x3 y, wi (ps x3 y) (wal (λ y, ps x3 y)))
    (λ x3 y, @imbi12d (wal (λ x3, wceq (cv x3) (cv y))) (ph x3 y) (ps x3 y) (wal (λ x3, ph x3 y)) (wal (λ y, ps x3 y))
      (dral1v_1 x3 y)
      (@dral1v (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
        (λ x3 y, dral1v_1 x3 y) x3 y)) x3 y)
  (@nf5 (λ x3, ph x3 y))
  (@nf5 (λ y, ps x3 y))


/-- An elementary proof of ~ moeu in disguise, connecting an expression characterizing uniqueness (
~ df-mo ) to that of existential uniqueness ( ~ eu6 ). No particular order of definition is
required, as one can be derived from the other. This is shown here and in ~ dfeumo . (Contributed by
Wolf Lammen, 27-May-2019.) -/
theorem dfmoeu {ph : setvar → wff} :
  ⊦ wb (wi (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) :=
@impbii (wi (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))))
  (@ja (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))))
    (setvar.forget $ λ y : setvar,
      show ⊦ wi (wn (wex (λ x3, ph x3))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))), from
      @«19_8ad» (λ y, wn (wex (λ x3, ph x3))) (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
        (λ y, @sylbir (wn (wex (λ x3, ph x3))) (wal (λ x3, wn (ph x3))) (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
          (@alnex (λ x3, ph x3))
          (@alimi (λ x3, wn (ph x3)) (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))
            (λ x3, @pm2_21 (ph x3) (wceq (cv x3) (cv y))))) y)
    (@eximi (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))) (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
      (λ y, @alimi (λ x3, wb (ph x3) (wceq (cv x3) (cv y))) (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))
        (λ x3, @biimp (ph x3) (wceq (cv x3) (cv y))))))
  (@com12 (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))
    (@eximdv (wex (λ x3, ph x3)) (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))
      (λ y, setvar.forget $ λ x3 : setvar,
        show ⊦ wi (wex (λ x3, ph x3)) (wi (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))), from
        @exlimi (λ x3, ph x3) (λ x3, wi (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))
          (@nfia1 (λ x3, wi (ph x3) (wceq (cv x3) (cv y))) (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))
          (λ x3, @syl6ibr (ph x3) (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (wa (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))) (wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))
            (@ancld (ph x3) (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))
              (@spsd (λ x3, ph x3) (λ x3, wi (ph x3) (wceq (cv x3) (cv y))) (λ x3, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))
                (λ x3, @embantd (ph x3) (ph x3) (wceq (cv x3) (cv y)) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))
                  (@id (ph x3))
                  (@com12 (wceq (cv x3) (cv y)) (ph x3) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))
                    (@ax12v (λ x3, ph x3) x3 y))) x3))
            (@albiim (λ x3, ph x3) (λ x3, wceq (cv x3) (cv y)))) x3)))


-- /-- Extend wff definition to include the at-most-one quantifier ("there exists at most one ` x `
-- such that ` ph ` "). -/
-- constant wmo : (setvar → wff) → wff


-- /-- Define the at-most-one quantifier. The expression ` E* x ph ` is read "there exists at most
-- one ` x ` such that ` ph ` ". This is also called the "uniqueness quantifier" but that expression
-- is also used for the unique existential quantifier ~ df-eu , therefore we avoid that ambiguous
-- name. Notation of [BellMachover] p. 460, whose definition we show as ~ mo3 . For other possible
-- definitions see ~ moeu and ~ mo4 . (Contributed by Wolf Lammen, 27-May-2019.) Make this the
-- definition (which used to be ~ moeu , while this definition was then proved as ~ dfmo ). (Revised
-- by BJ, 30-Sep-2022.) -/
-- axiom df_mo {ph : setvar → wff} : ⊦ wb (wmo (λ x3, ph x3)) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))))


/-- Nonexistence implies uniqueness. (Contributed by BJ, 30-Sep-2022.) Avoid ~ ax-11 . (Revised by
Wolf Lammen, 16-Oct-2022.) -/
theorem nexmo {ph : setvar → wff} :
  ⊦ wi (wn (wex (λ x3, ph x3))) (wmo (λ x3, ph x3)) :=
@«3imtr4i» (wal (λ x3, wn (ph x3))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) (wn (wex (λ x3, ph x3))) (wmo (λ x3, ph x3))
  (setvar.forget $ λ y : setvar,
    show ⊦ wi (wal (λ x3, wn (ph x3))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))), from
    @«19_2d» (λ y, wal (λ x3, wn (ph x3))) (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
      (λ y, @alrimiv (wal (λ x3, wn (ph x3))) (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
        (λ y, @alimi (λ x3, wn (ph x3)) (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))
          (λ x3, @pm2_21 (ph x3) (wceq (cv x3) (cv y))))) y)
  (@bicomi (wal (λ x3, wn (ph x3))) (wn (wex (λ x3, ph x3)))
    (@alnex (λ x3, ph x3)))
  (@df_mo (λ x3, ph x3))


/-- Absorption of existence condition by uniqueness. (Contributed by NM, 4-Nov-2002.) Shorten proof
and avoid ~ df-eu . (Revised by BJ, 14-Oct-2022.) -/
theorem moabs {ph : setvar → wff} :
  ⊦ wb (wmo (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))) :=
@impbii (wmo (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wmo (λ x3, ph x3)))
  (@ax_1 (wmo (λ x3, ph x3)) (wex (λ x3, ph x3)))
  (@ja (wex (λ x3, ph x3)) (wmo (λ x3, ph x3)) (wmo (λ x3, ph x3))
    (@nexmo (λ x3, ph x3))
    (@id (wmo (λ x3, ph x3))))


/-- The at-most-one quantifier reverses implication. (Contributed by NM, 22-Apr-1995.) -/
theorem moim {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wi (ph x3) (ps x3))) (wi (wmo (λ x3, ps x3)) (wmo (λ x3, ph x3))) :=
@«3imtr4g» (wal (λ x3, wi (ph x3) (ps x3))) (wex (λ y, wal (λ x3, wi (ps x3) (wceq (cv x3) (cv y))))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) (wmo (λ x3, ps x3)) (wmo (λ x3, ph x3))
  (@eximdv (wal (λ x3, wi (ph x3) (ps x3))) (λ y, wal (λ x3, wi (ps x3) (wceq (cv x3) (cv y)))) (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
    (λ y, @al2imi (λ x3, wi (ph x3) (ps x3)) (λ x3, wi (ps x3) (wceq (cv x3) (cv y))) (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))
      (λ x3, @imim1 (ph x3) (ps x3) (wceq (cv x3) (cv y)))))
  (@df_mo (λ x3, ps x3))
  (@df_mo (λ x3, ph x3))


/-- The at-most-one quantifier reverses implication. (Contributed by NM, 15-Feb-2006.) Remove use of
~ ax-5 . (Revised by Steven Nguyen, 9-May-2023.) -/
theorem moimi {ph ps : setvar → wff}
  (moimi_1 : ∀ x3, ⊦ wi (ph x3) (ps x3)) :
  ⊦ wi (wmo (λ x3, ps x3)) (wmo (λ x3, ph x3)) :=
@«3imtr4i» (wex (λ y, wal (λ x3, wi (ps x3) (wceq (cv x3) (cv y))))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) (wmo (λ x3, ps x3)) (wmo (λ x3, ph x3))
  (@eximi (λ y, wal (λ x3, wi (ps x3) (wceq (cv x3) (cv y)))) (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
    (λ y, @alimi (λ x3, wi (ps x3) (wceq (cv x3) (cv y))) (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))
      (λ x3, @imim1i (ph x3) (ps x3) (wceq (cv x3) (cv y))
        (moimi_1 x3))))
  (@df_mo (λ x3, ps x3))
  (@df_mo (λ x3, ph x3))


/-- Equivalence theorem for the at-most-one quantifier. (Contributed by BJ, 7-Oct-2022.) (Proof
shortened by Wolf Lammen, 18-Feb-2023.) -/
theorem mobi {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wb (ph x3) (ps x3))) (wb (wmo (λ x3, ph x3)) (wmo (λ x3, ps x3))) :=
@sylbi (wal (λ x3, wb (ph x3) (ps x3))) (wa (wal (λ x3, wi (ph x3) (ps x3))) (wal (λ x3, wi (ps x3) (ph x3)))) (wb (wmo (λ x3, ph x3)) (wmo (λ x3, ps x3)))
  (@albiim (λ x3, ph x3) (λ x3, ps x3))
  (@imp (wal (λ x3, wi (ph x3) (ps x3))) (wal (λ x3, wi (ps x3) (ph x3))) (wb (wmo (λ x3, ph x3)) (wmo (λ x3, ps x3)))
    (@impbid21d (wal (λ x3, wi (ph x3) (ps x3))) (wal (λ x3, wi (ps x3) (ph x3))) (wmo (λ x3, ph x3)) (wmo (λ x3, ps x3))
      (@moim (λ x3, ps x3) (λ x3, ph x3))
      (@moim (λ x3, ph x3) (λ x3, ps x3))))


/-- Formula-building rule for the at-most-one quantifier (inference form). (Contributed by NM,
9-Mar-1995.) (Revised by Mario Carneiro, 17-Oct-2016.) Avoid ~ ax-5 . (Revised by Wolf Lammen,
24-Sep-2023.) -/
theorem mobii {ps ch : setvar → wff}
  (mobii_1 : ∀ x3, ⊦ wb (ps x3) (ch x3)) :
  ⊦ wb (wmo (λ x3, ps x3)) (wmo (λ x3, ch x3)) :=
@impbii (wmo (λ x3, ps x3)) (wmo (λ x3, ch x3))
  (@moimi (λ x3, ch x3) (λ x3, ps x3)
    (λ x3, @biimpri (ps x3) (ch x3)
      (mobii_1 x3)))
  (@moimi (λ x3, ps x3) (λ x3, ch x3)
    (λ x3, @biimpi (ps x3) (ch x3)
      (mobii_1 x3)))


/-- Formula-building rule for the at-most-one quantifier (deduction form). (Contributed by Mario
Carneiro, 7-Oct-2016.) Reduce axiom dependencies and shorten proof. (Revised by BJ, 7-Oct-2022.) -/
theorem mobidv {ph : wff} {ps ch : setvar → wff}
  (mobidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wmo (λ x3, ps x3)) (wmo (λ x3, ch x3))) :=
@syl ph (wal (λ x3, wb (ps x3) (ch x3))) (wb (wmo (λ x3, ps x3)) (wmo (λ x3, ch x3)))
  (@alrimiv ph (λ x3, wb (ps x3) (ch x3))
    (λ x3, mobidv_1 x3))
  (@mobi (λ x3, ps x3) (λ x3, ch x3))


/-- "At most one" is still the case when a conjunct is added. (Contributed by NM, 22-Apr-1995.) -/
theorem moan {ph ps : setvar → wff} :
  ⊦ wi (wmo (λ x3, ph x3)) (wmo (λ x3, wa (ps x3) (ph x3))) :=
@moimi (λ x3, wa (ps x3) (ph x3)) (λ x3, ph x3)
  (λ x3, @simpr (ps x3) (ph x3))


/-- "At most one" is still true when a conjunct is added. (Contributed by NM, 9-Mar-1995.) -/
theorem moani {ph ps : setvar → wff}
  (moani_1 : ⊦ wmo (λ x3, ph x3)) :
  ⊦ wmo (λ x3, wa (ps x3) (ph x3)) :=
@ax_mp (wmo (λ x3, ph x3)) (wmo (λ x3, wa (ps x3) (ph x3)))
  moani_1
  (@moan (λ x3, ph x3) (λ x3, ps x3))


/-- Bound-variable hypothesis builder for the at-most-one quantifier. (Contributed by NM,
8-Mar-1995.) (Revised by Mario Carneiro, 7-Oct-2016.) Adapt to new definition. (Revised by BJ,
1-Oct-2022.) -/
theorem nfmo1 {ph : setvar → wff} :
  ⊦ wnf (λ x3, wmo (λ x3, ph x3)) :=
@nfxfr (λ x3, wmo (λ x3, ph x3)) (λ x3, wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))))
  (λ x3, @df_mo (λ x3, ph x3))
  (@nfex (λ x3 y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))
    (λ y, @nfa1 (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))))


/-- Bound-variable hypothesis builder for the at-most-one quantifier. See ~ nfmod for a version
without disjoint variable conditions but requiring ~ ax-13 . (Contributed by Mario Carneiro,
14-Nov-2016.) (Revised by BJ, 28-Jan-2023.) -/
theorem nfmodv {ph ps : setvar → setvar → wff}
  (nfmodv_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (nfmodv_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ps x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnf (λ x3, wmo (λ y, ps x3 y))) :=
@nfxfrd (λ x3, wmo (λ y, ps x3 y)) (λ x3, wex (λ z, wal (λ y, wi (ps x3 y) (wceq (cv y) (cv z))))) (λ x3, ph x3 y)
  (λ x3, @df_mo (λ y, ps x3 y))
  (λ x3, setvar.forget $ λ z : setvar,
    show ⊦ wi (ph x3 y) (wnf (λ x3, wex (λ z, wal (λ y, wi (ps x3 y) (wceq (cv y) (cv z)))))), from
    @nfexd (λ x3 z, ph x3 y) (λ x3 z, wal (λ y, wi (ps x3 y) (wceq (cv y) (cv z))))
      (λ x3, @nfv (ph x3 y))
      (λ x3 z, @nfald (λ x3 y, ph x3 y) (λ x3 y, wi (ps x3 y) (wceq (cv y) (cv z)))
        (λ x3, nfmodv_1 x3)
        (λ x3 y, @nfimd (λ x3, ph x3 y) (λ x3, ps x3 y) (λ x3, wceq (cv y) (cv z))
          (λ x3, nfmodv_2 x3 y)
          (λ x3, @nfvd (λ x3, ph x3 y) (wceq (cv y) (cv z)) x3) x3) x3 y) x3 z) x3


/-- Bound-variable hypothesis builder for the at-most-one quantifier. See ~ nfmo for a version
without disjoint variable conditions but requiring ~ ax-13 . (Contributed by NM, 9-Mar-1995.)
(Revised by Wolf Lammen, 2-Oct-2023.) -/
theorem nfmov {ph : setvar → setvar → wff}
  (nfmov_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y)) :
  ⊦ wnf (λ x3, wmo (λ y, ph x3 y)) :=
@mptru (wnf (λ x3, wmo (λ y, ph x3 y)))
  (setvar.forget $ λ x3 : setvar,
    setvar.forget $ λ y : setvar,
    show ⊦ wi wtru (wnf (λ x3, wmo (λ y, ph x3 y))), from
    @nfmodv (λ x3 y, wtru) (λ x3 y, ph x3 y)
      (λ x3, nftru)
      (λ x3 y, @a1i (wnf (λ x3, ph x3 y)) wtru
        (nfmov_1 y)) x3 y)


/-- Version of ~ df-mo with disjoint variable condition replaced by nonfreeness hypothesis.
(Contributed by NM, 8-Mar-1995.) Extract ~ dfmo from this proof, and prove ~ mof from it (as of
30-Sep-2022, directly from ~ df-mo ). (Revised by Wolf Lammen, 28-May-2019.) Avoid ~ ax-13 .
(Revised by Wolf Lammen, 16-Oct-2022.) -/
theorem mof {ph : setvar → setvar → wff}
  (mof_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (y : setvar) : ⊦ wb (wmo (λ x3, ph x3 y)) (wex (λ y, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y))))) :=
@bitri (wmo (λ x3, ph x3 y)) (wex (λ z, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z))))) (wex (λ y, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y)))))
  (@df_mo (λ x3, ph x3 y))
  (setvar.forget $ λ z : setvar,
    show ⊦ wb (wex (λ z, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z))))) (wex (λ y, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y))))), from
    @cbvexv1 (λ z y, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z)))) (λ z y, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y))))
      (λ z, @nfal (λ y x3, wi (ph x3 y) (wceq (cv x3) (cv z)))
        (λ x3, @nfim (λ y, ph x3 y) (λ y, wceq (cv x3) (cv z))
          (mof_1 x3)
          (@nfv (wceq (cv x3) (cv z)))))
      (λ y, @nfv (wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y)))))
      (λ z y, @albidv (wceq (cv z) (cv y)) (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z))) (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y)))
        (λ x3, @imbi2d (wceq (cv z) (cv y)) (wceq (cv x3) (cv z)) (wceq (cv x3) (cv y)) (ph x3 y)
          (@equequ2 z y x3))) z y)


/-- Alternate definition of the at-most-one quantifier. Definition of [BellMachover] p. 460, except
that definition has the side condition that ` y ` not occur in ` ph ` in place of our hypothesis.
(Contributed by NM, 8-Mar-1995.) (Proof shortened by Wolf Lammen, 18-Aug-2019.) Remove dependency on
~ ax-13 . (Revised by BJ and WL, 29-Jan-2023.) -/
theorem mo3 {ph : setvar → setvar → wff}
  (mo3_nf : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (y : setvar) : ⊦ wb (wmo (λ x3, ph x3 y)) (wal (λ x3, wal (λ y, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))))) :=
@impbii (wmo (λ x3, ph x3 y)) (wal (λ x3, wal (λ y, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y)))))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi (wmo (λ x3, ph x3 y)) (wal (λ x3, wal (λ y, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))))), from
    @alrimi (λ x3, wmo (λ x3, ph x3 y)) (λ x3, wal (λ y, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))))
      (@nfmo1 (λ x3, ph x3 y))
      (λ x3, @alrimi (λ y, wmo (λ x3, ph x3 y)) (λ y, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y)))
        (@nfmov (λ y x3, ph x3 y)
          (λ x3, mo3_nf x3))
        (λ y, @sylbi (wmo (λ x3, ph x3 y)) (wex (λ z, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z))))) (wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y)))
          (@df_mo (λ x3, ph x3 y))
          (@exlimiv (λ z, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z)))) (wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y)))
            (λ z, @syl6 (wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z)))) (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) (wceq (cv x3) (cv y))
              (@anim12d (wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z)))) (ph x3 y) (wceq (cv x3) (cv z)) (wsb (λ x3, ph x3 y) y) (wceq (cv y) (cv z))
                (@sp (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z))) x3)
                (@syl6ib (wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z)))) (wsb (λ x3, ph x3 y) y) (wsb (λ x3, wceq (cv x3) (cv z)) y) (wceq (cv y) (cv z))
                  (@spsbim (λ x3, ph x3 y) (λ x3, wceq (cv x3) (cv z)) y)
                  (@equsb3 z y)))
              (@equtr2 x3 y z)))) y) x3)
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi (wal (λ x3, wal (λ y, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))))) (wmo (λ x3, ph x3 y)), from
    @alcoms (λ y x3, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))) (λ y x3, wmo (λ x3, ph x3 y))
      (λ y x3, @sylibr (wal (λ y, wal (λ x3, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))))) (wi (wex (λ x3, ph x3 y)) (wmo (λ x3, ph x3 y))) (wmo (λ x3, ph x3 y))
        (@«3imtr4g» (wal (λ y, wal (λ x3, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))))) (wex (λ y, wsb (λ x3, ph x3 y) y)) (wex (λ y, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3 y)) (wmo (λ x3, ph x3 y))
          (@aleximi (λ y, wal (λ x3, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y)))) (λ y, wsb (λ x3, ph x3 y) y) (λ y, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y))))
            (λ y, @com12 (wsb (λ x3, ph x3 y) y) (wal (λ x3, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y)))) (wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y))))
              (setvar.forget $ λ x3 : setvar,
                show ⊦ wi (wsb (λ x3, ph x3 y) y) (wi (wal (λ x3, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y)))) (wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y))))), from
                @alimd (λ x3, wsb (λ x3, ph x3 y) y) (λ x3, wi (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))) (λ x3, wi (ph x3 y) (wceq (cv x3) (cv y)))
                  (@nfs1v (λ x3 y, ph x3 y) y)
                  (λ x3, @imim1d (wsb (λ x3, ph x3 y) y) (ph x3 y) (wa (ph x3 y) (wsb (λ x3, ph x3 y) y)) (wceq (cv x3) (cv y))
                    (@pm3_21 (wsb (λ x3, ph x3 y) y) (ph x3 y))) x3)))
          (@sb8ev (λ x3 y, ph x3 y)
            (λ x3, mo3_nf x3) y)
          (@mof (λ x3 y, ph x3 y)
            (λ x3, mo3_nf x3) y))
        (@moabs (λ x3, ph x3 y))) y x3)


/-- At-most-one quantifier expressed using implicit substitution. This theorem is also a direct
consequence of ~ mo4f , but this proof is based on fewer axioms. By the way, swapping ` x ` , ` y `
and ` ph ` , ` ps ` leads to an expression for ` E* y ps ` , which is equivalent to ` E* x ph ` (is
a proof line), so the right hand side is a rare instance of an expression where swapping the
quantifiers can be done without ~ ax-11 . (Contributed by NM, 26-Jul-1995.) Reduce axiom usage.
(Revised by Wolf Lammen, 18-Oct-2023.) -/
theorem mo4 {ph ps : setvar → wff}
  (mo4_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wb (wmo (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))) :=
@impbii (wmo (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))))
  (@sylbi (wmo (λ x3, ph x3)) (wex (λ z, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z))))) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))))
    (@df_mo (λ x3, ph x3))
    (@exlimiv (λ z, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z)))) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))))
      (λ z, @mpcom (wal (λ y, wi (ps y) (wceq (cv y) (cv z)))) (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z)))) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))))
        (@biimpi (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z)))) (wal (λ y, wi (ps y) (wceq (cv y) (cv z))))
          (@cbvalvw (λ x3, wi (ph x3) (wceq (cv x3) (cv z))) (λ y, wi (ps y) (wceq (cv y) (cv z)))
            (λ x3 y, @imbi12d (wceq (cv x3) (cv y)) (ph x3) (ps y) (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))
              (mo4_1 x3 y)
              (@equequ1 z x3 y))))
        (@alimdv (wal (λ y, wi (ps y) (wceq (cv y) (cv z)))) (λ x3, wi (ph x3) (wceq (cv x3) (cv z))) (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))
          (λ x3, @com12 (wi (ph x3) (wceq (cv x3) (cv z))) (wal (λ y, wi (ps y) (wceq (cv y) (cv z)))) (wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))
            (@alimdv (wi (ph x3) (wceq (cv x3) (cv z))) (λ y, wi (ps y) (wceq (cv y) (cv z))) (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))
              (λ y, @ex (wi (ph x3) (wceq (cv x3) (cv z))) (wi (ps y) (wceq (cv y) (cv z))) (wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))
                (@syl6com (wa (ph x3) (ps y)) (wa (wi (ph x3) (wceq (cv x3) (cv z))) (wi (ps y) (wceq (cv y) (cv z)))) (wa (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))) (wceq (cv x3) (cv y))
                  (@anim12d (wa (ph x3) (ps y)) (wi (ph x3) (wceq (cv x3) (cv z))) (wceq (cv x3) (cv z)) (wi (ps y) (wceq (cv y) (cv z))) (wceq (cv y) (cv z))
                    (@adantr (ph x3) (wi (wi (ph x3) (wceq (cv x3) (cv z))) (wceq (cv x3) (cv z))) (ps y)
                      (@pm2_27 (ph x3) (wceq (cv x3) (cv z))))
                    (@adantl (ps y) (wi (wi (ps y) (wceq (cv y) (cv z))) (wceq (cv y) (cv z))) (ph x3)
                      (@pm2_27 (ps y) (wceq (cv y) (cv z)))))
                  (@equtr2 x3 y z)))))))))
  (@sylibr (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))) (wi (wex (λ y, ps y)) (wmo (λ y, ps y))) (wmo (λ x3, ph x3))
    (@syl56 (wex (λ y, ps y)) (wex (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))) (wex (λ x3, wmo (λ y, ps y))) (wmo (λ y, ps y))
      (@biimpri (wex (λ x3, ph x3)) (wex (λ y, ps y))
        (@cbvexvw (λ x3, ph x3) (λ y, ps y)
          (λ x3 y, mo4_1 x3 y)))
      (@aleximi (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))) (λ x3, ph x3) (λ x3, wmo (λ y, ps y))
        (λ x3, @expcom (ph x3) (wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))) (wmo (λ y, ps y))
          (@sylibr (wa (ph x3) (wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))) (wex (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z))))) (wmo (λ y, ps y))
            (@mpi (wa (ph x3) (wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))) (wex (λ z, wceq (cv x3) (cv z))) (wex (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z)))))
              (@ax6evr x3)
              (@eximdv (wa (ph x3) (wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))) (λ z, wceq (cv x3) (cv z)) (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z))))
                (λ z, @impancom (ph x3) (wceq (cv x3) (cv z)) (wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))) (wal (λ y, wi (ps y) (wceq (cv y) (cv z))))
                  (@alimdv (wa (ph x3) (wceq (cv x3) (cv z))) (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))) (λ y, wi (ps y) (wceq (cv y) (cv z)))
                    (λ y, @impcom (wceq (cv x3) (cv z)) (ph x3) (wi (wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))) (wi (ps y) (wceq (cv y) (cv z))))
                      (@com4r (ph x3) (wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))) (ps y) (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))
                        (@syl8 (ph x3) (wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))) (ps y) (wceq (cv x3) (cv y)) (wi (wceq (cv x3) (cv z)) (wceq (cv y) (cv z)))
                          (@imim1d (ph x3) (ps y) (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))
                            (@pm3_2 (ph x3) (ps y)))
                          (@ax7 x3 y z))))))))
            (@df_mo (λ y, ps y)))))
      (@ax5e (wmo (λ y, ps y))))
    (@bitri (wmo (λ x3, ph x3)) (wmo (λ y, ps y)) (wi (wex (λ y, ps y)) (wmo (λ y, ps y)))
      (@«3bitr4i» (wex (λ z, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z))))) (wex (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z))))) (wmo (λ x3, ph x3)) (wmo (λ y, ps y))
        (@exbii (λ z, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z)))) (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z))))
          (λ z, @cbvalvw (λ x3, wi (ph x3) (wceq (cv x3) (cv z))) (λ y, wi (ps y) (wceq (cv y) (cv z)))
            (λ x3 y, @imbi12d (wceq (cv x3) (cv y)) (ph x3) (ps y) (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))
              (mo4_1 x3 y)
              (@equequ1 z x3 y))))
        (@df_mo (λ x3, ph x3))
        (@df_mo (λ y, ps y)))
      (@moabs (λ y, ps y))))


/-- At-most-one quantifier expressed using implicit substitution. Note that the disjoint variable
condition on ` y , ph ` can be replaced by the nonfreeness hypothesis ` |- F/ y ph ` with
essentially the same proof. (Contributed by NM, 10-Apr-2004.) Remove dependency on ~ ax-13 .
(Revised by Wolf Lammen, 19-Jan-2023.) -/
theorem mo4f {ph : setvar → wff} {ps : setvar → setvar → wff}
  (mo4f_1 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (mo4f_2 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps x3 y))) :
  ⊦ wb (wmo (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps x3 y)) (wceq (cv x3) (cv y))))) :=
@bitri (wmo (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (wsb (λ x3, ph x3) y)) (wceq (cv x3) (cv y))))) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps x3 y)) (wceq (cv x3) (cv y)))))
  (setvar.forget $ λ y : setvar,
    show ⊦ wb (wmo (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (wsb (λ x3, ph x3) y)) (wceq (cv x3) (cv y))))), from
    @mo3 (λ x3 y, ph x3)
      (λ x3, @nfv (ph x3)) y)
  (@«2albii» (λ x3 y, wi (wa (ph x3) (wsb (λ x3, ph x3) y)) (wceq (cv x3) (cv y))) (λ x3 y, wi (wa (ph x3) (ps x3 y)) (wceq (cv x3) (cv y)))
    (λ x3 y, @imbi1i (wa (ph x3) (wsb (λ x3, ph x3) y)) (wa (ph x3) (ps x3 y)) (wceq (cv x3) (cv y))
      (@anbi2i (wsb (λ x3, ph x3) y) (ps x3 y) (ph x3)
        (@sbiev (λ x3 y, ph x3) (λ x3 y, ps x3 y)
          (λ y, mo4f_1 y)
          (λ x3 y, mo4f_2 x3 y) x3 y))))


-- /-- Extend wff definition to include the unique existential quantifier ("there exists a unique `
-- x ` such that ` ph ` "). -/
-- constant weu : (setvar → wff) → wff


-- /-- Define the existential uniqueness quantifier. This expresses unique existence, or existential
-- uniqueness, which is the conjunction of existence ( ~ df-ex ) and uniqueness ( ~ df-mo ). The
-- expression ` E! x ph ` is read "there exists exactly one ` x ` such that ` ph ` " or "there
-- exists a unique ` x ` such that ` ph ` ". This is also called the "uniqueness quantifier" but
-- that expression is also used for the at-most-one quantifier ~ df-mo , therefore we avoid that
-- ambiguous name. Definition 10.1 of [BellMachover] p. 97; also Definition *14.02 of
-- [WhiteheadRussell] p. 175. Other possible definitions are given by ~ eu1 , ~ eu2 , ~ eu3v , and ~
-- eu6 . As for double unique existence, beware that the expression ` E! x E! y ph ` means "there
-- exists a unique ` x ` such that there exists a unique ` y ` such that ` ph ` " which is a weaker
-- property than "there exists exactly one ` x ` and one ` y ` such that ` ph ` " (see ~ 2eu4 ).
-- (Contributed by NM, 12-Aug-1993.) Make this the definition (which used to be ~ eu6 , while this
-- definition was then proved as ~ dfeu ). (Revised by BJ, 30-Sep-2022.) -/
-- axiom df_eu {ph : setvar → wff} : ⊦ wb (weu (λ x3, ph x3)) (wa (wex (λ x3, ph x3)) (wmo (λ x3, ph x3)))


/-- An alternate way to express existential uniqueness. (Contributed by NM, 8-Jul-1994.) Replace a
nonfreeness hypothesis with a disjoint variable condition on ` ph ` , ` y ` to reduce axiom usage.
(Revised by Wolf Lammen, 29-May-2019.) -/
theorem eu3v {ph : setvar → wff} :
  ⊦ wb (weu (λ x3, ph x3)) (wa (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))))) :=
@bitri (weu (λ x3, ph x3)) (wa (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))) (wa (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))))
  (@df_eu (λ x3, ph x3))
  (@anbi2i (wmo (λ x3, ph x3)) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3))
    (@df_mo (λ x3, ph x3)))


/-- Alternate definition of the unique existential quantifier ~ df-eu not using the at-most-one
quantifier. (Contributed by NM, 12-Aug-1993.) This used to be the definition of the unique
existential quantifier, while ~ df-eu was then proved as ~ dfeu . (Revised by BJ, 30-Sep-2022.)
(Proof shortened by Wolf Lammen, 3-Jan-2023.) Remove use of ~ ax-11 . (Revised by SN, 21-Sep-2023.)
-/
theorem eu6 {ph : setvar → wff} :
  ⊦ wb (weu (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) :=
@bitri (weu (λ x3, ph x3)) (wa (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))
  (@«3bitr4ri» (wa (wex (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))))) (wa (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))))) (wa (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))) (weu (λ x3, ph x3))
    (@anbi2i (wi (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3))
      (@dfmoeu (λ x3, ph x3)))
    (@abai (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))))
    (@eu3v (λ x3, ph x3)))
  (@«3bitr4i» (wa (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3))) (wa (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) (wi (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3)))) (wa (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))
    (@abai (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3)))
    (@ancom (wex (λ x3, ph x3)) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))))
    (@biantru (wi (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3))) (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))
      (@syl (wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))) (wex (λ y, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))) (wex (λ x3, ph x3))
        (@eximi (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))) (λ y, wal (λ x3, wi (wceq (cv x3) (cv y)) (ph x3)))
          (λ y, @alimi (λ x3, wb (ph x3) (wceq (cv x3) (cv y))) (λ x3, wi (wceq (cv x3) (cv y)) (ph x3))
            (λ x3, @biimpr (ph x3) (wceq (cv x3) (cv y)))))
        (@exsbim (λ x3, ph x3)))))


/-- Existential uniqueness implies existence. (Contributed by NM, 15-Sep-1993.) (Proof shortened by
Andrew Salmon, 9-Jul-2011.) (Proof shortened by Wolf Lammen, 4-Dec-2018.) (Proof shortened by BJ,
7-Oct-2022.) -/
theorem euex {ph : setvar → wff} :
  ⊦ wi (weu (λ x3, ph x3)) (wex (λ x3, ph x3)) :=
@simplbi (weu (λ x3, ph x3)) (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))
  (@df_eu (λ x3, ph x3))


/-- Existential uniqueness implies uniqueness. (Contributed by NM, 23-Mar-1995.) -/
theorem eumo {ph : setvar → wff} :
  ⊦ wi (weu (λ x3, ph x3)) (wmo (λ x3, ph x3)) :=
@simprbi (weu (λ x3, ph x3)) (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))
  (@df_eu (λ x3, ph x3))


/-- Uniqueness inferred from existential uniqueness. (Contributed by NM, 5-Apr-1995.) -/
theorem eumoi {ph : setvar → wff}
  (eumoi_1 : ⊦ weu (λ x3, ph x3)) :
  ⊦ wmo (λ x3, ph x3) :=
@ax_mp (weu (λ x3, ph x3)) (wmo (λ x3, ph x3))
  eumoi_1
  (@eumo (λ x3, ph x3))


/-- Existence implies that uniqueness is equivalent to unique existence. (Contributed by NM,
5-Apr-2004.) -/
theorem exmoeub {ph : setvar → wff} :
  ⊦ wi (wex (λ x3, ph x3)) (wb (wmo (λ x3, ph x3)) (weu (λ x3, ph x3))) :=
@baibr (weu (λ x3, ph x3)) (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))
  (@df_eu (λ x3, ph x3))


/-- Uniqueness is equivalent to existence implying unique existence. Alternate definition of the
at-most-one quantifier, in terms of the existential quantifier and the unique existential
quantifier. (Contributed by NM, 8-Mar-1995.) This used to be the definition of the at-most-one
quantifier, while ~ df-mo was then proved as ~ dfmo . (Revised by BJ, 30-Sep-2022.) -/
theorem moeu {ph : setvar → wff} :
  ⊦ wb (wmo (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (weu (λ x3, ph x3))) :=
@bitri (wmo (λ x3, ph x3)) (wi (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))) (wi (wex (λ x3, ph x3)) (weu (λ x3, ph x3)))
  (@moabs (λ x3, ph x3))
  (@pm5_74i (wex (λ x3, ph x3)) (wmo (λ x3, ph x3)) (weu (λ x3, ph x3))
    (@exmoeub (λ x3, ph x3)))


/-- Equivalence theorem for the unique existential quantifier. Theorem *14.271 in [WhiteheadRussell]
p. 192. (Contributed by Andrew Salmon, 11-Jul-2011.) Reduce dependencies on axioms. (Revised by BJ,
7-Oct-2022.) -/
theorem eubi {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wb (ph x3) (ps x3))) (wb (weu (λ x3, ph x3)) (weu (λ x3, ps x3))) :=
@«3bitr4g» (wal (λ x3, wb (ph x3) (ps x3))) (wa (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))) (wa (wex (λ x3, ps x3)) (wmo (λ x3, ps x3))) (weu (λ x3, ph x3)) (weu (λ x3, ps x3))
  (@anbi12d (wal (λ x3, wb (ph x3) (ps x3))) (wex (λ x3, ph x3)) (wex (λ x3, ps x3)) (wmo (λ x3, ph x3)) (wmo (λ x3, ps x3))
    (@exbi (λ x3, ph x3) (λ x3, ps x3))
    (@mobi (λ x3, ph x3) (λ x3, ps x3)))
  (@df_eu (λ x3, ph x3))
  (@df_eu (λ x3, ps x3))


/-- Introduce unique existential quantifier to both sides of an equivalence. (Contributed by NM,
9-Jul-1994.) (Revised by Mario Carneiro, 6-Oct-2016.) Avoid ~ ax-5 . (Revised by Wolf Lammen,
27-Sep-2023.) -/
theorem eubii {ph ps : setvar → wff}
  (eubii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (weu (λ x3, ph x3)) (weu (λ x3, ps x3)) :=
@«3bitr4i» (wa (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))) (wa (wex (λ x3, ps x3)) (wmo (λ x3, ps x3))) (weu (λ x3, ph x3)) (weu (λ x3, ps x3))
  (@anbi12i (wex (λ x3, ph x3)) (wex (λ x3, ps x3)) (wmo (λ x3, ph x3)) (wmo (λ x3, ps x3))
    (@exbii (λ x3, ph x3) (λ x3, ps x3)
      (λ x3, eubii_1 x3))
    (@mobii (λ x3, ph x3) (λ x3, ps x3)
      (λ x3, eubii_1 x3)))
  (@df_eu (λ x3, ph x3))
  (@df_eu (λ x3, ps x3))


/-- Formula-building rule for unique existential quantifier (deduction form). (Contributed by NM,
9-Jul-1994.) Reduce axiom dependencies and shorten proof. (Revised by BJ, 7-Oct-2022.) -/
theorem eubidv {ph : wff} {ps ch : setvar → wff}
  (eubidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (weu (λ x3, ps x3)) (weu (λ x3, ch x3))) :=
@syl ph (wal (λ x3, wb (ps x3) (ch x3))) (wb (weu (λ x3, ps x3)) (weu (λ x3, ch x3)))
  (@alrimiv ph (λ x3, wb (ps x3) (ch x3))
    (λ x3, eubidv_1 x3))
  (@eubi (λ x3, ps x3) (λ x3, ch x3))


/-- Bound-variable hypothesis builder for uniqueness. See also ~ nfeu1ALT . (Contributed by NM,
9-Jul-1994.) (Revised by Mario Carneiro, 7-Oct-2016.) -/
theorem nfeu1 {ph : setvar → wff} :
  ⊦ wnf (λ x3, weu (λ x3, ph x3)) :=
@nfxfr (λ x3, weu (λ x3, ph x3)) (λ x3, wex (λ y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))
  (λ x3, @eu6 (λ x3, ph x3))
  (@nfex (λ x3 y, wal (λ x3, wb (ph x3) (wceq (cv x3) (cv y))))
    (λ y, @nfa1 (λ x3, wb (ph x3) (wceq (cv x3) (cv y)))))


/-- There exists a unique set equal to a given set. Special case of ~ eueqi proved using only
predicate calculus. The proof needs ` y = z ` be free of ` x ` . This is ensured by having ` x ` and
` y ` be distinct. Alternately, a distinctor ` -. A. x x = y ` could have been used instead. See ~
eueq and ~ eueqi for classes. (Contributed by Stefan Allan, 4-Dec-2008.) (Proof shortened by Wolf
Lammen, 8-Sep-2019.) Reduce axiom usage. (Revised by Wolf Lammen, 1-Mar-2023.) -/
theorem euequ
  (y : setvar) : ⊦ weu (λ x3, wceq (cv x3) (cv y)) :=
@mpbir2an (weu (λ x3, wceq (cv x3) (cv y))) (wex (λ x3, wceq (cv x3) (cv y))) (wex (λ z, wal (λ x3, wi (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z)))))
  (@ax6ev y)
  (@eximii (λ z, wceq (cv z) (cv y)) (λ z, wal (λ x3, wi (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z))))
    (@ax6ev y)
    (λ z, @alrimiv (wceq (cv z) (cv y)) (λ x3, wi (wceq (cv x3) (cv y)) (wceq (cv x3) (cv z)))
      (λ x3, @equeuclr z x3 y)))
  (@eu3v (λ x3, wceq (cv x3) (cv y)))


/-- Change bound variable. Uses only Tarski's FOL axiom schemes. See ~ cbvmo for a version with
fewer disjoint variable conditions but requiring more axioms. (Contributed by NM, 9-Mar-1995.)
(Revised by Gino Giotto, 30-Sep-2024.) -/
theorem cbvmovw {ph ps : setvar → wff}
  (cbvmovw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wb (wmo (λ x3, ph x3)) (wmo (λ y, ps y)) :=
@«3bitri» (wmo (λ x3, ph x3)) (wex (λ z, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z))))) (wex (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z))))) (wmo (λ y, ps y))
  (@df_mo (λ x3, ph x3))
  (@exbii (λ z, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv z)))) (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z))))
    (λ z, @cbvalvw (λ x3, wi (ph x3) (wceq (cv x3) (cv z))) (λ y, wi (ps y) (wceq (cv y) (cv z)))
      (λ x3 y, @imbi12d (wceq (cv x3) (cv y)) (ph x3) (ps y) (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))
        (cbvmovw_1 x3 y)
        (@equequ1 z x3 y))))
  (@bicomi (wmo (λ y, ps y)) (wex (λ z, wal (λ y, wi (ps y) (wceq (cv y) (cv z)))))
    (@df_mo (λ y, ps y)))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbvmo with a
disjoint variable condition, which does not require ~ ax-10 , ~ ax-13 . (Contributed by NM,
9-Mar-1995.) (Revised by Gino Giotto, 23-May-2024.) -/
theorem cbvmow {ph ps : setvar → setvar → wff}
  (cbvmow_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbvmow_2 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (cbvmow_3 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (wmo (λ x3, ph x3 y)) (wmo (λ y, ps x3 y)) :=
@«3bitr4i» (wex (λ z, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z))))) (wex (λ z, wal (λ y, wi (ps x3 y) (wceq (cv y) (cv z))))) (wmo (λ x3, ph x3 y)) (wmo (λ y, ps x3 y))
  (@exbii (λ z, wal (λ x3, wi (ph x3 y) (wceq (cv x3) (cv z)))) (λ z, wal (λ y, wi (ps x3 y) (wceq (cv y) (cv z))))
    (λ z, @cbvalv1 (λ x3 y, wi (ph x3 y) (wceq (cv x3) (cv z))) (λ x3 y, wi (ps x3 y) (wceq (cv y) (cv z)))
      (λ x3, @nfim (λ y, ph x3 y) (λ y, wceq (cv x3) (cv z))
        (cbvmow_1 x3)
        (@nfv (wceq (cv x3) (cv z))))
      (λ y, @nfim (λ x3, ps x3 y) (λ x3, wceq (cv y) (cv z))
        (cbvmow_2 y)
        (@nfv (wceq (cv y) (cv z))))
      (λ x3 y, @imbi12d (wceq (cv x3) (cv y)) (ph x3 y) (ps x3 y) (wceq (cv x3) (cv z)) (wceq (cv y) (cv z))
        (cbvmow_3 x3 y)
        (@equequ1 z x3 y)) x3 y))
  (@df_mo (λ x3, ph x3 y))
  (@df_mo (λ y, ps x3 y))


/-- Change bound variable. Uses only Tarski's FOL axiom schemes. See ~ cbveu for a version with
fewer disjoint variable conditions but requiring more axioms. (Contributed by NM, 25-Nov-1994.)
(Revised by Gino Giotto, 30-Sep-2024.) -/
theorem cbveuvw {ph ps : setvar → wff}
  (cbveuvw_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wb (weu (λ x3, ph x3)) (weu (λ y, ps y)) :=
@«3bitr4i» (wa (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))) (wa (wex (λ y, ps y)) (wmo (λ y, ps y))) (weu (λ x3, ph x3)) (weu (λ y, ps y))
  (@anbi12i (wex (λ x3, ph x3)) (wex (λ y, ps y)) (wmo (λ x3, ph x3)) (wmo (λ y, ps y))
    (@cbvexvw (λ x3, ph x3) (λ y, ps y)
      (λ x3 y, cbveuvw_1 x3 y))
    (@cbvmovw (λ x3, ph x3) (λ y, ps y)
      (λ x3 y, cbveuvw_1 x3 y)))
  (@df_eu (λ x3, ph x3))
  (@df_eu (λ y, ps y))


/-- Version of ~ cbveu with a disjoint variable condition, which does not require ~ ax-10 , ~ ax-13
. (Contributed by NM, 25-Nov-1994.) (Revised by Gino Giotto, 23-May-2024.) -/
theorem cbveuw {ph ps : setvar → setvar → wff}
  (cbveuw_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbveuw_2 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (cbveuw_3 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wb (weu (λ x3, ph x3 y)) (weu (λ y, ps x3 y)) :=
@«3bitr4i» (wa (wex (λ x3, ph x3 y)) (wmo (λ x3, ph x3 y))) (wa (wex (λ y, ps x3 y)) (wmo (λ y, ps x3 y))) (weu (λ x3, ph x3 y)) (weu (λ y, ps x3 y))
  (@anbi12i (wex (λ x3, ph x3 y)) (wex (λ y, ps x3 y)) (wmo (λ x3, ph x3 y)) (wmo (λ y, ps x3 y))
    (@cbvexv1 (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
      (λ x3, cbveuw_1 x3)
      (λ y, cbveuw_2 y)
      (λ x3 y, cbveuw_3 x3 y) x3 y)
    (@cbvmow (λ x3 y, ph x3 y) (λ x3 y, ps x3 y)
      (λ x3, cbveuw_1 x3)
      (λ y, cbveuw_2 y)
      (λ x3 y, cbveuw_3 x3 y) x3 y))
  (@df_eu (λ x3, ph x3 y))
  (@df_eu (λ y, ps x3 y))


/-- Uniqueness using implicit substitution. (Contributed by NM, 26-Jul-1995.) -/
theorem eu4 {ph ps : setvar → wff}
  (eu4_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wb (weu (λ x3, ph x3)) (wa (wex (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y)))))) :=
@bitri (weu (λ x3, ph x3)) (wa (wex (λ x3, ph x3)) (wmo (λ x3, ph x3))) (wa (wex (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))))
  (@df_eu (λ x3, ph x3))
  (@anbi2i (wmo (λ x3, ph x3)) (wal (λ x3, wal (λ y, wi (wa (ph x3) (ps y)) (wceq (cv x3) (cv y))))) (wex (λ x3, ph x3))
    (@mo4 (λ x3, ph x3) (λ y, ps y)
      (λ x3 y, eu4_1 x3 y)))


/-- Existential uniqueness implies uniqueness through reverse implication. (Contributed by NM,
22-Apr-1995.) -/
theorem euimmo {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wi (ph x3) (ps x3))) (wi (weu (λ x3, ps x3)) (wmo (λ x3, ph x3))) :=
@syl5 (weu (λ x3, ps x3)) (wmo (λ x3, ps x3)) (wal (λ x3, wi (ph x3) (ps x3))) (wmo (λ x3, ph x3))
  (@eumo (λ x3, ps x3))
  (@moim (λ x3, ph x3) (λ x3, ps x3))


/-- Factor out the common proof skeleton of ~ moanimv and ~ moanim . (Contributed by NM,
3-Dec-2001.) (Proof shortened by Wolf Lammen, 24-Dec-2018.) Factor out common proof lines. (Revised
by Wolf Lammen, 8-Feb-2023.) -/
theorem moanimlem {ph ps : setvar → wff}
  (moanimlem_1 : ∀ x3, ⊦ wi (ph x3) (wb (wmo (λ x3, ps x3)) (wmo (λ x3, wa (ph x3) (ps x3)))))
  (moanimlem_2 : ∀ x3, ⊦ wi (wex (λ x3, wa (ph x3) (ps x3))) (ph x3))
  (x3 : setvar) : ⊦ wb (wmo (λ x3, wa (ph x3) (ps x3))) (wi (ph x3) (wmo (λ x3, ps x3))) :=
@impbii (wmo (λ x3, wa (ph x3) (ps x3))) (wi (ph x3) (wmo (λ x3, ps x3)))
  (@biimprcd (ph x3) (wmo (λ x3, ps x3)) (wmo (λ x3, wa (ph x3) (ps x3)))
    (moanimlem_1 x3))
  (@ja (ph x3) (wmo (λ x3, ps x3)) (wmo (λ x3, wa (ph x3) (ps x3)))
    (@nsyl5 (wex (λ x3, wa (ph x3) (ps x3))) (ph x3) (wmo (λ x3, wa (ph x3) (ps x3)))
      (moanimlem_2 x3)
      (@nexmo (λ x3, wa (ph x3) (ps x3))))
    (@moan (λ x3, ps x3) (λ x3, ph x3)))


/-- Introduction of a conjunct into an at-most-one quantifier. Version of ~ moanim requiring
disjoint variables, but fewer axioms. (Contributed by NM, 23-Mar-1995.) Reduce axiom usage .
(Revised by Wolf Lammen, 8-Feb-2023.) -/
theorem moanimv {ph : wff} {ps : setvar → wff} :
  ⊦ wb (wmo (λ x3, wa ph (ps x3))) (wi ph (wmo (λ x3, ps x3))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wmo (λ x3, wa ph (ps x3))) (wi ph (wmo (λ x3, ps x3))), from
  @moanimlem (λ x3, ph) (λ x3, ps x3)
    (λ x3, @mobidv ph (λ x3, ps x3) (λ x3, wa ph (ps x3))
      (λ x3, @ibar ph (ps x3)))
    (λ x3, @exlimiv (λ x3, wa ph (ps x3)) ph
      (λ x3, @simpl ph (ps x3))) x3


/-- Introduction of a conjunct into unique existential quantifier. (Contributed by NM, 23-Mar-1995.)
Reduce dependencies on axioms. (Revised by Wolf Lammen, 14-Jan-2023.) -/
theorem euanv {ph : wff} {ps : setvar → wff} :
  ⊦ wb (weu (λ x3, wa ph (ps x3))) (wa ph (weu (λ x3, ps x3))) :=
@impbii (weu (λ x3, wa ph (ps x3))) (wa ph (weu (λ x3, ps x3)))
  (@jcai (weu (λ x3, wa ph (ps x3))) ph (weu (λ x3, ps x3))
    (@syl (weu (λ x3, wa ph (ps x3))) (wex (λ x3, wa ph (ps x3))) ph
      (@euex (λ x3, wa ph (ps x3)))
      (@exlimiv (λ x3, wa ph (ps x3)) ph
        (λ x3, @simpl ph (ps x3))))
    (@biimprcd ph (weu (λ x3, ps x3)) (weu (λ x3, wa ph (ps x3)))
      (@eubidv ph (λ x3, ps x3) (λ x3, wa ph (ps x3))
        (λ x3, @ibar ph (ps x3)))))
  (@biimpa ph (weu (λ x3, ps x3)) (weu (λ x3, wa ph (ps x3)))
    (@eubidv ph (λ x3, ps x3) (λ x3, wa ph (ps x3))
      (λ x3, @ibar ph (ps x3))))


/-- "At most one" picks a variable value, eliminating an existential quantifier. (Contributed by NM,
27-Jan-1997.) (Proof shortened by Wolf Lammen, 17-Sep-2019.) -/
theorem mopick {ph ps : setvar → wff}
  (x3 : setvar) : ⊦ wi (wa (wmo (λ x3, ph x3)) (wex (λ x3, wa (ph x3) (ps x3)))) (wi (ph x3) (ps x3)) :=
@imp (wmo (λ x3, ph x3)) (wex (λ x3, wa (ph x3) (ps x3))) (wi (ph x3) (ps x3))
  (@sylbi (wmo (λ x3, ph x3)) (wex (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y))))) (wi (wex (λ x3, wa (ph x3) (ps x3))) (wi (ph x3) (ps x3)))
    (@df_mo (λ x3, ph x3))
    (@exlimiv (λ y, wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (wi (wex (λ x3, wa (ph x3) (ps x3))) (wi (ph x3) (ps x3)))
      (λ y, @syl5d (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (ph x3) (wceq (cv x3) (cv y)) (wex (λ x3, wa (ph x3) (ps x3))) (ps x3)
        (@sp (λ x3, wi (ph x3) (wceq (cv x3) (cv y))) x3)
        (@syl6 (wal (λ x3, wi (ph x3) (wceq (cv x3) (cv y)))) (wex (λ x3, wa (ph x3) (ps x3))) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ps x3))) (wi (wceq (cv x3) (cv y)) (ps x3))
          (@aleximi (λ x3, wi (ph x3) (wceq (cv x3) (cv y))) (λ x3, wa (ph x3) (ps x3)) (λ x3, wa (wceq (cv x3) (cv y)) (ps x3))
            (λ x3, @pm3_45 (ph x3) (wceq (cv x3) (cv y)) (ps x3)))
          (@sylbi (wex (λ x3, wa (wceq (cv x3) (cv y)) (ps x3))) (wal (λ x3, wi (wceq (cv x3) (cv y)) (ps x3))) (wi (wceq (cv x3) (cv y)) (ps x3))
            (@sbalex (λ x3 y, ps x3) y)
            (@sp (λ x3, wi (wceq (cv x3) (cv y)) (ps x3)) x3))))))


/-- Factor out the proof skeleton of ~ moexex and ~ moexexvw . (Contributed by Wolf Lammen,
2-Oct-2023.) -/
theorem moexexlem {ph ps : setvar → setvar → wff}
  (moexexlem_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (moexexlem_2 : ⊦ wnf (λ y, wmo (λ x3, ph x3 y)))
  (moexexlem_3 : ⊦ wnf (λ x3, wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))))
  (y : setvar) : ⊦ wi (wa (wmo (λ x3, ph x3 y)) (wal (λ x3, wmo (λ y, ps x3 y)))) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))) :=
@imp (wmo (λ x3, ph x3 y)) (wal (λ x3, wmo (λ y, ps x3 y))) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y))))
  (@pm2_61d1 (wmo (λ x3, ph x3 y)) (wex (λ x3, ph x3 y)) (wi (wal (λ x3, wmo (λ y, ps x3 y))) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))))
    (setvar.forget $ λ x3 : setvar,
      show ⊦ wi (wmo (λ x3, ph x3 y)) (wi (wex (λ x3, ph x3 y)) (wi (wal (λ x3, wmo (λ y, ps x3 y))) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))))), from
      @exlimd (λ x3, wmo (λ x3, ph x3 y)) (λ x3, ph x3 y) (λ x3, wi (wal (λ x3, wmo (λ y, ps x3 y))) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))))
        (@nfmo1 (λ x3, ph x3 y))
        (@nfim (λ x3, wal (λ x3, wmo (λ y, ps x3 y))) (λ x3, wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y))))
          (@nfa1 (λ x3, wmo (λ y, ps x3 y)))
          moexexlem_3)
        (λ x3, @syl6 (wmo (λ x3, ph x3 y)) (ph x3 y) (wal (λ y, wi (wex (λ x3, wa (ph x3 y) (ps x3 y))) (ps x3 y))) (wi (wal (λ x3, wmo (λ y, ps x3 y))) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))))
          (@alrimd (λ y, wmo (λ x3, ph x3 y)) (λ y, ph x3 y) (λ y, wi (wex (λ x3, wa (ph x3 y) (ps x3 y))) (ps x3 y))
            moexexlem_2
            (moexexlem_1 x3)
            (λ y, @com23 (wmo (λ x3, ph x3 y)) (wex (λ x3, wa (ph x3 y) (ps x3 y))) (ph x3 y) (ps x3 y)
              (@ex (wmo (λ x3, ph x3 y)) (wex (λ x3, wa (ph x3 y) (ps x3 y))) (wi (ph x3 y) (ps x3 y))
                (@mopick (λ x3, ph x3 y) (λ x3, ps x3 y) x3))) y)
          (@spsd (λ x3, wal (λ y, wi (wex (λ x3, wa (ph x3 y) (ps x3 y))) (ps x3 y))) (λ x3, wmo (λ y, ps x3 y)) (λ x3, wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y))))
            (λ x3, @moim (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y))) (λ y, ps x3 y)) x3)) x3)
    (@a1d (wn (wex (λ x3, ph x3 y))) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))) (wal (λ x3, wmo (λ y, ps x3 y)))
      (@nsyl5 (wex (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))) (wex (λ x3, ph x3 y)) (wmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y))))
        (@exlimi (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y))) (λ y, wex (λ x3, ph x3 y))
          (@nfex (λ y x3, ph x3 y)
            (λ x3, moexexlem_1 x3))
          (λ y, @exsimpl (λ x3, ph x3 y) (λ x3, ps x3 y)) y)
        (@nexmo (λ y, wex (λ x3, wa (ph x3 y) (ps x3 y)))))))


/-- "At most one" double quantification. Version of ~ moexexv with an additional disjoint variable
condition, which does not require ~ ax-13 . (Contributed by NM, 26-Jan-1997.) (Revised by Gino
Giotto, 22-Aug-2023.) Factor out common proof lines with ~ moexex . (Revised by Wolf Lammen,
2-Oct-2023.) -/
theorem moexexvw {ph : setvar → wff} {ps : setvar → setvar → wff} :
  ⊦ wi (wa (wmo (λ x3, ph x3)) (wal (λ x3, wmo (λ y, ps x3 y)))) (wmo (λ y, wex (λ x3, wa (ph x3) (ps x3 y)))) :=
setvar.forget $ λ y : setvar,
  show ⊦ wi (wa (wmo (λ x3, ph x3)) (wal (λ x3, wmo (λ y, ps x3 y)))) (wmo (λ y, wex (λ x3, wa (ph x3) (ps x3 y)))), from
  @moexexlem (λ x3 y, ph x3) (λ x3 y, ps x3 y)
    (λ x3, @nfv (ph x3))
    (@nfv (wmo (λ x3, ph x3)))
    (@nfmov (λ x3 y, wex (λ x3, wa (ph x3) (ps x3 y)))
      (λ y, @nfe1 (λ x3, wa (ph x3) (ps x3 y)))) y


/-- A condition allowing to swap an existential quantifier and at at-most-one quantifier. Version of
~ 2moswap with a disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM,
10-Apr-2004.) (Revised by Gino Giotto, 22-Aug-2023.) Factor out common proof lines with ~ moexexvw .
(Revised by Wolf Lammen, 2-Oct-2023.) -/
theorem «2moswapv» {ph : setvar → setvar → wff} :
  ⊦ wi (wal (λ x3, wmo (λ y, ph x3 y))) (wi (wmo (λ x3, wex (λ y, ph x3 y))) (wmo (λ y, wex (λ x3, ph x3 y)))) :=
@syl6ibr (wal (λ x3, wmo (λ y, ph x3 y))) (wmo (λ x3, wex (λ y, ph x3 y))) (wmo (λ y, wex (λ x3, wa (wex (λ y, ph x3 y)) (ph x3 y)))) (wmo (λ y, wex (λ x3, ph x3 y)))
  (@expcom (wmo (λ x3, wex (λ y, ph x3 y))) (wal (λ x3, wmo (λ y, ph x3 y))) (wmo (λ y, wex (λ x3, wa (wex (λ y, ph x3 y)) (ph x3 y))))
    (setvar.forget $ λ y : setvar,
      show ⊦ wi (wa (wmo (λ x3, wex (λ y, ph x3 y))) (wal (λ x3, wmo (λ y, ph x3 y)))) (wmo (λ y, wex (λ x3, wa (wex (λ y, ph x3 y)) (ph x3 y)))), from
      @moexexlem (λ x3 y, wex (λ y, ph x3 y)) (λ x3 y, ph x3 y)
        (λ x3, @nfe1 (λ y, ph x3 y))
        (@nfmov (λ y x3, wex (λ y, ph x3 y))
          (λ x3, @nfe1 (λ y, ph x3 y)))
        (@nfmov (λ x3 y, wex (λ x3, wa (wex (λ y, ph x3 y)) (ph x3 y)))
          (λ y, @nfe1 (λ x3, wa (wex (λ y, ph x3 y)) (ph x3 y)))) y))
  (@mobii (λ y, wex (λ x3, ph x3 y)) (λ y, wex (λ x3, wa (wex (λ y, ph x3 y)) (ph x3 y)))
    (λ y, @exbii (λ x3, ph x3 y) (λ x3, wa (wex (λ y, ph x3 y)) (ph x3 y))
      (λ x3, @pm4_71ri (ph x3 y) (wex (λ y, ph x3 y))
        (@«19_8a» (λ y, ph x3 y) y))))


/-- A condition allowing to swap an existential quantifier and a unique existential quantifier.
Version of ~ 2euswap with a disjoint variable condition, which does not require ~ ax-13 .
(Contributed by NM, 10-Apr-2004.) (Revised by Gino Giotto, 22-Aug-2023.) -/
theorem «2euswapv» {ph : setvar → setvar → wff} :
  ⊦ wi (wal (λ x3, wmo (λ y, ph x3 y))) (wi (weu (λ x3, wex (λ y, ph x3 y))) (weu (λ y, wex (λ x3, ph x3 y)))) :=
@«3imtr4g» (wal (λ x3, wmo (λ y, ph x3 y))) (wa (wex (λ x3, wex (λ y, ph x3 y))) (wmo (λ x3, wex (λ y, ph x3 y)))) (wa (wex (λ y, wex (λ x3, ph x3 y))) (wmo (λ y, wex (λ x3, ph x3 y)))) (weu (λ x3, wex (λ y, ph x3 y))) (weu (λ y, wex (λ x3, ph x3 y)))
  (@anim12d (wal (λ x3, wmo (λ y, ph x3 y))) (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ y, wex (λ x3, ph x3 y))) (wmo (λ x3, wex (λ y, ph x3 y))) (wmo (λ y, wex (λ x3, ph x3 y)))
    (@a1i (wi (wex (λ x3, wex (λ y, ph x3 y))) (wex (λ y, wex (λ x3, ph x3 y)))) (wal (λ x3, wmo (λ y, ph x3 y)))
      (@excomim (λ x3 y, ph x3 y)))
    (@«2moswapv» (λ x3 y, ph x3 y)))
  (@df_eu (λ x3, wex (λ y, ph x3 y)))
  (@df_eu (λ y, wex (λ x3, ph x3 y)))


/-- Existential uniqueness "picks" a variable value for which another wff is true. If there is only
one thing ` x ` such that ` ph ` is true, and there is also an ` x ` (actually the same one) such
that ` ph ` and ` ps ` are both true, then ` ph ` implies ` ps ` regardless of ` x ` . This theorem
can be useful for eliminating existential quantifiers in a hypothesis. Compare Theorem *14.26 in
[WhiteheadRussell] p. 192. (Contributed by NM, 10-Jul-1994.) -/
theorem eupick {ph ps : setvar → wff}
  (x3 : setvar) : ⊦ wi (wa (weu (λ x3, ph x3)) (wex (λ x3, wa (ph x3) (ps x3)))) (wi (ph x3) (ps x3)) :=
@sylan (weu (λ x3, ph x3)) (wmo (λ x3, ph x3)) (wex (λ x3, wa (ph x3) (ps x3))) (wi (ph x3) (ps x3))
  (@eumo (λ x3, ph x3))
  (@mopick (λ x3, ph x3) (λ x3, ps x3) x3)


-- /-- Axiom of extensionality. An axiom of Zermelo-Fraenkel set theory. It states that two sets are
-- identical if they contain the same elements. Axiom Ext of [BellMachover] p. 461. Its converse is
-- a theorem of predicate logic, ~ elequ2g . Set theory can also be formulated with a _single_
-- primitive predicate ` e. ` on top of traditional predicate calculus _without_ equality. In that
-- case the Axiom of Extensionality becomes ` ( A. w ( w e. x <-> w e. y ) -> ( x e. z -> y e. z ) )
-- ` , and equality ` x = y ` is _defined_ as ` A. w ( w e. x <-> w e. y ) ` . All of the usual
-- axioms of equality then become theorems of set theory. See, for example, Axiom 1 of
-- [TakeutiZaring] p. 8. To use the above "equality-free" version of Extensionality with Metamath's
-- predicate calculus axioms, we would rewrite all axioms involving equality with equality expanded
-- according to the above definition. Some of those axioms may be provable from ax-ext and would
-- become redundant, but this hasn't been studied carefully. _General remarks_: Our set theory
-- axioms are presented using defined connectives ( ` <-> ` , ` E. ` , etc.) for convenience.
-- However, it is implicitly understood that the actual axioms use only the primitive connectives `
-- -> ` , ` -. ` , ` A. ` , ` = ` , and ` e. ` . It is straightforward to establish the equivalence
-- between the actual axioms and the ones we display, and we will not do so. It is important to
-- understand that strictly speaking, all of our set theory axioms are really schemes that represent
-- an infinite number of actual axioms. This is inherent in the design of Metamath ("metavariable
-- math"), which manipulates only metavariables. For example, the metavariable ` x ` in ~ ax-ext can
-- represent any actual variable _v1_, _v2_, _v3_,... . Distinct variable restrictions ($d) prevent
-- us from substituting say _v1_ for both ` x ` and ` z ` . This is in contrast to typical textbook
-- presentations that present actual axioms (except for Replacement ~ ax-rep , which involves a wff
-- metavariable). In practice, though, the theorems and proofs are essentially the same. The $d
-- restrictions make each of the infinite axioms generated by the ~ ax-ext scheme exactly logically
-- equivalent to each other and in particular to the actual axiom of the textbook version.
-- (Contributed by NM, 21-May-1993.) -/
-- axiom ax_ext {x3 y : setvar} : ⊦ wi (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))) (wceq (cv x3) (cv y))


/-- A generalization of the axiom of extensionality in which ` x ` and ` y ` need not be distinct.
(Contributed by NM, 15-Sep-1993.) (Proof shortened by Andrew Salmon, 12-Aug-2011.) Remove
dependencies on ~ ax-10 , ~ ax-12 , ~ ax-13 . (Revised by BJ, 12-Jul-2019.) (Revised by Wolf Lammen,
9-Dec-2019.) -/
theorem axextg {y : setvar}
  (x3 : setvar) : ⊦ wi (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))) (wceq (cv x3) (cv y)) :=
@chvarvv (λ w x3, wi (wal (λ z, wb (wcel (cv z) (cv w)) (wcel (cv z) (cv y)))) (wceq (cv w) (cv y))) (λ x3, wi (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))) (wceq (cv x3) (cv y)))
  (λ w x3, @imbi12d (wceq (cv w) (cv x3)) (wal (λ z, wb (wcel (cv z) (cv w)) (wcel (cv z) (cv y)))) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))) (wceq (cv w) (cv y)) (wceq (cv x3) (cv y))
    (@albidv (wceq (cv w) (cv x3)) (λ z, wb (wcel (cv z) (cv w)) (wcel (cv z) (cv y))) (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))
      (λ z, @bibi1d (wceq (cv w) (cv x3)) (wcel (cv z) (cv w)) (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))
        (@elequ2 z w x3)))
    (@equequ1 y w x3))
  (λ w x3, @ax_ext w y) x3


/-- A generalization of the axiom of extensionality in which ` x ` and ` y ` need not be distinct.
(Contributed by NM, 15-Sep-1993.) (Proof shortened by Andrew Salmon, 12-Aug-2011.) Remove
dependencies on ~ ax-10 , ~ ax-12 , ~ ax-13 . (Revised by BJ, 12-Jul-2019.) (Revised by Wolf Lammen,
9-Dec-2019.) -/
theorem axextg_b
  (x3 : setvar) : ⊦ wi (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))) (wceq (cv x3) (cv x3)) :=
@chvarvv (λ w x3, wi (wal (λ z, wb (wcel (cv z) (cv w)) (wcel (cv z) (cv x3)))) (wceq (cv w) (cv x3))) (λ x3, wi (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))) (wceq (cv x3) (cv x3)))
  (λ w x3, @imbi12d (wceq (cv w) (cv x3)) (wal (λ z, wb (wcel (cv z) (cv w)) (wcel (cv z) (cv x3)))) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))) (wceq (cv w) (cv x3)) (wceq (cv x3) (cv x3))
    (@albidv (wceq (cv w) (cv x3)) (λ z, wb (wcel (cv z) (cv w)) (wcel (cv z) (cv x3))) (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))
      (λ z, @bibi1d (wceq (cv w) (cv x3)) (wcel (cv z) (cv w)) (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3))
        (@elequ2 z w x3)))
    (@equequ1_b1 w x3))
  (λ w x3, @ax_ext w x3) x3


/-- A bidirectional version of the axiom of extensionality. Although this theorem looks like a
definition of equality, it requires the axiom of extensionality for its proof under our
axiomatization. See the comments for ~ ax-ext and ~ df-cleq . (Contributed by NM, 14-Nov-2008.) -/
theorem axextb
  (x3 y : setvar) : ⊦ wb (wceq (cv x3) (cv y)) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)))) :=
@impbii (wceq (cv x3) (cv y)) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv y))))
  (@elequ2g x3 y)
  (@axextg y x3)


/-- A bidirectional version of the axiom of extensionality. Although this theorem looks like a
definition of equality, it requires the axiom of extensionality for its proof under our
axiomatization. See the comments for ~ ax-ext and ~ df-cleq . (Contributed by NM, 14-Nov-2008.) -/
theorem axextb_b
  (x3 : setvar) : ⊦ wb (wceq (cv x3) (cv x3)) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3)))) :=
@impbii (wceq (cv x3) (cv x3)) (wal (λ z, wb (wcel (cv z) (cv x3)) (wcel (cv z) (cv x3))))
  (@elequ2g_b x3)
  (@axextg_b x3)


-- /-- Introduce the class abstraction (or class builder) notation: ` { x | ph } ` is the class of
-- sets ` x ` such that ` ph ( x ) ` is true. A setvar variable can be expressed as a class
-- abstraction per Theorem ~ cvjust , justifying the substitution of class variables for setvar
-- variables via the use of ~ cv . -/
-- constant cab : (setvar → wff) → «class»


-- /-- Define class abstractions, that is, classes of the form ` { y | ph } ` , which is read "the
-- class of sets ` y ` such that ` ph ( y ) ` ". A few remarks are in order: 1. The axiomatic
-- statement ~ df-clab does not define the class abstraction ` { y | ph } ` itself, that is, it does
-- not have the form ` |- { y | ph } = ... ` that a standard definition should have (for a good
-- reason: equality itself has not yet been defined or axiomatized for class abstractions; it is
-- defined later in ~ df-cleq ). Instead, ~ df-clab has the form ` |- ( x e. { y | ph } <-> ... ) `
-- , meaning that it only defines what it means for a setvar to be a member of a class abstraction.
-- As a consequence, one can say that ~ df-clab defines class abstractions if and only if a class
-- abstraction is completely determined by which elements belong to it, which is the content of the
-- axiom of extensionality ~ ax-ext . Therefore, ~ df-clab can be considered a definition only in
-- systems that can prove ~ ax-ext (and the necessary first-order logic). 2. As in all definitions,
-- the definiendum (the left-hand side of the biconditional) has no disjoint variable conditions. In
-- particular, the setvar variables ` x ` and ` y ` need not be distinct, and the formula ` ph ` may
-- depend on both ` x ` and ` y ` . This is necessary, as with all definitions, since if there was
-- for instance a disjoint variable condition on ` x , y ` , then one could not do anything with
-- expressions like ` x e. { x | ph } ` which are sometimes useful to shorten proofs (because of ~
-- abid ). Most often, however, ` x ` does not occur in ` { y | ph } ` and ` y ` is free in ` ph ` .
-- 3. Remark 1 stresses that ~ df-clab does not have the standard form of a definition for a class,
-- but one could be led to think it has the standard form of a definition for a formula. However, it
-- also fails that test since the membership predicate ` e. ` has already appeared earlier (e.g., in
-- the non-syntactic statement ~ ax-8 ). Indeed, the definiendum extends, or "overloads", the
-- membership predicate ` e. ` from formulas of the form "setvar ` e. ` setvar" to formulas of the
-- form "setvar ` e. ` class abstraction". This is possible because of ~ wcel and ~ cab , and it can
-- be called an "extension" of the membership predicate because of ~ wel , whose proof uses ~ cv .
-- An a posteriori justification for ~ cv is given by ~ cvjust , stating that every setvar can be
-- written as a class abstraction (though conversely not every class abstraction is a set, as
-- illustrated by Russell's paradox ~ ru ). 4. Proof techniques. Because class variables can be
-- substituted with compound expressions and setvar variables cannot, it is often useful to convert
-- a theorem containing a free setvar variable to a more general version with a class variable. This
-- is done with theorems such as ~ vtoclg which is used, for example, to convert ~ elirrv to ~ elirr
-- . 5. Definition or axiom? The question arises with the three axiomatic statements introducing
-- classes, ~ df-clab , ~ df-cleq , and ~ df-clel , to decide if they qualify as definitions or if
-- they should be called axioms. Under the strict definition of "definition" (see ~ conventions ),
-- they are not definitions (see Remarks 1 and 3 above, and similarly for ~ df-cleq and ~ df-clel ).
-- One could be less strict and decide to call "definition" every axiomatic statement which provides
-- an eliminable and conservative extension of the considered axiom system. But the notion of
-- conservativity may be given two different meanings in set.mm, due to the difference between the
-- "scheme level" of set.mm and the "object level" of classical treatments. For a proof that these
-- three axiomatic statements yield an eliminable and weakly (that is, object-level) conservative
-- extension of FOL= plus ~ ax-ext , see Appendix of [Levy] p. 357. 6. References and history. The
-- concept of class abstraction dates back to at least Frege, and is used by Whitehead and Russell.
-- This definition is Definition 2.1 of [Quine] p. 16 and Axiom 4.3.1 of [Levy] p. 12. It is called
-- the "axiom of class comprehension" by [Levy] p. 358, who treats the theory of classes as an
-- extralogical extension to predicate logic and set theory axioms. He calls the construction ` { y
-- | ph } ` a "class term". For a full description of how classes are introduced and how to recover
-- the primitive language, see the books of Quine and Levy (and the comment of ~ abeq2 for a quick
-- overview). For a general discussion of the theory of classes, see ~ mmset.html#class .
-- (Contributed by NM, 26-May-1993.) (Revised by BJ, 19-Aug-2023.) -/
-- axiom df_clab {ph : setvar → wff} {x3 : setvar} : ⊦ wb (wcel (cv x3) (cab (λ y, ph y))) (wsb (λ y, ph y) x3)


-- /-- Define class abstractions, that is, classes of the form ` { y | ph } ` , which is read "the
-- class of sets ` y ` such that ` ph ( y ) ` ". A few remarks are in order: 1. The axiomatic
-- statement ~ df-clab does not define the class abstraction ` { y | ph } ` itself, that is, it does
-- not have the form ` |- { y | ph } = ... ` that a standard definition should have (for a good
-- reason: equality itself has not yet been defined or axiomatized for class abstractions; it is
-- defined later in ~ df-cleq ). Instead, ~ df-clab has the form ` |- ( x e. { y | ph } <-> ... ) `
-- , meaning that it only defines what it means for a setvar to be a member of a class abstraction.
-- As a consequence, one can say that ~ df-clab defines class abstractions if and only if a class
-- abstraction is completely determined by which elements belong to it, which is the content of the
-- axiom of extensionality ~ ax-ext . Therefore, ~ df-clab can be considered a definition only in
-- systems that can prove ~ ax-ext (and the necessary first-order logic). 2. As in all definitions,
-- the definiendum (the left-hand side of the biconditional) has no disjoint variable conditions. In
-- particular, the setvar variables ` x ` and ` y ` need not be distinct, and the formula ` ph ` may
-- depend on both ` x ` and ` y ` . This is necessary, as with all definitions, since if there was
-- for instance a disjoint variable condition on ` x , y ` , then one could not do anything with
-- expressions like ` x e. { x | ph } ` which are sometimes useful to shorten proofs (because of ~
-- abid ). Most often, however, ` x ` does not occur in ` { y | ph } ` and ` y ` is free in ` ph ` .
-- 3. Remark 1 stresses that ~ df-clab does not have the standard form of a definition for a class,
-- but one could be led to think it has the standard form of a definition for a formula. However, it
-- also fails that test since the membership predicate ` e. ` has already appeared earlier (e.g., in
-- the non-syntactic statement ~ ax-8 ). Indeed, the definiendum extends, or "overloads", the
-- membership predicate ` e. ` from formulas of the form "setvar ` e. ` setvar" to formulas of the
-- form "setvar ` e. ` class abstraction". This is possible because of ~ wcel and ~ cab , and it can
-- be called an "extension" of the membership predicate because of ~ wel , whose proof uses ~ cv .
-- An a posteriori justification for ~ cv is given by ~ cvjust , stating that every setvar can be
-- written as a class abstraction (though conversely not every class abstraction is a set, as
-- illustrated by Russell's paradox ~ ru ). 4. Proof techniques. Because class variables can be
-- substituted with compound expressions and setvar variables cannot, it is often useful to convert
-- a theorem containing a free setvar variable to a more general version with a class variable. This
-- is done with theorems such as ~ vtoclg which is used, for example, to convert ~ elirrv to ~ elirr
-- . 5. Definition or axiom? The question arises with the three axiomatic statements introducing
-- classes, ~ df-clab , ~ df-cleq , and ~ df-clel , to decide if they qualify as definitions or if
-- they should be called axioms. Under the strict definition of "definition" (see ~ conventions ),
-- they are not definitions (see Remarks 1 and 3 above, and similarly for ~ df-cleq and ~ df-clel ).
-- One could be less strict and decide to call "definition" every axiomatic statement which provides
-- an eliminable and conservative extension of the considered axiom system. But the notion of
-- conservativity may be given two different meanings in set.mm, due to the difference between the
-- "scheme level" of set.mm and the "object level" of classical treatments. For a proof that these
-- three axiomatic statements yield an eliminable and weakly (that is, object-level) conservative
-- extension of FOL= plus ~ ax-ext , see Appendix of [Levy] p. 357. 6. References and history. The
-- concept of class abstraction dates back to at least Frege, and is used by Whitehead and Russell.
-- This definition is Definition 2.1 of [Quine] p. 16 and Axiom 4.3.1 of [Levy] p. 12. It is called
-- the "axiom of class comprehension" by [Levy] p. 358, who treats the theory of classes as an
-- extralogical extension to predicate logic and set theory axioms. He calls the construction ` { y
-- | ph } ` a "class term". For a full description of how classes are introduced and how to recover
-- the primitive language, see the books of Quine and Levy (and the comment of ~ abeq2 for a quick
-- overview). For a general discussion of the theory of classes, see ~ mmset.html#class .
-- (Contributed by NM, 26-May-1993.) (Revised by BJ, 19-Aug-2023.) -/
-- axiom df_clab_b {ph : setvar → wff} : ∀ y, ⊦ wb (wcel (cv y) (cab (λ y, ph y))) (wsb (λ y, ph y) y)


/-- Extension (in the sense of Remark 3 of the comment of ~ df-clab ) of ~ elequ1 from formulas of
the form "setvar ` e. ` setvar" to formulas of the form "setvar ` e. ` class abstraction". This
extension does not require ~ ax-8 contrary to ~ elequ1 , but recall from Remark 3 of the comment of
~ df-clab that it can be considered an extension only because of ~ cvjust , which does require ~
ax-8 . This is an instance of ~ eleq1w where the containing class is a class abstraction, and
contrary to it, it can be proved without ~ df-clel . See also ~ eleq1 for general classes. The
straightforward yet important fact that this statement can be proved from FOL= plus ~ df-clab (hence
without ~ ax-ext , ~ df-cleq or ~ df-clel ) was stressed by Mario Carneiro. (Contributed by BJ,
17-Aug-2023.) -/
theorem eleq1ab {ph : setvar → setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv x3) (cab (λ z, ph x3 y z))) (wcel (cv y) (cab (λ z, ph x3 y z)))) :=
@«3bitr4g» (wceq (cv x3) (cv y)) (wsb (λ z, ph x3 y z) x3) (wsb (λ z, ph x3 y z) y) (wcel (cv x3) (cab (λ z, ph x3 y z))) (wcel (cv y) (cab (λ z, ph x3 y z)))
  (@sbequ (λ x3 y z, ph x3 y z) x3 y)
  (@df_clab (λ z, ph x3 y z) x3)
  (@df_clab (λ z, ph x3 y z) y)


/-- Extension (in the sense of Remark 3 of the comment of ~ df-clab ) of ~ elequ1 from formulas of
the form "setvar ` e. ` setvar" to formulas of the form "setvar ` e. ` class abstraction". This
extension does not require ~ ax-8 contrary to ~ elequ1 , but recall from Remark 3 of the comment of
~ df-clab that it can be considered an extension only because of ~ cvjust , which does require ~
ax-8 . This is an instance of ~ eleq1w where the containing class is a class abstraction, and
contrary to it, it can be proved without ~ df-clel . See also ~ eleq1 for general classes. The
straightforward yet important fact that this statement can be proved from FOL= plus ~ df-clab (hence
without ~ ax-ext , ~ df-cleq or ~ df-clel ) was stressed by Mario Carneiro. (Contributed by BJ,
17-Aug-2023.) -/
theorem eleq1ab_b {ph : setvar → setvar → wff}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv x3) (cab (λ y, ph x3 y))) (wcel (cv y) (cab (λ y, ph x3 y)))) :=
@«3bitr4g» (wceq (cv x3) (cv y)) (wsb (λ y, ph x3 y) x3) (wsb (λ y, ph x3 y) y) (wcel (cv x3) (cab (λ y, ph x3 y))) (wcel (cv y) (cab (λ y, ph x3 y)))
  (@sbequ_b1 (λ x3 y, ph x3 y) x3 y)
  (@df_clab (λ y, ph x3 y) x3)
  (@df_clab_b (λ y, ph x3 y) y)


/-- Simplification of class abstraction notation when the free and bound variables are identical.
(Contributed by NM, 26-May-1993.) -/
theorem abid {ph : setvar → wff}
  (x3 : setvar) : ⊦ wb (wcel (cv x3) (cab (λ x3, ph x3))) (ph x3) :=
@bitri (wcel (cv x3) (cab (λ x3, ph x3))) (wsb (λ x3, ph x3) x3) (ph x3)
  (@df_clab_b (λ x3, ph x3) x3)
  (@sbid (λ x3, ph x3) x3)


/-- If ` ph ` is a theorem, then any set belongs to the class ` { x | ph } ` . Therefore, ` { x | ph
} ` is "a" universal class. This is the closest one can get to defining a universal class, or
proving ~ vex , without using ~ ax-ext . Note that this theorem has no disjoint variable condition
and does not use ~ df-clel nor ~ df-cleq either: only propositional logic and ~ ax-gen and ~ df-clab
. This is ~ sbt expressed using class abstractions. Without ~ ax-ext , one cannot define "the"
universal class, since one could not prove for instance the justification theorem ` { x | T. } = { y
| T. } ` (see ~ vjust ). Indeed, in order to prove any equality of classes, one needs ~ df-cleq ,
which has ~ ax-ext as a hypothesis. Therefore, the classes ` { x | T. } ` , ` { y | ( ph -> ph ) } `
, ` { z | ( A. t t = t -> A. t t = t ) } ` and countless others are all universal classes whose
equality cannot be proved without ~ ax-ext . Once ~ dfcleq is available, we will define "the"
universal class in ~ df-v . Its degenerate instance is also a simple consequence of ~ abid (using ~
mpbir ). (Contributed by BJ, 13-Jun-2019.) Reduce axiom dependencies. (Revised by Steven Nguyen,
25-Apr-2023.) -/
theorem vexw {ph : setvar → wff} {y : setvar}
  (vexw_1 : ∀ x3, ⊦ ph x3) :
  ⊦ wcel (cv y) (cab (λ x3, ph x3)) :=
@mpbir (wcel (cv y) (cab (λ x3, ph x3))) (wsb (λ x3, ph x3) y)
  (@sbt (λ x3, ph x3) y
    (λ x3, vexw_1 x3))
  (@df_clab (λ x3, ph x3) y)


/-- If ` ph ` is a theorem, then any set belongs to the class ` { x | ph } ` . Therefore, ` { x | ph
} ` is "a" universal class. This is the closest one can get to defining a universal class, or
proving ~ vex , without using ~ ax-ext . Note that this theorem has no disjoint variable condition
and does not use ~ df-clel nor ~ df-cleq either: only propositional logic and ~ ax-gen and ~ df-clab
. This is ~ sbt expressed using class abstractions. Without ~ ax-ext , one cannot define "the"
universal class, since one could not prove for instance the justification theorem ` { x | T. } = { y
| T. } ` (see ~ vjust ). Indeed, in order to prove any equality of classes, one needs ~ df-cleq ,
which has ~ ax-ext as a hypothesis. Therefore, the classes ` { x | T. } ` , ` { y | ( ph -> ph ) } `
, ` { z | ( A. t t = t -> A. t t = t ) } ` and countless others are all universal classes whose
equality cannot be proved without ~ ax-ext . Once ~ dfcleq is available, we will define "the"
universal class in ~ df-v . Its degenerate instance is also a simple consequence of ~ abid (using ~
mpbir ). (Contributed by BJ, 13-Jun-2019.) Reduce axiom dependencies. (Revised by Steven Nguyen,
25-Apr-2023.) -/
theorem vexw_b {ph : setvar → wff}
  (vexw_1 : ∀ x3, ⊦ ph x3)
  (x3 : setvar) : ⊦ wcel (cv x3) (cab (λ x3, ph x3)) :=
@mpbir (wcel (cv x3) (cab (λ x3, ph x3))) (wsb (λ x3, ph x3) x3)
  (@sbt_b (λ x3, ph x3)
    (λ x3, vexw_1 x3) x3)
  (@df_clab_b (λ x3, ph x3) x3)


/-- Every setvar is a member of ` { x | T. } ` , which is therefore "a" universal class. Once class
extensionality ~ dfcleq is available, we can say "the" universal class (see ~ df-v ). This is ~
sbtru expressed using class abstractions. (Contributed by BJ, 2-Sep-2023.) -/
theorem vextru {y : setvar} :
  ⊦ wcel (cv y) (cab (λ x3, wtru)) :=
@vexw (λ x3, wtru) y
  (λ x3, tru)


/-- Every setvar is a member of ` { x | T. } ` , which is therefore "a" universal class. Once class
extensionality ~ dfcleq is available, we can say "the" universal class (see ~ df-v ). This is ~
sbtru expressed using class abstractions. (Contributed by BJ, 2-Sep-2023.) -/
theorem vextru_b
  (x3 : setvar) : ⊦ wcel (cv x3) (cab (λ x3, wtru)) :=
@vexw_b (λ x3, wtru)
  (λ x3, tru) x3


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by NM, 26-May-1993.) -/
theorem hbab1 {ph : setvar → setvar → wff}
  (y : setvar) : ⊦ wi (wcel (cv y) (cab (λ x3, ph x3 y))) (wal (λ x3, wcel (cv y) (cab (λ x3, ph x3 y)))) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wcel (cv y) (cab (λ x3, ph x3 y))) (wal (λ x3, wcel (cv y) (cab (λ x3, ph x3 y)))), from
  @hbxfrbi (λ x3, wcel (cv y) (cab (λ x3, ph x3 y))) (λ x3, wsb (λ x3, ph x3 y) y)
    (λ x3, @df_clab (λ x3, ph x3 y) y)
    (λ x3, @hbs1 (λ x3 y, ph x3 y) y) x3


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by Mario Carneiro,
11-Aug-2016.) Remove use of ~ ax-12 . (Revised by SN, 20-Sep-2023.) -/
theorem nfsab1 {ph : setvar → setvar → wff}
  (y : setvar) : ⊦ wnf (λ x3, wcel (cv y) (cab (λ x3, ph x3 y))) :=
@nfxfr (λ x3, wcel (cv y) (cab (λ x3, ph x3 y))) (λ x3, wsb (λ x3, ph x3 y) y)
  (λ x3, @df_clab (λ x3, ph x3 y) y)
  (@nfs1v (λ x3 y, ph x3 y) y)


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by NM, 1-Mar-1995.) Add
disjoint variable condition to avoid ~ ax-13 . See ~ hbabg for a less restrictive version requiring
more axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem hbab {ph : setvar → setvar → wff} {z : setvar}
  (hbab_1 : ∀ x3 y, ⊦ wi (ph x3 y) (wal (λ x3, ph x3 y)))
  (x3 : setvar) : ⊦ wi (wcel (cv z) (cab (λ y, ph x3 y))) (wal (λ x3, wcel (cv z) (cab (λ y, ph x3 y)))) :=
@hbxfrbi (λ x3, wcel (cv z) (cab (λ y, ph x3 y))) (λ x3, wsb (λ y, ph x3 y) z)
  (λ x3, @df_clab (λ y, ph x3 y) z)
  (λ x3, @hbsbw (λ y x3, ph x3 y) z
    (λ y x3, hbab_1 x3 y) x3) x3


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by NM, 1-Mar-1995.) Add
disjoint variable condition to avoid ~ ax-13 . See ~ hbabg for a less restrictive version requiring
more axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem hbab_b {ph : setvar → setvar → wff}
  (hbab_1 : ∀ x3 y, ⊦ wi (ph x3 y) (wal (λ x3, ph x3 y)))
  (x3 y : setvar) : ⊦ wi (wcel (cv y) (cab (λ y, ph x3 y))) (wal (λ x3, wcel (cv y) (cab (λ y, ph x3 y)))) :=
@hbxfrbi (λ x3, wcel (cv y) (cab (λ y, ph x3 y))) (λ x3, wsb (λ y, ph x3 y) y)
  (λ x3, @df_clab_b (λ y, ph x3 y) y)
  (λ x3, @hbsbw_b (λ y x3, ph x3 y)
    (λ y x3, hbab_1 x3 y) y x3) x3


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by Mario Carneiro,
11-Aug-2016.) Add disjoint variable condition to avoid ~ ax-13 . See ~ nfsabg for a less restrictive
version requiring more axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem nfsab {ph : setvar → setvar → wff} {z : setvar}
  (nfsab_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y)) :
  ⊦ wnf (λ x3, wcel (cv z) (cab (λ y, ph x3 y))) :=
@nf5i (λ x3, wcel (cv z) (cab (λ y, ph x3 y)))
  (λ x3, @hbab (λ x3 y, ph x3 y) z
    (λ x3 y, @nf5ri (λ x3, ph x3 y)
      (nfsab_1 y) x3) x3)


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by Mario Carneiro,
11-Aug-2016.) Add disjoint variable condition to avoid ~ ax-13 . See ~ nfsabg for a less restrictive
version requiring more axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem nfsab_b {ph : setvar → setvar → wff}
  (nfsab_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y))
  (y : setvar) : ⊦ wnf (λ x3, wcel (cv y) (cab (λ y, ph x3 y))) :=
@nf5i (λ x3, wcel (cv y) (cab (λ y, ph x3 y)))
  (λ x3, @hbab_b (λ x3 y, ph x3 y)
    (λ x3 y, @nf5ri (λ x3, ph x3 y)
      (nfsab_1 y) x3) x3 y)


-- /-- Define the equality connective between classes. Definition 2.7 of [Quine] p. 18. Also
-- Definition 4.5 of [TakeutiZaring] p. 13; Chapter 4 provides its justification and methods for
-- eliminating it. Note that its elimination will not necessarily result in a single wff in the
-- original language but possibly a "scheme" of wffs. The hypotheses express that all instances of
-- the conclusion where class variables are replaced with setvar variables hold. Therefore, this
-- definition merely extends to class variables something that is true for setvar variables, hence
-- is conservative. This is only a proof sketch of conservativity; for details see Appendix of
-- [Levy] p. 357. This is the reason why we call this axiomatic statement a "definition", even
-- though it does not have the usual form of a definition. If we required a definition to have the
-- usual form, we would call ~ df-cleq an axiom. See also comments under ~ df-clab , ~ df-clel , and
-- ~ abeq2 . In the form of ~ dfcleq , this is called the "axiom of extensionality" by [Levy] p.
-- 338, who treats the theory of classes as an extralogical extension to our logic and set theory
-- axioms. While the three class definitions ~ df-clab , ~ df-cleq , and ~ df-clel are eliminable
-- and conservative and thus meet the requirements for sound definitions, they are technically
-- axioms in that they do not satisfy the requirements for the current definition checker. The
-- proofs of conservativity require external justification that is beyond the scope of the
-- definition checker. For a general discussion of the theory of classes, see ~ mmset.html#class .
-- (Contributed by NM, 15-Sep-1993.) (Revised by BJ, 24-Jun-2019.) -/
-- axiom df_cleq {A2 B2 : «class»} : (∀ y z, ⊦ wb (wceq (cv y) (cv z)) (wal (λ u, wb (wcel (cv u) (cv y)) (wcel (cv u) (cv z))))) → (∀ t, ⊦ wb (wceq (cv t) (cv t)) (wal (λ v, wb (wcel (cv v) (cv t)) (wcel (cv v) (cv t))))) → ⊦ wb (wceq A2 B2) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2)))


/-- The defining characterization of class equality. It is proved, over Tarski's FOL, from the axiom
of (set) extensionality ( ~ ax-ext ) and the definition of class equality ( ~ df-cleq ). Its forward
implication is called "class extensionality". Remark: the proof uses ~ axextb to prove also the
hypothesis of ~ df-cleq that is a degenerate instance, but it could be proved also from minimal
propositional calculus and { ~ ax-gen , ~ equid }. (Contributed by NM, 15-Sep-1993.) (Revised by BJ,
24-Jun-2019.) -/
theorem dfcleq {A2 B2 : «class»} :
  ⊦ wb (wceq A2 B2) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))) :=
@df_cleq A2 B2
  (λ y z, @axextb y z)
  (λ t, @axextb_b t)


/-- A weaker version of ~ eleq2 (but stronger than ~ ax-9 and ~ elequ2 ) that uses ~ ax-12 to avoid
~ ax-8 and ~ df-clel . Compare ~ eleq2w , whose setvars appear where the class variables are in this
theorem, and vice versa. (Contributed by BJ, 24-Jun-2019.) Strengthen from setvar variables to class
variables. (Revised by WL and SN, 23-Aug-2024.) -/
theorem eleq2w2 {A2 B2 : «class»}
  (x3 : setvar) : ⊦ wi (wceq A2 B2) (wb (wcel (cv x3) A2) (wcel (cv x3) B2)) :=
@«19_21bi» (λ x3, wceq A2 B2) (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))
  (λ x3, @biimpi (wceq A2 B2) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2)))
    (@dfcleq A2 B2)) x3


/-- Infer equality of classes from equivalence of membership. (Contributed by NM, 21-Jun-1993.) -/
theorem eqriv {A2 B2 : «class»}
  (eqriv_1 : ∀ x3, ⊦ wb (wcel (cv x3) A2) (wcel (cv x3) B2)) :
  ⊦ wceq A2 B2 :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wceq A2 B2, from
  @mpgbir (λ x3, wceq A2 B2) (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))
    (λ x3, @dfcleq A2 B2)
    (λ x3, eqriv_1 x3) x3


/-- Deduce equality of classes from equivalence of membership. (Contributed by NM, 17-Mar-1996.) -/
theorem eqrdv {ph : wff} {A2 B2 : «class»}
  (eqrdv_1 : ∀ x3, ⊦ wi ph (wb (wcel (cv x3) A2) (wcel (cv x3) B2))) :
  ⊦ wi ph (wceq A2 B2) :=
@sylibr ph (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))) (wceq A2 B2)
  (@alrimiv ph (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))
    (λ x3, eqrdv_1 x3))
  (@dfcleq A2 B2)


/-- Law of identity (reflexivity of class equality). Theorem 6.4 of [Quine] p. 41. This is part of
Frege's eighth axiom per Proposition 54 of [Frege1879] p. 50; see also ~ biid . An early mention of
this law can be found in Aristotle, _Metaphysics_, Z.17, 1041a10-20. (Thanks to Stefan Allan and BJ
for this information.) (Contributed by NM, 21-Jun-1993.) (Revised by BJ, 14-Oct-2017.) -/
theorem eqid {A2 : «class»} :
  ⊦ wceq A2 A2 :=
@eqriv A2 A2
  (λ x3, @biid (wcel (cv x3) A2))


/-- Class identity law with antecedent. (Contributed by NM, 21-Aug-2008.) -/
theorem eqidd {ph : wff} {A2 : «class»} :
  ⊦ wi ph (wceq A2 A2) :=
@a1i (wceq A2 A2) ph
  (@eqid A2)


/-- Deduction from equality to equivalence of equalities. (Contributed by NM, 27-Dec-1993.) Reduce
dependencies on axioms. (Revised by Wolf Lammen, 5-Dec-2019.) -/
theorem eqeq1d {ph : wff} {A2 B2 C : «class»}
  (eqeq1d_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wb (wceq A2 C) (wceq B2 C)) :=
@«3bitr4g» ph (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) C))) (wal (λ x3, wb (wcel (cv x3) B2) (wcel (cv x3) C))) (wceq A2 C) (wceq B2 C)
  (@«4syl» ph (wceq A2 B2) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))) (wal (λ x3, wb (wb (wcel (cv x3) A2) (wcel (cv x3) C)) (wb (wcel (cv x3) B2) (wcel (cv x3) C)))) (wb (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) C))) (wal (λ x3, wb (wcel (cv x3) B2) (wcel (cv x3) C))))
    eqeq1d_1
    (@biimpi (wceq A2 B2) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2)))
      (@dfcleq A2 B2))
    (@alimi (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2)) (λ x3, wb (wb (wcel (cv x3) A2) (wcel (cv x3) C)) (wb (wcel (cv x3) B2) (wcel (cv x3) C)))
      (λ x3, @bibi1 (wcel (cv x3) A2) (wcel (cv x3) B2) (wcel (cv x3) C)))
    (@albi (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) C)) (λ x3, wb (wcel (cv x3) B2) (wcel (cv x3) C))))
  (@dfcleq A2 C)
  (@dfcleq B2 C)


/-- Equality implies equivalence of equalities. (Contributed by NM, 26-May-1993.) (Proof shortened
by Wolf Lammen, 19-Nov-2019.) -/
theorem eqeq1 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wceq A2 C) (wceq B2 C)) :=
@eqeq1d (wceq A2 B2) A2 B2 C
  (@id (wceq A2 B2))


/-- Inference from equality to equivalence of equalities. (Contributed by NM, 15-Jul-1993.) -/
theorem eqeq1i {A2 B2 C : «class»}
  (eqeq1i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wceq A2 C) (wceq B2 C) :=
@ax_mp (wceq A2 B2) (wb (wceq A2 C) (wceq B2 C))
  eqeq1i_1
  (@eqeq1 A2 B2 C)


/-- Deduction from commutative law for class equality. (Contributed by NM, 15-Aug-1994.) Allow
shortening of ~ eqcom . (Revised by Wolf Lammen, 19-Nov-2019.) -/
theorem eqcomd {ph : wff} {A2 B2 : «class»}
  (eqcomd_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wceq B2 A2) :=
@mpbii ph (wceq A2 A2) (wceq B2 A2)
  (@eqid A2)
  (@eqeq1d ph A2 B2 A2
    eqcomd_1)


/-- Commutative law for class equality. Theorem 6.5 of [Quine] p. 41. (Contributed by NM,
26-May-1993.) (Proof shortened by Wolf Lammen, 19-Nov-2019.) -/
theorem eqcom {A2 B2 : «class»} :
  ⊦ wb (wceq A2 B2) (wceq B2 A2) :=
@impbii (wceq A2 B2) (wceq B2 A2)
  (@eqcomd (wceq A2 B2) A2 B2
    (@id (wceq A2 B2)))
  (@eqcomd (wceq B2 A2) B2 A2
    (@id (wceq B2 A2)))


/-- Inference applying commutative law for class equality to an antecedent. (Contributed by NM,
24-Jun-1993.) -/
theorem eqcoms {ph : wff} {A2 B2 : «class»}
  (eqcoms_1 : ⊦ wi (wceq A2 B2) ph) :
  ⊦ wi (wceq B2 A2) ph :=
@sylbi (wceq B2 A2) (wceq A2 B2) ph
  (@eqcom B2 A2)
  eqcoms_1


/-- Inference from commutative law for class equality. (Contributed by NM, 26-May-1993.) -/
theorem eqcomi {A2 B2 : «class»}
  (eqcomi_1 : ⊦ wceq A2 B2) :
  ⊦ wceq B2 A2 :=
@mpbi (wceq A2 B2) (wceq B2 A2)
  eqcomi_1
  (@eqcom A2 B2)


/-- Deduction from equality to equivalence of equalities. (Contributed by NM, 27-Dec-1993.) Allow
shortening of ~ eqeq2 . (Revised by Wolf Lammen, 19-Nov-2019.) -/
theorem eqeq2d {ph : wff} {A2 B2 C : «class»}
  (eqeq2d_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wb (wceq C A2) (wceq C B2)) :=
@«3bitr4g» ph (wceq A2 C) (wceq B2 C) (wceq C A2) (wceq C B2)
  (@eqeq1d ph A2 B2 C
    eqeq2d_1)
  (@eqcom C A2)
  (@eqcom C B2)


/-- Equality implies equivalence of equalities. (Contributed by NM, 26-May-1993.) (Proof shortened
by Wolf Lammen, 19-Nov-2019.) -/
theorem eqeq2 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wceq C A2) (wceq C B2)) :=
@eqeq2d (wceq A2 B2) A2 B2 C
  (@id (wceq A2 B2))


/-- Inference from equality to equivalence of equalities. (Contributed by NM, 26-May-1993.) -/
theorem eqeq2i {A2 B2 C : «class»}
  (eqeq2i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wceq C A2) (wceq C B2) :=
@ax_mp (wceq A2 B2) (wb (wceq C A2) (wceq C B2))
  eqeq2i_1
  (@eqeq2 A2 B2 C)


/-- Equality relationship among four classes. (Contributed by NM, 3-Aug-1994.) -/
theorem eqeq12 {A2 B2 C D : «class»} :
  ⊦ wi (wa (wceq A2 B2) (wceq C D)) (wb (wceq A2 C) (wceq B2 D)) :=
@sylan9bb (wceq A2 B2) (wceq A2 C) (wceq B2 C) (wceq C D) (wceq B2 D)
  (@eqeq1 A2 B2 C)
  (@eqeq2 C D B2)


/-- A useful inference for substituting definitions into an equality. (Contributed by NM,
15-Jul-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen,
20-Nov-2019.) -/
theorem eqeq12i {A2 B2 C D : «class»}
  (eqeq12i_1 : ⊦ wceq A2 B2)
  (eqeq12i_2 : ⊦ wceq C D) :
  ⊦ wb (wceq A2 C) (wceq B2 D) :=
@bitri (wceq A2 C) (wceq B2 C) (wceq B2 D)
  (@eqeq1i A2 B2 C
    eqeq12i_1)
  (@eqeq2i C D B2
    eqeq12i_2)


/-- A useful inference for substituting definitions into an equality. (Contributed by NM,
5-Aug-1993.) (Proof shortened by Andrew Salmon, 25-May-2011.) -/
theorem eqeq12d {ph : wff} {A2 B2 C D : «class»}
  (eqeq12d_1 : ⊦ wi ph (wceq A2 B2))
  (eqeq12d_2 : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wb (wceq A2 C) (wceq B2 D)) :=
@syl2anc ph (wceq A2 B2) (wceq C D) (wb (wceq A2 C) (wceq B2 D))
  eqeq12d_1
  eqeq12d_2
  (@eqeq12 A2 B2 C D)


/-- A useful inference for substituting definitions into an equality. See also ~ eqeqan12dALT .
(Contributed by NM, 9-Aug-1994.) (Proof shortened by Andrew Salmon, 25-May-2011.) (Proof shortened
by Wolf Lammen, 20-Nov-2019.) -/
theorem eqeqan12d {ph ps : wff} {A2 B2 C D : «class»}
  (eqeqan12d_1 : ⊦ wi ph (wceq A2 B2))
  (eqeqan12d_2 : ⊦ wi ps (wceq C D)) :
  ⊦ wi (wa ph ps) (wb (wceq A2 C) (wceq B2 D)) :=
@eqeq12d (wa ph ps) A2 B2 C D
  (@adantr ph (wceq A2 B2) ps
    eqeqan12d_1)
  (@adantl ps (wceq C D) ph
    eqeqan12d_2)


/-- A useful inference for substituting definitions into an equality. (Contributed by NM,
9-Aug-1994.) -/
theorem eqeqan12rd {ph ps : wff} {A2 B2 C D : «class»}
  (eqeqan12rd_1 : ⊦ wi ph (wceq A2 B2))
  (eqeqan12rd_2 : ⊦ wi ps (wceq C D)) :
  ⊦ wi (wa ps ph) (wb (wceq A2 C) (wceq B2 D)) :=
@ancoms ph ps (wb (wceq A2 C) (wceq B2 D))
  (@eqeqan12d ph ps A2 B2 C D
    eqeqan12rd_1
    eqeqan12rd_2)


/-- Transitive law for class equality. Proposition 4.7(3) of [TakeutiZaring] p. 13. (Contributed by
NM, 25-Jan-2004.) -/
theorem eqtr {A2 B2 C : «class»} :
  ⊦ wi (wa (wceq A2 B2) (wceq B2 C)) (wceq A2 C) :=
@biimpar (wceq A2 B2) (wceq A2 C) (wceq B2 C)
  (@eqeq1 A2 B2 C)


/-- A transitive law for class equality. (Contributed by NM, 20-May-2005.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem eqtr2 {A2 B2 C : «class»} :
  ⊦ wi (wa (wceq A2 B2) (wceq A2 C)) (wceq B2 C) :=
@sylanb (wceq A2 B2) (wceq B2 A2) (wceq A2 C) (wceq B2 C)
  (@eqcom A2 B2)
  (@eqtr B2 A2 C)


/-- A transitive law for class equality. (Contributed by NM, 20-May-2005.) -/
theorem eqtr3 {A2 B2 C : «class»} :
  ⊦ wi (wa (wceq A2 C) (wceq B2 C)) (wceq A2 B2) :=
@sylan2b (wceq B2 C) (wceq A2 C) (wceq C B2) (wceq A2 B2)
  (@eqcom B2 C)
  (@eqtr A2 C B2)


/-- An equality transitivity inference. (Contributed by NM, 26-May-1993.) -/
theorem eqtri {A2 B2 C : «class»}
  (eqtri_1 : ⊦ wceq A2 B2)
  (eqtri_2 : ⊦ wceq B2 C) :
  ⊦ wceq A2 C :=
@mpbi (wceq A2 B2) (wceq A2 C)
  eqtri_1
  (@eqeq2i B2 C A2
    eqtri_2)


/-- An equality transitivity inference. (Contributed by NM, 21-Feb-1995.) -/
theorem eqtr2i {A2 B2 C : «class»}
  (eqtr2i_1 : ⊦ wceq A2 B2)
  (eqtr2i_2 : ⊦ wceq B2 C) :
  ⊦ wceq C A2 :=
@eqcomi A2 C
  (@eqtri A2 B2 C
    eqtr2i_1
    eqtr2i_2)


/-- An equality transitivity inference. (Contributed by NM, 6-May-1994.) -/
theorem eqtr3i {A2 B2 C : «class»}
  (eqtr3i_1 : ⊦ wceq A2 B2)
  (eqtr3i_2 : ⊦ wceq A2 C) :
  ⊦ wceq B2 C :=
@eqtri B2 A2 C
  (@eqcomi A2 B2
    eqtr3i_1)
  eqtr3i_2


/-- An equality transitivity inference. (Contributed by NM, 26-May-1993.) -/
theorem eqtr4i {A2 B2 C : «class»}
  (eqtr4i_1 : ⊦ wceq A2 B2)
  (eqtr4i_2 : ⊦ wceq C B2) :
  ⊦ wceq A2 C :=
@eqtri A2 B2 C
  eqtr4i_1
  (@eqcomi C B2
    eqtr4i_2)


/-- An inference from three chained equalities. (Contributed by NM, 29-Aug-1993.) -/
theorem «3eqtri» {A2 B2 C D : «class»}
  («3eqtri_1» : ⊦ wceq A2 B2)
  («3eqtri_2» : ⊦ wceq B2 C)
  («3eqtri_3» : ⊦ wceq C D) :
  ⊦ wceq A2 D :=
@eqtri A2 B2 D
  «3eqtri_1»
  (@eqtri B2 C D
    «3eqtri_2»
    «3eqtri_3»)


/-- An inference from three chained equalities. (Contributed by NM, 3-Aug-2006.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem «3eqtrri» {A2 B2 C D : «class»}
  («3eqtri_1» : ⊦ wceq A2 B2)
  («3eqtri_2» : ⊦ wceq B2 C)
  («3eqtri_3» : ⊦ wceq C D) :
  ⊦ wceq D A2 :=
@eqtr2i A2 C D
  (@eqtri A2 B2 C
    «3eqtri_1»
    «3eqtri_2»)
  «3eqtri_3»


/-- An inference from three chained equalities. (Contributed by NM, 3-Aug-2006.) -/
theorem «3eqtr2i» {A2 B2 C D : «class»}
  («3eqtr2i_1» : ⊦ wceq A2 B2)
  («3eqtr2i_2» : ⊦ wceq C B2)
  («3eqtr2i_3» : ⊦ wceq C D) :
  ⊦ wceq A2 D :=
@eqtri A2 C D
  (@eqtr4i A2 B2 C
    «3eqtr2i_1»
    «3eqtr2i_2»)
  «3eqtr2i_3»


/-- An inference from three chained equalities. (Contributed by NM, 3-Aug-2006.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem «3eqtr2ri» {A2 B2 C D : «class»}
  («3eqtr2i_1» : ⊦ wceq A2 B2)
  («3eqtr2i_2» : ⊦ wceq C B2)
  («3eqtr2i_3» : ⊦ wceq C D) :
  ⊦ wceq D A2 :=
@eqtr2i A2 C D
  (@eqtr4i A2 B2 C
    «3eqtr2i_1»
    «3eqtr2i_2»)
  «3eqtr2i_3»


/-- An inference from three chained equalities. (Contributed by NM, 6-May-1994.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem «3eqtr3i» {A2 B2 C D : «class»}
  («3eqtr3i_1» : ⊦ wceq A2 B2)
  («3eqtr3i_2» : ⊦ wceq A2 C)
  («3eqtr3i_3» : ⊦ wceq B2 D) :
  ⊦ wceq C D :=
@eqtr3i B2 C D
  (@eqtr3i A2 B2 C
    «3eqtr3i_1»
    «3eqtr3i_2»)
  «3eqtr3i_3»


/-- An inference from three chained equalities. (Contributed by NM, 15-Aug-2004.) -/
theorem «3eqtr3ri» {A2 B2 C D : «class»}
  («3eqtr3i_1» : ⊦ wceq A2 B2)
  («3eqtr3i_2» : ⊦ wceq A2 C)
  («3eqtr3i_3» : ⊦ wceq B2 D) :
  ⊦ wceq D C :=
@eqtr3i B2 D C
  «3eqtr3i_3»
  (@eqtr3i A2 B2 C
    «3eqtr3i_1»
    «3eqtr3i_2»)


/-- An inference from three chained equalities. (Contributed by NM, 26-May-1993.) (Proof shortened
by Andrew Salmon, 25-May-2011.) -/
theorem «3eqtr4i» {A2 B2 C D : «class»}
  («3eqtr4i_1» : ⊦ wceq A2 B2)
  («3eqtr4i_2» : ⊦ wceq C A2)
  («3eqtr4i_3» : ⊦ wceq D B2) :
  ⊦ wceq C D :=
@eqtr4i C A2 D
  «3eqtr4i_2»
  (@eqtr4i D B2 A2
    «3eqtr4i_3»
    «3eqtr4i_1»)


/-- An inference from three chained equalities. (Contributed by NM, 2-Sep-1995.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem «3eqtr4ri» {A2 B2 C D : «class»}
  («3eqtr4i_1» : ⊦ wceq A2 B2)
  («3eqtr4i_2» : ⊦ wceq C A2)
  («3eqtr4i_3» : ⊦ wceq D B2) :
  ⊦ wceq D C :=
@eqtr4i D A2 C
  (@eqtr4i D B2 A2
    «3eqtr4i_3»
    «3eqtr4i_1»)
  «3eqtr4i_2»


/-- An equality transitivity deduction. (Contributed by NM, 21-Jun-1993.) -/
theorem eqtrd {ph : wff} {A2 B2 C : «class»}
  (eqtrd_1 : ⊦ wi ph (wceq A2 B2))
  (eqtrd_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wceq A2 C) :=
@mpbid ph (wceq A2 B2) (wceq A2 C)
  eqtrd_1
  (@eqeq2d ph B2 C A2
    eqtrd_2)


/-- An equality transitivity deduction. (Contributed by NM, 18-Oct-1999.) -/
theorem eqtr2d {ph : wff} {A2 B2 C : «class»}
  (eqtr2d_1 : ⊦ wi ph (wceq A2 B2))
  (eqtr2d_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wceq C A2) :=
@eqcomd ph A2 C
  (@eqtrd ph A2 B2 C
    eqtr2d_1
    eqtr2d_2)


/-- An equality transitivity equality deduction. (Contributed by NM, 18-Jul-1995.) -/
theorem eqtr3d {ph : wff} {A2 B2 C : «class»}
  (eqtr3d_1 : ⊦ wi ph (wceq A2 B2))
  (eqtr3d_2 : ⊦ wi ph (wceq A2 C)) :
  ⊦ wi ph (wceq B2 C) :=
@eqtrd ph B2 A2 C
  (@eqcomd ph A2 B2
    eqtr3d_1)
  eqtr3d_2


/-- An equality transitivity equality deduction. (Contributed by NM, 18-Jul-1995.) -/
theorem eqtr4d {ph : wff} {A2 B2 C : «class»}
  (eqtr4d_1 : ⊦ wi ph (wceq A2 B2))
  (eqtr4d_2 : ⊦ wi ph (wceq C B2)) :
  ⊦ wi ph (wceq A2 C) :=
@eqtrd ph A2 B2 C
  eqtr4d_1
  (@eqcomd ph C B2
    eqtr4d_2)


/-- A deduction from three chained equalities. (Contributed by NM, 29-Oct-1995.) -/
theorem «3eqtrd» {ph : wff} {A2 B2 C D : «class»}
  («3eqtrd_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtrd_2» : ⊦ wi ph (wceq B2 C))
  («3eqtrd_3» : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wceq A2 D) :=
@eqtrd ph A2 B2 D
  «3eqtrd_1»
  (@eqtrd ph B2 C D
    «3eqtrd_2»
    «3eqtrd_3»)


/-- A deduction from three chained equalities. (Contributed by NM, 4-Aug-2006.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem «3eqtrrd» {ph : wff} {A2 B2 C D : «class»}
  («3eqtrd_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtrd_2» : ⊦ wi ph (wceq B2 C))
  («3eqtrd_3» : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wceq D A2) :=
@eqtr2d ph A2 C D
  (@eqtrd ph A2 B2 C
    «3eqtrd_1»
    «3eqtrd_2»)
  «3eqtrd_3»


/-- A deduction from three chained equalities. (Contributed by NM, 4-Aug-2006.) -/
theorem «3eqtr2d» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr2d_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr2d_2» : ⊦ wi ph (wceq C B2))
  («3eqtr2d_3» : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wceq A2 D) :=
@eqtrd ph A2 C D
  (@eqtr4d ph A2 B2 C
    «3eqtr2d_1»
    «3eqtr2d_2»)
  «3eqtr2d_3»


/-- A deduction from three chained equalities. (Contributed by NM, 4-Aug-2006.) -/
theorem «3eqtr2rd» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr2d_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr2d_2» : ⊦ wi ph (wceq C B2))
  («3eqtr2d_3» : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wceq D A2) :=
@eqtr2d ph A2 C D
  (@eqtr4d ph A2 B2 C
    «3eqtr2d_1»
    «3eqtr2d_2»)
  «3eqtr2d_3»


/-- A deduction from three chained equalities. (Contributed by NM, 4-Aug-1995.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem «3eqtr3d» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr3d_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr3d_2» : ⊦ wi ph (wceq A2 C))
  («3eqtr3d_3» : ⊦ wi ph (wceq B2 D)) :
  ⊦ wi ph (wceq C D) :=
@eqtr3d ph B2 C D
  (@eqtr3d ph A2 B2 C
    «3eqtr3d_1»
    «3eqtr3d_2»)
  «3eqtr3d_3»


/-- A deduction from three chained equalities. (Contributed by NM, 14-Jan-2006.) -/
theorem «3eqtr3rd» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr3d_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr3d_2» : ⊦ wi ph (wceq A2 C))
  («3eqtr3d_3» : ⊦ wi ph (wceq B2 D)) :
  ⊦ wi ph (wceq D C) :=
@eqtr3d ph B2 D C
  «3eqtr3d_3»
  (@eqtr3d ph A2 B2 C
    «3eqtr3d_1»
    «3eqtr3d_2»)


/-- A deduction from three chained equalities. (Contributed by NM, 4-Aug-1995.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem «3eqtr4d» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr4d_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr4d_2» : ⊦ wi ph (wceq C A2))
  («3eqtr4d_3» : ⊦ wi ph (wceq D B2)) :
  ⊦ wi ph (wceq C D) :=
@eqtr4d ph C A2 D
  «3eqtr4d_2»
  (@eqtr4d ph D B2 A2
    «3eqtr4d_3»
    «3eqtr4d_1»)


/-- A deduction from three chained equalities. (Contributed by NM, 21-Sep-1995.) -/
theorem «3eqtr4rd» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr4d_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr4d_2» : ⊦ wi ph (wceq C A2))
  («3eqtr4d_3» : ⊦ wi ph (wceq D B2)) :
  ⊦ wi ph (wceq D C) :=
@eqtr4d ph D A2 C
  (@eqtr4d ph D B2 A2
    «3eqtr4d_3»
    «3eqtr4d_1»)
  «3eqtr4d_2»


/-- An equality transitivity deduction. (Contributed by NM, 21-Jun-1993.) -/
theorem syl5eq {ph : wff} {A2 B2 C : «class»}
  (syl5eq_1 : ⊦ wceq A2 B2)
  (syl5eq_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wceq A2 C) :=
@eqtrd ph A2 B2 C
  (@a1i (wceq A2 B2) ph
    syl5eq_1)
  syl5eq_2


/-- An equality transitivity deduction. (Contributed by NM, 29-Mar-1998.) -/
theorem eqtr2id {ph : wff} {A2 B2 C : «class»}
  (eqtr2id_1 : ⊦ wceq A2 B2)
  (eqtr2id_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wceq C A2) :=
@eqcomd ph A2 C
  (@syl5eq ph A2 B2 C
    eqtr2id_1
    eqtr2id_2)


/-- An equality transitivity deduction. (Contributed by NM, 5-Aug-1993.) -/
theorem eqtr3id {ph : wff} {A2 B2 C : «class»}
  (eqtr3id_1 : ⊦ wceq B2 A2)
  (eqtr3id_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wceq A2 C) :=
@syl5eq ph A2 B2 C
  (@eqcomi B2 A2
    eqtr3id_1)
  eqtr3id_2


/-- An equality transitivity deduction. (Contributed by NM, 29-Mar-1998.) -/
theorem syl5reqr {ph : wff} {A2 B2 C : «class»}
  (syl5reqr_1 : ⊦ wceq B2 A2)
  (syl5reqr_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wceq C A2) :=
@eqtr2id ph A2 B2 C
  (@eqcomi B2 A2
    syl5reqr_1)
  syl5reqr_2


/-- An equality transitivity deduction. (Contributed by NM, 21-Jun-1993.) -/
theorem eqtrdi {ph : wff} {A2 B2 C : «class»}
  (eqtrdi_1 : ⊦ wi ph (wceq A2 B2))
  (eqtrdi_2 : ⊦ wceq B2 C) :
  ⊦ wi ph (wceq A2 C) :=
@eqtrd ph A2 B2 C
  eqtrdi_1
  (@a1i (wceq B2 C) ph
    eqtrdi_2)


/-- An equality transitivity deduction. (Contributed by NM, 29-Mar-1998.) -/
theorem eqtr2di {ph : wff} {A2 B2 C : «class»}
  (eqtr2di_1 : ⊦ wi ph (wceq A2 B2))
  (eqtr2di_2 : ⊦ wceq B2 C) :
  ⊦ wi ph (wceq C A2) :=
@eqcomd ph A2 C
  (@eqtrdi ph A2 B2 C
    eqtr2di_1
    eqtr2di_2)


/-- An equality transitivity deduction. (Contributed by NM, 21-Jun-1993.) -/
theorem eqtr4di {ph : wff} {A2 B2 C : «class»}
  (eqtr4di_1 : ⊦ wi ph (wceq A2 B2))
  (eqtr4di_2 : ⊦ wceq C B2) :
  ⊦ wi ph (wceq A2 C) :=
@eqtrdi ph A2 B2 C
  eqtr4di_1
  (@eqcomi C B2
    eqtr4di_2)


/-- An equality transitivity deduction. (Contributed by NM, 29-Mar-1998.) -/
theorem eqtr4id {ph : wff} {A2 B2 C : «class»}
  (eqtr4id_2 : ⊦ wceq A2 B2)
  (eqtr4id_1 : ⊦ wi ph (wceq C B2)) :
  ⊦ wi ph (wceq A2 C) :=
@eqtr2di ph C B2 A2
  eqtr4id_1
  (@eqcomi A2 B2
    eqtr4id_2)


/-- An equality transitivity deduction. (Contributed by NM, 8-May-1994.) (Proof shortened by Andrew
Salmon, 25-May-2011.) -/
theorem sylan9eq {ph ps : wff} {A2 B2 C : «class»}
  (sylan9eq_1 : ⊦ wi ph (wceq A2 B2))
  (sylan9eq_2 : ⊦ wi ps (wceq B2 C)) :
  ⊦ wi (wa ph ps) (wceq A2 C) :=
@syl2an ph (wceq A2 B2) (wceq B2 C) (wceq A2 C) ps
  sylan9eq_1
  sylan9eq_2
  (@eqtr A2 B2 C)


/-- An equality transitivity deduction. (Contributed by NM, 23-Jun-2007.) -/
theorem sylan9req {ph ps : wff} {A2 B2 C : «class»}
  (sylan9req_1 : ⊦ wi ph (wceq B2 A2))
  (sylan9req_2 : ⊦ wi ps (wceq B2 C)) :
  ⊦ wi (wa ph ps) (wceq A2 C) :=
@sylan9eq ph ps A2 B2 C
  (@eqcomd ph B2 A2
    sylan9req_1)
  sylan9req_2


/-- An equality transitivity deduction. (Contributed by NM, 8-May-1994.) -/
theorem sylan9eqr {ph ps : wff} {A2 B2 C : «class»}
  (sylan9eqr_1 : ⊦ wi ph (wceq A2 B2))
  (sylan9eqr_2 : ⊦ wi ps (wceq B2 C)) :
  ⊦ wi (wa ps ph) (wceq A2 C) :=
@ancoms ph ps (wceq A2 C)
  (@sylan9eq ph ps A2 B2 C
    sylan9eqr_1
    sylan9eqr_2)


/-- A chained equality inference, useful for converting from definitions. (Contributed by NM,
15-Nov-1994.) -/
theorem «3eqtr3g» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr3g_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr3g_2» : ⊦ wceq A2 C)
  («3eqtr3g_3» : ⊦ wceq B2 D) :
  ⊦ wi ph (wceq C D) :=
@eqtrdi ph C B2 D
  (@eqtr3id ph C A2 B2
    «3eqtr3g_2»
    «3eqtr3g_1»)
  «3eqtr3g_3»


/-- A chained equality inference, useful for converting from definitions. (Contributed by Mario
Carneiro, 6-Nov-2015.) -/
theorem «3eqtr3a» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr3a_1» : ⊦ wceq A2 B2)
  («3eqtr3a_2» : ⊦ wi ph (wceq A2 C))
  («3eqtr3a_3» : ⊦ wi ph (wceq B2 D)) :
  ⊦ wi ph (wceq C D) :=
@eqtr3d ph A2 C D
  «3eqtr3a_2»
  (@syl5eq ph A2 B2 D
    «3eqtr3a_1»
    «3eqtr3a_3»)


/-- A chained equality inference, useful for converting to definitions. (Contributed by NM,
21-Jun-1993.) -/
theorem «3eqtr4g» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr4g_1» : ⊦ wi ph (wceq A2 B2))
  («3eqtr4g_2» : ⊦ wceq C A2)
  («3eqtr4g_3» : ⊦ wceq D B2) :
  ⊦ wi ph (wceq C D) :=
@eqtr4di ph C B2 D
  (@syl5eq ph C A2 B2
    «3eqtr4g_2»
    «3eqtr4g_1»)
  «3eqtr4g_3»


/-- A chained equality inference, useful for converting to definitions. (Contributed by NM,
2-Feb-2007.) (Proof shortened by Andrew Salmon, 25-May-2011.) -/
theorem «3eqtr4a» {ph : wff} {A2 B2 C D : «class»}
  («3eqtr4a_1» : ⊦ wceq A2 B2)
  («3eqtr4a_2» : ⊦ wi ph (wceq C A2))
  («3eqtr4a_3» : ⊦ wi ph (wceq D B2)) :
  ⊦ wi ph (wceq C D) :=
@eqtr4d ph C B2 D
  (@eqtrdi ph C A2 B2
    «3eqtr4a_2»
    «3eqtr4a_1»)
  «3eqtr4a_3»


/-- Equivalent formulas yield equal class abstractions (closed form). This is the forward
implication of ~ abbi , proved from fewer axioms. (Contributed by BJ and WL and SN, 20-Aug-2023.) -/
theorem abbi1 {ph ps : setvar → wff} :
  ⊦ wi (wal (λ x3, wb (ph x3) (ps x3))) (wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3))) :=
@eqrdv (wal (λ x3, wb (ph x3) (ps x3))) (cab (λ x3, ph x3)) (cab (λ x3, ps x3))
  (λ y, @«3bitr4g» (wal (λ x3, wb (ph x3) (ps x3))) (wsb (λ x3, ph x3) y) (wsb (λ x3, ps x3) y) (wcel (cv y) (cab (λ x3, ph x3))) (wcel (cv y) (cab (λ x3, ps x3)))
    (@spsbbi (λ x3, ph x3) (λ x3, ps x3) y)
    (@df_clab (λ x3, ph x3) y)
    (@df_clab (λ x3, ps x3) y))


/-- Equivalent wff's yield equal class abstractions (deduction form). (Contributed by NM,
10-Aug-1993.) Avoid ~ ax-12 , based on an idea of Steven Nguyen. (Revised by Wolf Lammen,
6-May-2023.) -/
theorem abbidv {ph : wff} {ps ch : setvar → wff}
  (abbidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wceq (cab (λ x3, ps x3)) (cab (λ x3, ch x3))) :=
@syl ph (wal (λ x3, wb (ps x3) (ch x3))) (wceq (cab (λ x3, ps x3)) (cab (λ x3, ch x3)))
  (@alrimiv ph (λ x3, wb (ps x3) (ch x3))
    (λ x3, abbidv_1 x3))
  (@abbi1 (λ x3, ps x3) (λ x3, ch x3))


/-- Equivalent wff's yield equal class abstractions (inference form). (Contributed by NM,
26-May-1993.) Remove dependency on ~ ax-10 , ~ ax-11 , and ~ ax-12 . (Revised by Steven Nguyen,
3-May-2023.) -/
theorem abbii {ph ps : setvar → wff}
  (abbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3)), from
  @mpg (λ x3, wb (ph x3) (ps x3)) (λ x3, wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3)))
    (λ x3, @abbi1 (λ x3, ph x3) (λ x3, ps x3))
    (λ x3, abbii_1 x3) x3


/-- Equivalent wff's yield equal class abstractions (deduction form, with nonfreeness hypothesis).
(Contributed by NM, 21-Jun-1993.) (Revised by Mario Carneiro, 7-Oct-2016.) Avoid ~ ax-10 and ~ ax-11
. (Revised by Wolf Lammen, 6-May-2023.) -/
theorem abbid {ph ps ch : setvar → wff}
  (abbid_1 : ⊦ wnf (λ x3, ph x3))
  (abbid_2 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wceq (cab (λ x3, ps x3)) (cab (λ x3, ch x3))) :=
@syl (ph x3) (wal (λ x3, wb (ps x3) (ch x3))) (wceq (cab (λ x3, ps x3)) (cab (λ x3, ch x3)))
  (@alrimi (λ x3, ph x3) (λ x3, wb (ps x3) (ch x3))
    abbid_1
    (λ x3, abbid_2 x3) x3)
  (@abbi1 (λ x3, ps x3) (λ x3, ch x3))


/-- Equivalent formulas define equal class abstractions, and conversely. (Contributed by NM,
25-Nov-2013.) (Revised by Mario Carneiro, 11-Aug-2016.) Remove dependency on ~ ax-8 and ~ df-clel
(by avoiding use of ~ cleqh ). (Revised by BJ, 23-Jun-2019.) -/
theorem abbi {ph ps : setvar → wff} :
  ⊦ wb (wal (λ x3, wb (ph x3) (ps x3))) (wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3))) :=
@bitr2i (wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3))) (wal (λ y, wb (wcel (cv y) (cab (λ x3, ph x3))) (wcel (cv y) (cab (λ x3, ps x3))))) (wal (λ x3, wb (ph x3) (ps x3)))
  (@dfcleq (cab (λ x3, ph x3)) (cab (λ x3, ps x3)))
  (setvar.forget $ λ x3 : setvar,
    setvar.forget $ λ y : setvar,
    show ⊦ wb (wal (λ y, wb (wcel (cv y) (cab (λ x3, ph x3))) (wcel (cv y) (cab (λ x3, ps x3))))) (wal (λ x3, wb (ph x3) (ps x3))), from
    @cbvalv1 (λ y x3, wb (wcel (cv y) (cab (λ x3, ph x3))) (wcel (cv y) (cab (λ x3, ps x3)))) (λ y x3, wb (ph x3) (ps x3))
      (λ y, @nfbi (λ x3, wcel (cv y) (cab (λ x3, ph x3))) (λ x3, wcel (cv y) (cab (λ x3, ps x3)))
        (@nfsab1 (λ x3 y, ph x3) y)
        (@nfsab1 (λ x3 y, ps x3) y))
      (λ x3, @nfv (wb (ph x3) (ps x3)))
      (λ y x3, @bibi12d (wceq (cv y) (cv x3)) (wcel (cv y) (cab (λ x3, ph x3))) (ph x3) (wcel (cv y) (cab (λ x3, ps x3))) (ps x3)
        (@syl5bb (wcel (cv y) (cab (λ x3, ph x3))) (wsb (λ x3, ph x3) y) (wceq (cv y) (cv x3)) (ph x3)
          (@df_clab (λ x3, ph x3) y)
          (@sbequ12r (λ y x3, ph x3) y x3))
        (@syl5bb (wcel (cv y) (cab (λ x3, ps x3))) (wsb (λ x3, ps x3) y) (wceq (cv y) (cv x3)) (ps x3)
          (@df_clab (λ x3, ps x3) y)
          (@sbequ12r (λ y x3, ps x3) y x3))) y x3)


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbvab with
disjoint variable conditions requiring fewer axioms. (Contributed by NM, 26-May-1999.) Require ` x `
, ` y ` be disjoint to avoid ~ ax-11 and ~ ax-13 . (Revised by Steven Nguyen, 4-Dec-2022.) -/
theorem cbvabv {ph ps : setvar → wff}
  (cbvabv_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y))) :
  ⊦ wceq (cab (λ x3, ph x3)) (cab (λ y, ps y)) :=
@eqriv (cab (λ x3, ph x3)) (cab (λ y, ps y))
  (λ z, @«3bitr4i» (wsb (λ x3, ph x3) z) (wsb (λ y, ps y) z) (wcel (cv z) (cab (λ x3, ph x3))) (wcel (cv z) (cab (λ y, ps y)))
    (@bitr3i (wsb (λ x3, ph x3) z) (wsb (λ y, wsb (λ x3, ph x3) y) z) (wsb (λ y, ps y) z)
      (@sbco2vv (λ x3 z, ph x3) z)
      (@sbbii (λ y, wsb (λ x3, ph x3) y) (λ y, ps y) z
        (λ y, @sbievw (λ x3 y, ph x3) (λ y, ps y)
          (λ x3 y, cbvabv_1 x3 y) y)))
    (@df_clab (λ x3, ph x3) z)
    (@df_clab (λ y, ps y) z))


/-- Rule used to change bound variables, using implicit substitution. Version of ~ cbvab with a
disjoint variable condition, which does not require ~ ax-10 , ~ ax-13 . (Contributed by Andrew
Salmon, 11-Jul-2011.) (Revised by Gino Giotto, 23-May-2024.) -/
theorem cbvabw {ph ps : setvar → setvar → wff}
  (cbvabw_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (cbvabw_2 : ∀ y, ⊦ wnf (λ x3, ps x3 y))
  (cbvabw_3 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3 y) (ps x3 y)))
  (x3 y : setvar) : ⊦ wceq (cab (λ x3, ph x3 y)) (cab (λ y, ps x3 y)) :=
@eqriv (cab (λ x3, ph x3 y)) (cab (λ y, ps x3 y))
  (λ z, @«3bitr4i» (wsb (λ x3, ph x3 y) z) (wsb (λ y, ps x3 y) z) (wcel (cv z) (cab (λ x3, ph x3 y))) (wcel (cv z) (cab (λ y, ps x3 y)))
    (@«3bitr4i» (wal (λ w, wi (wceq (cv w) (cv z)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 y))))) (wal (λ w, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ps x3 y))))) (wsb (λ x3, ph x3 y) z) (wsb (λ y, ps x3 y) z)
      (@albii (λ w, wi (wceq (cv w) (cv z)) (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 y)))) (λ w, wi (wceq (cv w) (cv z)) (wal (λ y, wi (wceq (cv y) (cv w)) (ps x3 y))))
        (λ w, @imbi2i (wal (λ x3, wi (wceq (cv x3) (cv w)) (ph x3 y))) (wal (λ y, wi (wceq (cv y) (cv w)) (ps x3 y))) (wceq (cv w) (cv z))
          (@cbvalv1 (λ x3 y, wi (wceq (cv x3) (cv w)) (ph x3 y)) (λ x3 y, wi (wceq (cv y) (cv w)) (ps x3 y))
            (λ x3, @nfim (λ y, wceq (cv x3) (cv w)) (λ y, ph x3 y)
              (@nfv (wceq (cv x3) (cv w)))
              (cbvabw_1 x3))
            (λ y, @nfim (λ x3, wceq (cv y) (cv w)) (λ x3, ps x3 y)
              (@nfv (wceq (cv y) (cv w)))
              (cbvabw_2 y))
            (λ x3 y, @imbi12d (wceq (cv x3) (cv y)) (wceq (cv x3) (cv w)) (wceq (cv y) (cv w)) (ph x3 y) (ps x3 y)
              (@equequ1 w x3 y)
              (cbvabw_3 x3 y)) x3 y)))
      (@df_sb (λ x3, ph x3 y) z)
      (@df_sb (λ y, ps x3 y) z))
    (@df_clab (λ x3, ph x3 y) z)
    (@df_clab (λ y, ps x3 y) z))


/-- Version of ~ abeq2 using implicit substitution, which requires fewer axioms. (Contributed by GG
and AV, 18-Sep-2024.) -/
theorem abeq2w {ph ps : setvar → wff} {A2 : setvar → «class»}
  (abeq2w_1 : ∀ x3 y, ⊦ wi (wceq (cv x3) (cv y)) (wb (ph x3) (ps y)))
  (x3 : setvar) : ⊦ wb (wceq (A2 x3) (cab (λ x3, ph x3))) (wal (λ y, wb (wcel (cv y) (A2 x3)) (ps y))) :=
@bitri (wceq (A2 x3) (cab (λ x3, ph x3))) (wal (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (cab (λ x3, ph x3))))) (wal (λ y, wb (wcel (cv y) (A2 x3)) (ps y)))
  (@dfcleq (A2 x3) (cab (λ x3, ph x3)))
  (@albii (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (cab (λ x3, ph x3)))) (λ y, wb (wcel (cv y) (A2 x3)) (ps y))
    (λ y, @bibi2i (wcel (cv y) (cab (λ x3, ph x3))) (ps y) (wcel (cv y) (A2 x3))
      (@bitri (wcel (cv y) (cab (λ x3, ph x3))) (wsb (λ x3, ph x3) y) (ps y)
        (@df_clab (λ x3, ph x3) y)
        (@sbievw (λ x3 y, ph x3) (λ y, ps y)
          (λ x3 y, abeq2w_1 x3 y) y))))


-- /-- Define the membership connective between classes. Theorem 6.3 of [Quine] p. 41, or
-- Proposition 4.6 of [TakeutiZaring] p. 13, which we adopt as a definition. See these references
-- for its metalogical justification. The hypotheses express that all instances of the conclusion
-- where class variables are replaced with setvar variables hold. Therefore, this definition merely
-- extends to class variables something that is true for setvar variables, hence is conservative.
-- This is only a proof sketch of conservativity; for details see Appendix of [Levy] p. 357. This is
-- the reason why we call this axiomatic statement a "definition", even though it does not have the
-- usual form of a definition. If we required a definition to have the usual form, we would call ~
-- df-clel an axiom. See also comments under ~ df-clab , ~ df-cleq , and ~ abeq2 . Alternate
-- characterizations of ` A e. B ` when either ` A ` or ` B ` is a set are given by ~ clel2g , ~
-- clel3g , and ~ clel4g . This is called the "axiom of membership" by [Levy] p. 338, who treats the
-- theory of classes as an extralogical extension to our logic and set theory axioms. While the
-- three class definitions ~ df-clab , ~ df-cleq , and ~ df-clel are eliminable and conservative and
-- thus meet the requirements for sound definitions, they are technically axioms in that they do not
-- satisfy the requirements for the current definition checker. The proofs of conservativity require
-- external justification that is beyond the scope of the definition checker. For a general
-- discussion of the theory of classes, see ~ mmset.html#class . (Contributed by NM, 26-May-1993.)
-- (Revised by BJ, 27-Jun-2019.) -/
-- axiom df_clel {A2 B2 : «class»} : (∀ y z, ⊦ wb (wcel (cv y) (cv z)) (wex (λ u, wa (wceq (cv u) (cv y)) (wcel (cv u) (cv z))))) → (∀ t, ⊦ wb (wcel (cv t) (cv t)) (wex (λ v, wa (wceq (cv v) (cv t)) (wcel (cv v) (cv t))))) → ⊦ wb (wcel A2 B2) (wex (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) B2)))


/-- Characterization of the elements of a class. (Contributed by BJ, 27-Jun-2019.) -/
theorem dfclel {A2 B2 : «class»} :
  ⊦ wb (wcel A2 B2) (wex (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) B2))) :=
@df_clel A2 B2
  (λ y z, @cleljust z y)
  (λ t, @cleljust_b t)


/-- An element of a class exists. Version of ~ elisset with a disjoint variable condition on ` V , x
` , avoiding ~ df-clab . (Contributed by BJ, 14-Sep-2019.) -/
theorem elissetv {A2 V : «class»} :
  ⊦ wi (wcel A2 V) (wex (λ x3, wceq (cv x3) A2)) :=
@sylbi (wcel A2 V) (wex (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) V))) (wex (λ x3, wceq (cv x3) A2))
  (@dfclel A2 V)
  (@exsimpl (λ x3, wceq (cv x3) A2) (λ x3, wcel (cv x3) V))


/-- An element of a class exists. (Contributed by NM, 1-May-1995.) Reduce dependencies on axioms.
(Revised by BJ, 29-Apr-2019.) -/
theorem elisset {A2 : «class»} {V : setvar → «class»}
  (x3 : setvar) : ⊦ wi (wcel A2 (V x3)) (wex (λ x3, wceq (cv x3) A2)) :=
@sylib (wcel A2 (V x3)) (wex (λ y, wceq (cv y) A2)) (wex (λ x3, wceq (cv x3) A2))
  (@elissetv A2 (V x3))
  (@bitr4i (wex (λ y, wceq (cv y) A2)) (wcel A2 (cab (λ z, wtru))) (wex (λ x3, wceq (cv x3) A2))
    (@bitr4i (wex (λ y, wceq (cv y) A2)) (wex (λ y, wa (wceq (cv y) A2) (wcel (cv y) (cab (λ z, wtru))))) (wcel A2 (cab (λ z, wtru)))
      (@exbii (λ y, wceq (cv y) A2) (λ y, wa (wceq (cv y) A2) (wcel (cv y) (cab (λ z, wtru))))
        (λ y, @biantru (wcel (cv y) (cab (λ z, wtru))) (wceq (cv y) A2)
          (@vextru y)))
      (@dfclel A2 (cab (λ z, wtru))))
    (@bitr4i (wex (λ x3, wceq (cv x3) A2)) (wex (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) (cab (λ z, wtru))))) (wcel A2 (cab (λ z, wtru)))
      (@exbii (λ x3, wceq (cv x3) A2) (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) (cab (λ z, wtru))))
        (λ x3, @biantru (wcel (cv x3) (cab (λ z, wtru))) (wceq (cv x3) A2)
          (@vextru x3)))
      (@dfclel A2 (cab (λ z, wtru)))))


/-- Weaker version of ~ eleq1 (but more general than ~ elequ1 ) not depending on ~ ax-ext nor ~
df-cleq . Note that this provides a proof of ~ ax-8 from Tarski's FOL and ~ dfclel (simply consider
an instance where ` A ` is replaced by a setvar and deduce the forward implication by ~ biimpd ),
which shows that ~ dfclel is too powerful to be used as a definition instead of ~ df-clel .
(Contributed by BJ, 24-Jun-2019.) -/
theorem eleq1w {A2 : setvar → setvar → «class»}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (A2 x3 y))) :=
@«3bitr4g» (wceq (cv x3) (cv y)) (wex (λ z, wa (wceq (cv z) (cv x3)) (wcel (cv z) (A2 x3 y)))) (wex (λ z, wa (wceq (cv z) (cv y)) (wcel (cv z) (A2 x3 y)))) (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (A2 x3 y))
  (@exbidv (wceq (cv x3) (cv y)) (λ z, wa (wceq (cv z) (cv x3)) (wcel (cv z) (A2 x3 y))) (λ z, wa (wceq (cv z) (cv y)) (wcel (cv z) (A2 x3 y)))
    (λ z, @anbi1d (wceq (cv x3) (cv y)) (wceq (cv z) (cv x3)) (wceq (cv z) (cv y)) (wcel (cv z) (A2 x3 y))
      (@equequ2 x3 y z)))
  (@dfclel (cv x3) (A2 x3 y))
  (@dfclel (cv y) (A2 x3 y))


/-- Weaker version of ~ eleq2 (but more general than ~ elequ2 ) not depending on ~ ax-ext nor ~
df-cleq . (Contributed by BJ, 29-Sep-2019.) -/
theorem eleq2w {A2 : setvar → setvar → «class»}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wb (wcel (A2 x3 y) (cv x3)) (wcel (A2 x3 y) (cv y))) :=
@«3bitr4g» (wceq (cv x3) (cv y)) (wex (λ z, wa (wceq (cv z) (A2 x3 y)) (wcel (cv z) (cv x3)))) (wex (λ z, wa (wceq (cv z) (A2 x3 y)) (wcel (cv z) (cv y)))) (wcel (A2 x3 y) (cv x3)) (wcel (A2 x3 y) (cv y))
  (@exbidv (wceq (cv x3) (cv y)) (λ z, wa (wceq (cv z) (A2 x3 y)) (wcel (cv z) (cv x3))) (λ z, wa (wceq (cv z) (A2 x3 y)) (wcel (cv z) (cv y)))
    (λ z, @anbi2d (wceq (cv x3) (cv y)) (wcel (cv z) (cv x3)) (wcel (cv z) (cv y)) (wceq (cv z) (A2 x3 y))
      (@elequ2 z x3 y)))
  (@dfclel (A2 x3 y) (cv x3))
  (@dfclel (A2 x3 y) (cv y))


/-- Deduction from equality to equivalence of membership. (Contributed by NM, 21-Jun-1993.) Allow
shortening of ~ eleq1 . (Revised by Wolf Lammen, 20-Nov-2019.) -/
theorem eleq1d {ph : wff} {A2 B2 C : «class»}
  (eleq1d_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wb (wcel A2 C) (wcel B2 C)) :=
@«3bitr4g» ph (wex (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) C))) (wex (λ x3, wa (wceq (cv x3) B2) (wcel (cv x3) C))) (wcel A2 C) (wcel B2 C)
  (@exbidv ph (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) C)) (λ x3, wa (wceq (cv x3) B2) (wcel (cv x3) C))
    (λ x3, @anbi1d ph (wceq (cv x3) A2) (wceq (cv x3) B2) (wcel (cv x3) C)
      (@eqeq2d ph A2 B2 (cv x3)
        eleq1d_1)))
  (@dfclel A2 C)
  (@dfclel B2 C)


/-- Deduction from equality to equivalence of membership. (Contributed by NM, 27-Dec-1993.) Reduce
dependencies on axioms. (Revised by Wolf Lammen, 5-Dec-2019.) -/
theorem eleq2d {ph : wff} {A2 B2 C : «class»}
  (eleq1d_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wb (wcel C A2) (wcel C B2)) :=
@«3bitr4g» ph (wex (λ x3, wa (wceq (cv x3) C) (wcel (cv x3) A2))) (wex (λ x3, wa (wceq (cv x3) C) (wcel (cv x3) B2))) (wcel C A2) (wcel C B2)
  (@syl ph (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))) (wb (wex (λ x3, wa (wceq (cv x3) C) (wcel (cv x3) A2))) (wex (λ x3, wa (wceq (cv x3) C) (wcel (cv x3) B2))))
    (@sylib ph (wceq A2 B2) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2)))
      eleq1d_1
      (@dfcleq A2 B2))
    (@alexbii (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2)) (λ x3, wa (wceq (cv x3) C) (wcel (cv x3) A2)) (λ x3, wa (wceq (cv x3) C) (wcel (cv x3) B2))
      (λ x3, @anbi2 (wcel (cv x3) A2) (wcel (cv x3) B2) (wceq (cv x3) C))))
  (@dfclel C A2)
  (@dfclel C B2)


/-- Equality implies equivalence of membership. (Contributed by NM, 26-May-1993.) (Proof shortened
by Wolf Lammen, 20-Nov-2019.) -/
theorem eleq1 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wcel A2 C) (wcel B2 C)) :=
@eleq1d (wceq A2 B2) A2 B2 C
  (@id (wceq A2 B2))


/-- Equality implies equivalence of membership. (Contributed by NM, 26-May-1993.) (Proof shortened
by Wolf Lammen, 20-Nov-2019.) -/
theorem eleq2 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wcel C A2) (wcel C B2)) :=
@eleq2d (wceq A2 B2) A2 B2 C
  (@id (wceq A2 B2))


/-- Equality implies equivalence of membership. (Contributed by NM, 31-May-1999.) -/
theorem eleq12 {A2 B2 C D : «class»} :
  ⊦ wi (wa (wceq A2 B2) (wceq C D)) (wb (wcel A2 C) (wcel B2 D)) :=
@sylan9bb (wceq A2 B2) (wcel A2 C) (wcel B2 C) (wceq C D) (wcel B2 D)
  (@eleq1 A2 B2 C)
  (@eleq2 C D B2)


/-- Inference from equality to equivalence of membership. (Contributed by NM, 21-Jun-1993.) -/
theorem eleq1i {A2 B2 C : «class»}
  (eleq1i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wcel A2 C) (wcel B2 C) :=
@ax_mp (wceq A2 B2) (wb (wcel A2 C) (wcel B2 C))
  eleq1i_1
  (@eleq1 A2 B2 C)


/-- Inference from equality to equivalence of membership. (Contributed by NM, 26-May-1993.) -/
theorem eleq2i {A2 B2 C : «class»}
  (eleq1i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wcel C A2) (wcel C B2) :=
@ax_mp (wceq A2 B2) (wb (wcel C A2) (wcel C B2))
  eleq1i_1
  (@eleq2 A2 B2 C)


/-- If a class is not an element of another class, an equal class is also not an element.
(Contributed by Glauco Siliprandi, 3-Jan-2021.) -/
theorem eqneltri {A2 B2 C : «class»}
  (eqneltri_1 : ⊦ wceq A2 B2)
  (eqneltri_2 : ⊦ wn (wcel B2 C)) :
  ⊦ wn (wcel A2 C) :=
@mtbir (wcel A2 C) (wcel B2 C)
  eqneltri_2
  (@eleq1i A2 B2 C
    eqneltri_1)


/-- Deduction from equality to equivalence of membership. (Contributed by NM, 31-May-1994.) -/
theorem eleq12d {ph : wff} {A2 B2 C D : «class»}
  (eleq12d_1 : ⊦ wi ph (wceq A2 B2))
  (eleq12d_2 : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wb (wcel A2 C) (wcel B2 D)) :=
@bitrd ph (wcel A2 C) (wcel A2 D) (wcel B2 D)
  (@eleq2d ph C D A2
    eleq12d_2)
  (@eleq1d ph A2 B2 D
    eleq12d_1)


/-- A transitive-type law relating membership and equality. (Contributed by NM, 9-Apr-1994.) -/
theorem eleq1a {A2 B2 C : «class»} :
  ⊦ wi (wcel A2 B2) (wi (wceq C A2) (wcel C B2)) :=
@biimprcd (wceq C A2) (wcel C B2) (wcel A2 B2)
  (@eleq1 C A2 B2)


/-- Substitution of equal classes into membership relation. (Contributed by NM, 21-Jun-1993.) -/
theorem eqeltri {A2 B2 C : «class»}
  (eqeltri_1 : ⊦ wceq A2 B2)
  (eqeltri_2 : ⊦ wcel B2 C) :
  ⊦ wcel A2 C :=
@mpbir (wcel A2 C) (wcel B2 C)
  eqeltri_2
  (@eleq1i A2 B2 C
    eqeltri_1)


/-- Substitution of equal classes into membership relation. (Contributed by NM, 21-Jun-1993.) -/
theorem eqeltrri {A2 B2 C : «class»}
  (eqeltrri_1 : ⊦ wceq A2 B2)
  (eqeltrri_2 : ⊦ wcel A2 C) :
  ⊦ wcel B2 C :=
@eqeltri B2 A2 C
  (@eqcomi A2 B2
    eqeltrri_1)
  eqeltrri_2


/-- Substitution of equal classes into membership relation. (Contributed by NM, 15-Jul-1993.) -/
theorem eleqtri {A2 B2 C : «class»}
  (eleqtri_1 : ⊦ wcel A2 B2)
  (eleqtri_2 : ⊦ wceq B2 C) :
  ⊦ wcel A2 C :=
@mpbi (wcel A2 B2) (wcel A2 C)
  eleqtri_1
  (@eleq2i B2 C A2
    eleqtri_2)


/-- Substitution of equal classes into membership relation. (Contributed by NM, 15-Jul-1993.) -/
theorem eleqtrri {A2 B2 C : «class»}
  (eleqtrri_1 : ⊦ wcel A2 B2)
  (eleqtrri_2 : ⊦ wceq C B2) :
  ⊦ wcel A2 C :=
@eleqtri A2 B2 C
  eleqtrri_1
  (@eqcomi C B2
    eleqtrri_2)


/-- Substitution of equal classes into membership relation, deduction form. (Contributed by Raph
Levien, 10-Dec-2002.) -/
theorem eqeltrd {ph : wff} {A2 B2 C : «class»}
  (eqeltrd_1 : ⊦ wi ph (wceq A2 B2))
  (eqeltrd_2 : ⊦ wi ph (wcel B2 C)) :
  ⊦ wi ph (wcel A2 C) :=
@mpbird ph (wcel A2 C) (wcel B2 C)
  eqeltrd_2
  (@eleq1d ph A2 B2 C
    eqeltrd_1)


/-- Deduction that substitutes equal classes into membership. (Contributed by NM, 14-Dec-2004.) -/
theorem eqeltrrd {ph : wff} {A2 B2 C : «class»}
  (eqeltrrd_1 : ⊦ wi ph (wceq A2 B2))
  (eqeltrrd_2 : ⊦ wi ph (wcel A2 C)) :
  ⊦ wi ph (wcel B2 C) :=
@eqeltrd ph B2 A2 C
  (@eqcomd ph A2 B2
    eqeltrrd_1)
  eqeltrrd_2


/-- Deduction that substitutes equal classes into membership. (Contributed by NM, 14-Dec-2004.) -/
theorem eleqtrd {ph : wff} {A2 B2 C : «class»}
  (eleqtrd_1 : ⊦ wi ph (wcel A2 B2))
  (eleqtrd_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wcel A2 C) :=
@mpbid ph (wcel A2 B2) (wcel A2 C)
  eleqtrd_1
  (@eleq2d ph B2 C A2
    eleqtrd_2)


/-- Deduction that substitutes equal classes into membership. (Contributed by NM, 14-Dec-2004.) -/
theorem eleqtrrd {ph : wff} {A2 B2 C : «class»}
  (eleqtrrd_1 : ⊦ wi ph (wcel A2 B2))
  (eleqtrrd_2 : ⊦ wi ph (wceq C B2)) :
  ⊦ wi ph (wcel A2 C) :=
@eleqtrd ph A2 B2 C
  eleqtrrd_1
  (@eqcomd ph C B2
    eleqtrrd_2)


/-- A membership and equality inference. (Contributed by NM, 4-Jan-2006.) -/
theorem eqeltrid {ph : wff} {A2 B2 C : «class»}
  (eqeltrid_1 : ⊦ wceq A2 B2)
  (eqeltrid_2 : ⊦ wi ph (wcel B2 C)) :
  ⊦ wi ph (wcel A2 C) :=
@eqeltrd ph A2 B2 C
  (@a1i (wceq A2 B2) ph
    eqeltrid_1)
  eqeltrid_2


/-- A membership and equality inference. (Contributed by NM, 4-Jan-2006.) -/
theorem eqeltrrid {ph : wff} {A2 B2 C : «class»}
  (eqeltrrid_1 : ⊦ wceq B2 A2)
  (eqeltrrid_2 : ⊦ wi ph (wcel B2 C)) :
  ⊦ wi ph (wcel A2 C) :=
@eqeltrid ph A2 B2 C
  (@eqcomi B2 A2
    eqeltrrid_1)
  eqeltrrid_2


/-- A membership and equality inference. (Contributed by NM, 4-Jan-2006.) -/
theorem eleqtrid {ph : wff} {A2 B2 C : «class»}
  (eleqtrid_1 : ⊦ wcel A2 B2)
  (eleqtrid_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wcel A2 C) :=
@eleqtrd ph A2 B2 C
  (@a1i (wcel A2 B2) ph
    eleqtrid_1)
  eleqtrid_2


/-- A membership and equality inference. (Contributed by NM, 4-Jan-2006.) -/
theorem eleqtrrid {ph : wff} {A2 B2 C : «class»}
  (eleqtrrid_1 : ⊦ wcel A2 B2)
  (eleqtrrid_2 : ⊦ wi ph (wceq C B2)) :
  ⊦ wi ph (wcel A2 C) :=
@eleqtrid ph A2 B2 C
  eleqtrrid_1
  (@eqcomd ph C B2
    eleqtrrid_2)


/-- A membership and equality inference. (Contributed by NM, 4-Jan-2006.) -/
theorem eqeltrdi {ph : wff} {A2 B2 C : «class»}
  (eqeltrdi_1 : ⊦ wi ph (wceq A2 B2))
  (eqeltrdi_2 : ⊦ wcel B2 C) :
  ⊦ wi ph (wcel A2 C) :=
@eqeltrd ph A2 B2 C
  eqeltrdi_1
  (@a1i (wcel B2 C) ph
    eqeltrdi_2)


/-- A membership and equality inference. (Contributed by NM, 4-Jan-2006.) -/
theorem eqeltrrdi {ph : wff} {A2 B2 C : «class»}
  (eqeltrrdi_1 : ⊦ wi ph (wceq B2 A2))
  (eqeltrrdi_2 : ⊦ wcel B2 C) :
  ⊦ wi ph (wcel A2 C) :=
@eqeltrdi ph A2 B2 C
  (@eqcomd ph B2 A2
    eqeltrrdi_1)
  eqeltrrdi_2


/-- A membership and equality inference. (Contributed by NM, 4-Jan-2006.) -/
theorem eleqtrdi {ph : wff} {A2 B2 C : «class»}
  (eleqtrdi_1 : ⊦ wi ph (wcel A2 B2))
  (eleqtrdi_2 : ⊦ wceq B2 C) :
  ⊦ wi ph (wcel A2 C) :=
@eleqtrd ph A2 B2 C
  eleqtrdi_1
  (@a1i (wceq B2 C) ph
    eleqtrdi_2)


/-- A membership and equality inference. (Contributed by NM, 24-Apr-2005.) -/
theorem eleqtrrdi {ph : wff} {A2 B2 C : «class»}
  (eleqtrrdi_1 : ⊦ wi ph (wcel A2 B2))
  (eleqtrrdi_2 : ⊦ wceq C B2) :
  ⊦ wi ph (wcel A2 C) :=
@eleqtrdi ph A2 B2 C
  eleqtrrdi_1
  (@eqcomi C B2
    eleqtrrdi_2)


/-- Substitution of equal classes into membership relation. (Contributed by Mario Carneiro,
6-Jan-2017.) -/
theorem «3eltr4i» {A2 B2 C D : «class»}
  («3eltr4i_1» : ⊦ wcel A2 B2)
  («3eltr4i_2» : ⊦ wceq C A2)
  («3eltr4i_3» : ⊦ wceq D B2) :
  ⊦ wcel C D :=
@eqeltri C A2 D
  «3eltr4i_2»
  (@eleqtrri A2 B2 D
    «3eltr4i_1»
    «3eltr4i_3»)


/-- Substitution of equal classes into membership relation. (Contributed by Mario Carneiro,
6-Jan-2017.) -/
theorem «3eltr3d» {ph : wff} {A2 B2 C D : «class»}
  («3eltr3d_1» : ⊦ wi ph (wcel A2 B2))
  («3eltr3d_2» : ⊦ wi ph (wceq A2 C))
  («3eltr3d_3» : ⊦ wi ph (wceq B2 D)) :
  ⊦ wi ph (wcel C D) :=
@eqeltrrd ph A2 C D
  «3eltr3d_2»
  (@eleqtrd ph A2 B2 D
    «3eltr3d_1»
    «3eltr3d_3»)


/-- Substitution of equal classes into membership relation. (Contributed by Mario Carneiro,
6-Jan-2017.) -/
theorem «3eltr4d» {ph : wff} {A2 B2 C D : «class»}
  («3eltr4d_1» : ⊦ wi ph (wcel A2 B2))
  («3eltr4d_2» : ⊦ wi ph (wceq C A2))
  («3eltr4d_3» : ⊦ wi ph (wceq D B2)) :
  ⊦ wi ph (wcel C D) :=
@eqeltrd ph C A2 D
  «3eltr4d_2»
  (@eleqtrrd ph A2 B2 D
    «3eltr4d_1»
    «3eltr4d_3»)


/-- Substitution of equal classes into membership relation. (Contributed by Mario Carneiro,
6-Jan-2017.) (Proof shortened by Wolf Lammen, 23-Nov-2019.) -/
theorem «3eltr4g» {ph : wff} {A2 B2 C D : «class»}
  («3eltr4g_1» : ⊦ wi ph (wcel A2 B2))
  («3eltr4g_2» : ⊦ wceq C A2)
  («3eltr4g_3» : ⊦ wceq D B2) :
  ⊦ wi ph (wcel C D) :=
@eleqtrrdi ph C B2 D
  (@eqeltrid ph C A2 B2
    «3eltr4g_2»
    «3eltr4g_1»)
  «3eltr4g_3»


/-- Substitution of equal classes into a membership antecedent. (Contributed by Jonathan Ben-Naim,
3-Jun-2011.) -/
theorem eleq2s {ph : wff} {A2 B2 C : «class»}
  (eleq2s_1 : ⊦ wi (wcel A2 B2) ph)
  (eleq2s_2 : ⊦ wceq C B2) :
  ⊦ wi (wcel A2 C) ph :=
@sylbi (wcel A2 C) (wcel A2 B2) ph
  (@eleq2i C B2 A2
    eleq2s_2)
  eleq2s_1


/-- If a class is not an element of another class, an equal class is also not an element. Deduction
form. (Contributed by David Moews, 1-May-2017.) -/
theorem eqneltrd {ph : wff} {A2 B2 C : «class»}
  (eqneltrd_1 : ⊦ wi ph (wceq A2 B2))
  (eqneltrd_2 : ⊦ wi ph (wn (wcel B2 C))) :
  ⊦ wi ph (wn (wcel A2 C)) :=
@mtbird ph (wcel A2 C) (wcel B2 C)
  eqneltrd_2
  (@eleq1d ph A2 B2 C
    eqneltrd_1)


/-- If a class is not an element of another class, it is also not an element of an equal class.
Deduction form. (Contributed by David Moews, 1-May-2017.) -/
theorem neleqtrd {ph : wff} {A2 B2 C : «class»}
  (neleqtrd_1 : ⊦ wi ph (wn (wcel C A2)))
  (neleqtrd_2 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wn (wcel C B2)) :=
@mtbid ph (wcel C A2) (wcel C B2)
  neleqtrd_1
  (@eleq2d ph A2 B2 C
    neleqtrd_2)


/-- If a class is not an element of another class, it is also not an element of an equal class.
Deduction form. (Contributed by David Moews, 1-May-2017.) (Proof shortened by Wolf Lammen,
13-Nov-2019.) -/
theorem neleqtrrd {ph : wff} {A2 B2 C : «class»}
  (neleqtrrd_1 : ⊦ wi ph (wn (wcel C B2)))
  (neleqtrrd_2 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wn (wcel C A2)) :=
@neleqtrd ph B2 A2 C
  neleqtrrd_1
  (@eqcomd ph A2 B2
    neleqtrrd_2)


/-- Establish equality between classes, using bound-variable hypotheses instead of distinct variable
conditions as in ~ dfcleq . See also ~ cleqf . (Contributed by NM, 26-May-1993.) (Proof shortened by
Wolf Lammen, 14-Nov-2019.) Remove dependency on ~ ax-13 . (Revised by BJ, 30-Nov-2020.) -/
theorem cleqh {A2 B2 : setvar → «class»}
  (cleqh_1 : ∀ x3 y, ⊦ wi (wcel (cv y) (A2 x3)) (wal (λ x3, wcel (cv y) (A2 x3))))
  (cleqh_2 : ∀ x3 y, ⊦ wi (wcel (cv y) (B2 x3)) (wal (λ x3, wcel (cv y) (B2 x3))))
  (x3 : setvar) : ⊦ wb (wceq (A2 x3) (B2 x3)) (wal (λ x3, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3)))) :=
@bitr4i (wceq (A2 x3) (B2 x3)) (wal (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))) (wal (λ x3, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3))))
  (@dfcleq (A2 x3) (B2 x3))
  (setvar.forget $ λ y : setvar,
    show ⊦ wb (wal (λ x3, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3)))) (wal (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))), from
    @cbvalv1 (λ x3 y, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3))) (λ x3 y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))
      (λ x3, @nfv (wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3))))
      (λ y, @nfbi (λ x3, wcel (cv y) (A2 x3)) (λ x3, wcel (cv y) (B2 x3))
        (@nf5i (λ x3, wcel (cv y) (A2 x3))
          (λ x3, cleqh_1 x3 y))
        (@nf5i (λ x3, wcel (cv y) (B2 x3))
          (λ x3, cleqh_2 x3 y)))
      (λ x3 y, @bibi12d (wceq (cv x3) (cv y)) (wcel (cv x3) (A2 x3)) (wcel (cv y) (A2 x3)) (wcel (cv x3) (B2 x3)) (wcel (cv y) (B2 x3))
        (@eleq1w (λ x3 y, A2 x3) x3 y)
        (@eleq1w (λ x3 y, B2 x3) x3 y)) x3 y)


/-- A way of showing two classes are not equal. (Contributed by NM, 1-Apr-1997.) -/
theorem nelneq {A2 B2 C : «class»} :
  ⊦ wi (wa (wcel A2 C) (wn (wcel B2 C))) (wn (wceq A2 B2)) :=
@con3dimp (wcel A2 C) (wceq A2 B2) (wcel B2 C)
  (@biimpcd (wceq A2 B2) (wcel A2 C) (wcel B2 C)
    (@eleq1 A2 B2 C))


/-- A way of showing two classes are not equal. (Contributed by NM, 12-Jan-2002.) -/
theorem nelneq2 {A2 B2 C : «class»} :
  ⊦ wi (wa (wcel A2 B2) (wn (wcel A2 C))) (wn (wceq B2 C)) :=
@con3dimp (wcel A2 B2) (wceq B2 C) (wcel A2 C)
  (@biimpcd (wceq B2 C) (wcel A2 B2) (wcel A2 C)
    (@eleq2 B2 C A2))


/-- Substitution applied to an atomic wff (class version of ~ equsb3 ). (Contributed by Rodolfo
Medina, 28-Apr-2010.) -/
theorem eqsb3 {A2 : setvar → «class»}
  (y : setvar) : ⊦ wb (wsb (λ x3, wceq (cv x3) (A2 y)) y) (wceq (cv y) (A2 y)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wsb (λ x3, wceq (cv x3) (A2 y)) y) (wceq (cv y) (A2 y)), from
  @sbievw2 (λ x3 y, wceq (cv x3) (A2 y)) (λ x3 y, wceq (cv y) (A2 y)) (λ y w, wceq (cv w) (A2 y))
    (λ x3 y w, @eqeq1 (cv x3) (cv w) (A2 y))
    (λ x3 y w, @eqeq1 (cv w) (cv y) (A2 y)) x3 y


/-- Substitution applied to an atomic wff (class version of ~ elsb3 ). (Contributed by Rodolfo
Medina, 28-Apr-2010.) (Proof shortened by Andrew Salmon, 14-Jun-2011.) -/
theorem clelsb3 {A2 : setvar → «class»}
  (y : setvar) : ⊦ wb (wsb (λ x3, wcel (cv x3) (A2 y)) y) (wcel (cv y) (A2 y)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wb (wsb (λ x3, wcel (cv x3) (A2 y)) y) (wcel (cv y) (A2 y)), from
  @sbievw2 (λ x3 y, wcel (cv x3) (A2 y)) (λ x3 y, wcel (cv y) (A2 y)) (λ y w, wcel (cv w) (A2 y))
    (λ x3 y w, @eleq1w (λ x3 w, A2 y) x3 w)
    (λ x3 y w, @eleq1w (λ w y, A2 y) w y) x3 y


/-- Equality of a class variable and a class abstraction (also called a class builder). Theorem 5.1
of [Quine] p. 34. This theorem shows the relationship between expressions with class abstractions
and expressions with class variables. Note that ~ abbi and its relatives are among those useful for
converting theorems with class variables to equivalent theorems with wff variables, by first
substituting a class abstraction for each class variable. Class variables can always be eliminated
from a theorem to result in an equivalent theorem with wff variables, and vice-versa. The idea is
roughly as follows. To convert a theorem with a wff variable ` ph ` (that has a free variable ` x `
) to a theorem with a class variable ` A ` , we substitute ` x e. A ` for ` ph ` throughout and
simplify, where ` A ` is a new class variable not already in the wff. An example is the conversion
of ~ zfauscl to ~ inex1 (look at the instance of ~ zfauscl that occurs in the proof of ~ inex1 ).
Conversely, to convert a theorem with a class variable ` A ` to one with ` ph ` , we substitute ` {
x | ph } ` for ` A ` throughout and simplify, where ` x ` and ` ph ` are new setvar and wff
variables not already in the wff. Examples include ~ dfsymdif2 and ~ cp ; the latter derives a
formula containing wff variables from substitution instances of the class variables in its
equivalent formulation ~ cplem2 . For more information on class variables, see Quine pp. 15-21
and/or Takeuti and Zaring pp. 10-13. Usage of ~ abeq2w is preferred since it requires fewer axioms.
(Contributed by NM, 26-May-1993.) -/
theorem abeq2 {ph : setvar → wff} {A2 : «class»} :
  ⊦ wb (wceq A2 (cab (λ x3, ph x3))) (wal (λ x3, wb (wcel (cv x3) A2) (ph x3))) :=
@bitri (wceq A2 (cab (λ x3, ph x3))) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) (cab (λ x3, ph x3))))) (wal (λ x3, wb (wcel (cv x3) A2) (ph x3)))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wb (wceq A2 (cab (λ x3, ph x3))) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) (cab (λ x3, ph x3))))), from
    @cleqh (λ x3, A2) (λ x3, cab (λ x3, ph x3))
      (λ x3 y, @ax_5 (wcel (cv y) A2))
      (λ x3 y, @hbab1 (λ x3 y, ph x3) y) x3)
  (@albii (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) (cab (λ x3, ph x3)))) (λ x3, wb (wcel (cv x3) A2) (ph x3))
    (λ x3, @bibi2i (wcel (cv x3) (cab (λ x3, ph x3))) (ph x3) (wcel (cv x3) A2)
      (@abid (λ x3, ph x3) x3)))


/-- Equality of a class variable and a class abstraction. Commuted form of ~ abeq2 . (Contributed by
NM, 20-Aug-1993.) -/
theorem abeq1 {ph : setvar → wff} {A2 : «class»} :
  ⊦ wb (wceq (cab (λ x3, ph x3)) A2) (wal (λ x3, wb (ph x3) (wcel (cv x3) A2))) :=
@«3bitr4i» (wceq A2 (cab (λ x3, ph x3))) (wal (λ x3, wb (wcel (cv x3) A2) (ph x3))) (wceq (cab (λ x3, ph x3)) A2) (wal (λ x3, wb (ph x3) (wcel (cv x3) A2)))
  (@abeq2 (λ x3, ph x3) A2)
  (@eqcom (cab (λ x3, ph x3)) A2)
  (@albii (λ x3, wb (ph x3) (wcel (cv x3) A2)) (λ x3, wb (wcel (cv x3) A2) (ph x3))
    (λ x3, @bicom (ph x3) (wcel (cv x3) A2)))


/-- Equality of a class variable and a class abstraction (deduction form of ~ abeq2 ). (Contributed
by NM, 16-Nov-1995.) -/
theorem abeq2d {ph ps : setvar → wff} {A2 : setvar → «class»}
  (abeq2d_1 : ∀ x3, ⊦ wi (ph x3) (wceq (A2 x3) (cab (λ x3, ps x3))))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wcel (cv x3) (A2 x3)) (ps x3)) :=
@bitrdi (ph x3) (wcel (cv x3) (A2 x3)) (wcel (cv x3) (cab (λ x3, ps x3))) (ps x3)
  (@eleq2d (ph x3) (A2 x3) (cab (λ x3, ps x3)) (cv x3)
    (abeq2d_1 x3))
  (@abid (λ x3, ps x3) x3)


/-- Equality of a class variable and a class abstraction (inference form). (Contributed by NM,
3-Apr-1996.) (Proof shortened by Wolf Lammen, 15-Nov-2019.) -/
theorem abeq2i {ph : setvar → wff} {A2 : setvar → «class»}
  (abeq2i_1 : ∀ x3, ⊦ wceq (A2 x3) (cab (λ x3, ph x3)))
  (x3 : setvar) : ⊦ wb (wcel (cv x3) (A2 x3)) (ph x3) :=
@mptru (wb (wcel (cv x3) (A2 x3)) (ph x3))
  (@abeq2d (λ x3, wtru) (λ x3, ph x3) (λ x3, A2 x3)
    (λ x3, @a1i (wceq (A2 x3) (cab (λ x3, ph x3))) wtru
      (abeq2i_1 x3)) x3)


/-- Deduction from a wff to a class abstraction. (Contributed by NM, 9-Jul-1994.) Avoid ~ ax-11 .
(Revised by Wolf Lammen, 6-May-2023.) -/
theorem abbi2dv {ph : wff} {ps : setvar → wff} {A2 : «class»}
  (abbi2dv_1 : ∀ x3, ⊦ wi ph (wb (wcel (cv x3) A2) (ps x3))) :
  ⊦ wi ph (wceq A2 (cab (λ x3, ps x3))) :=
@eqrdv ph A2 (cab (λ x3, ps x3))
  (λ y, @«3bitr4g» ph (wsb (λ x3, wcel (cv x3) A2) y) (wsb (λ x3, ps x3) y) (wcel (cv y) A2) (wcel (cv y) (cab (λ x3, ps x3)))
    (@sbbidv ph (λ x3, wcel (cv x3) A2) (λ x3, ps x3) y
      (λ x3, abbi2dv_1 x3))
    (@bicomi (wsb (λ x3, wcel (cv x3) A2) y) (wcel (cv y) A2)
      (@clelsb3 (λ y, A2) y))
    (@df_clab (λ x3, ps x3) y))


/-- Deduction from a wff to a class abstraction. (Contributed by NM, 9-Jul-1994.) (Proof shortened
by Wolf Lammen, 16-Nov-2019.) -/
theorem abbi1dv {ph : wff} {ps : setvar → wff} {A2 : «class»}
  (abbi1dv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (wcel (cv x3) A2))) :
  ⊦ wi ph (wceq (cab (λ x3, ps x3)) A2) :=
@eqcomd ph A2 (cab (λ x3, ps x3))
  (@abbi2dv ph (λ x3, ps x3) A2
    (λ x3, @bicomd ph (ps x3) (wcel (cv x3) A2)
      (abbi1dv_1 x3)))


/-- Equality of a class variable and a class abstraction (inference form). (Contributed by NM,
26-May-1993.) Avoid ~ ax-11 . (Revised by Wolf Lammen, 6-May-2023.) -/
theorem abbi2i {ph : setvar → wff} {A2 : «class»}
  (abbi2i_1 : ∀ x3, ⊦ wb (wcel (cv x3) A2) (ph x3)) :
  ⊦ wceq A2 (cab (λ x3, ph x3)) :=
@mptru (wceq A2 (cab (λ x3, ph x3)))
  (@abbi2dv wtru (λ x3, ph x3) A2
    (λ x3, @a1i (wb (wcel (cv x3) A2) (ph x3)) wtru
      (abbi2i_1 x3)))


/-- Every class is equal to a class abstraction (the class of sets belonging to it). Theorem 5.2 of
[Quine] p. 35. This is a generalization to classes of ~ cvjust . The proof does not rely on ~ cvjust
, so ~ cvjust could be proved as a special instance of it. Note however that ~ abid1 necessarily
relies on ~ df-clel , whereas ~ cvjust does not. This theorem requires ~ ax-ext , ~ df-clab , ~
df-cleq , ~ df-clel , but to prove that any specific class term not containing class variables is a
setvar or is equal to a class abstraction does not require these $a-statements. This last fact is a
metatheorem, consequence of the fact that the only $a-statements with typecode ` class ` are ~ cv ,
~ cab , and statements corresponding to defined class constructors. Note on the simultaneous
presence in set.mm of this ~ abid1 and its commuted form ~ abid2 : It is rare that two forms so
closely related both appear in set.mm. Indeed, such equalities are generally used in later proofs as
parts of transitive inferences, and with the many variants of ~ eqtri (search for *eqtr*), it would
be rare that either one would shorten a proof compared to the other. There is typically a choice
between what we call a "definitional form", where the shorter expression is on the LHS (left-hand
side), and a "computational form", where the shorter expression is on the RHS (right-hand side). An
example is ~ df-2 versus ~ 1p1e2 . We do not need ~ 1p1e2 , but because it occurs "naturally" in
computations, it can be useful to have it directly, together with a uniform set of 1-digit
operations like ~ 1p2e3 , etc. In most cases, we do not need both a definitional and a computational
forms. A definitional form would favor consistency with genuine definitions, while a computational
form is often more natural. The situation is similar with biconditionals in propositional calculus:
see for instance ~ pm4.24 and ~ anidm , while other biconditionals generally appear in a single form
(either definitional, but more often computational). In the present case, the equality is important
enough that both ~ abid1 and ~ abid2 are in set.mm. (Contributed by NM, 26-Dec-1993.) (Revised by
BJ, 10-Nov-2020.) -/
theorem abid1 {A2 : «class»} :
  ⊦ wceq A2 (cab (λ x3, wcel (cv x3) A2)) :=
@abbi2i (λ x3, wcel (cv x3) A2) A2
  (λ x3, @biid (wcel (cv x3) A2))


/-- A simplification of class abstraction. Commuted form of ~ abid1 . See comments there.
(Contributed by NM, 26-Dec-1993.) -/
theorem abid2 {A2 : «class»} :
  ⊦ wceq (cab (λ x3, wcel (cv x3) A2)) A2 :=
@eqcomi A2 (cab (λ x3, wcel (cv x3) A2))
  (@abid1 A2)


/-- Membership of a class variable in a class abstraction. (Contributed by NM, 23-Dec-1993.) (Proof
shortened by Wolf Lammen, 16-Nov-2019.) Avoid ~ ax-11 , see ~ sbc5ALT for more details. (Revised by
SN, 2-Sep-2024.) -/
theorem clelab {ph : setvar → wff} {A2 : «class»} :
  ⊦ wb (wcel A2 (cab (λ x3, ph x3))) (wex (λ x3, wa (wceq (cv x3) A2) (ph x3))) :=
@pm5_21nii (wcel A2 (cab (λ x3, ph x3))) (wex (λ y, wceq (cv y) A2)) (wex (λ x3, wa (wceq (cv x3) A2) (ph x3)))
  (setvar.forget $ λ y : setvar,
    show ⊦ wi (wcel A2 (cab (λ x3, ph x3))) (wex (λ y, wceq (cv y) A2)), from
    @elisset A2 (λ y, cab (λ x3, ph x3)) y)
  (@sylib (wex (λ x3, wa (wceq (cv x3) A2) (ph x3))) (wex (λ x3, wceq (cv x3) A2)) (wex (λ y, wceq (cv y) A2))
    (@exsimpl (λ x3, wceq (cv x3) A2) (λ x3, ph x3))
    (@cbvexvw (λ x3, wceq (cv x3) A2) (λ y, wceq (cv y) A2)
      (λ x3 y, @eqeq1 (cv x3) (cv y) A2)))
  (@exlimiv (λ y, wceq (cv y) A2) (wb (wcel A2 (cab (λ x3, ph x3))) (wex (λ x3, wa (wceq (cv x3) A2) (ph x3))))
    (λ y, @mpbii (wceq (cv y) A2) (wb (wcel (cv y) (cab (λ x3, ph x3))) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3)))) (wb (wcel A2 (cab (λ x3, ph x3))) (wex (λ x3, wa (wceq (cv x3) A2) (ph x3))))
      (@bitri (wcel (cv y) (cab (λ x3, ph x3))) (wsb (λ x3, ph x3) y) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3)))
        (@df_clab (λ x3, ph x3) y)
        (@sb5 (λ x3 y, ph x3) y))
      (@bibi12d (wceq (cv y) A2) (wcel (cv y) (cab (λ x3, ph x3))) (wcel A2 (cab (λ x3, ph x3))) (wex (λ x3, wa (wceq (cv x3) (cv y)) (ph x3))) (wex (λ x3, wa (wceq (cv x3) A2) (ph x3)))
        (@eleq1 (cv y) A2 (cab (λ x3, ph x3)))
        (@exbidv (wceq (cv y) A2) (λ x3, wa (wceq (cv x3) (cv y)) (ph x3)) (λ x3, wa (wceq (cv x3) A2) (ph x3))
          (λ x3, @anbi1d (wceq (cv y) A2) (wceq (cv x3) (cv y)) (wceq (cv x3) A2) (ph x3)
            (@eqeq2 (cv y) A2 (cv x3)))))))


/-- The right-hand side of the second equality is a way of representing proper substitution of ` y `
for ` x ` into a class variable. (Contributed by NM, 14-Sep-2003.) -/
theorem sbab {A2 : setvar → setvar → «class»}
  (x3 y : setvar) : ⊦ wi (wceq (cv x3) (cv y)) (wceq (A2 x3 y) (cab (λ z, wsb (λ x3, wcel (cv z) (A2 x3 y)) y))) :=
@abbi2dv (wceq (cv x3) (cv y)) (λ z, wsb (λ x3, wcel (cv z) (A2 x3 y)) y) (A2 x3 y)
  (λ z, @sbequ12 (λ x3 y, wcel (cv z) (A2 x3 y)) x3 y)


-- /-- Extend wff definition to include the not-free predicate for classes. -/
-- constant wnfc : (setvar → «class») → wff


-- /-- Define the not-free predicate for classes. This is read " ` x ` is not free in ` A ` ".
-- Not-free means that the value of ` x ` cannot affect the value of ` A ` , e.g., any occurrence of
-- ` x ` in ` A ` is effectively bound by a "for all" or something that expands to one (such as
-- "there exists"). It is defined in terms of the not-free predicate ~ df-nf for wffs; see that
-- definition for more information. (Contributed by Mario Carneiro, 11-Aug-2016.) -/
-- axiom df_nfc {A2 : setvar → «class»} : ⊦ wb (wnfc (λ x3, A2 x3)) (wal (λ y, wnf (λ x3, wcel (cv y) (A2 x3))))


/-- Deduce that a class ` A ` does not have ` x ` free in it. (Contributed by Mario Carneiro,
11-Aug-2016.) -/
theorem nfci {A2 : setvar → «class»}
  (nfci_1 : ∀ y, ⊦ wnf (λ x3, wcel (cv y) (A2 x3))) :
  ⊦ wnfc (λ x3, A2 x3) :=
setvar.forget $ λ y : setvar,
  show ⊦ wnfc (λ x3, A2 x3), from
  @mpgbir (λ y, wnfc (λ x3, A2 x3)) (λ y, wnf (λ x3, wcel (cv y) (A2 x3)))
    (λ y, @df_nfc (λ x3, A2 x3))
    (λ y, nfci_1 y) y


/-- Consequence of the not-free predicate. (Contributed by Mario Carneiro, 11-Aug-2016.) Drop ~
ax-12 but use ~ ax-8 , ~ df-clel , and avoid a DV condition on ` y ` , ` A ` . (Revised by SN,
3-Jun-2024.) -/
theorem nfcr {A2 : setvar → setvar → «class»}
  (y : setvar) : ⊦ wi (wnfc (λ x3, A2 x3 y)) (wnf (λ x3, wcel (cv y) (A2 x3 y))) :=
@sylbi (wnfc (λ x3, A2 x3 y)) (wal (λ z, wnf (λ x3, wcel (cv z) (A2 x3 y)))) (wnf (λ x3, wcel (cv y) (A2 x3 y)))
  (@df_nfc (λ x3, A2 x3 y))
  (@spvv (λ z y, wnf (λ x3, wcel (cv z) (A2 x3 y))) (λ y, wnf (λ x3, wcel (cv y) (A2 x3 y)))
    (λ z y, @nfbidv (wceq (cv z) (cv y)) (λ x3, wcel (cv z) (A2 x3 y)) (λ x3, wcel (cv y) (A2 x3 y))
      (λ x3, @eleq1w (λ z y, A2 x3 y) z y)) y)


/-- Consequence of the not-free predicate. (Contributed by Mario Carneiro, 11-Aug-2016.) Avoid ~
ax-10 , ~ ax-11 . (Revised by Gino Giotto, 23-May-2024.) Avoid ~ ax-12 (adopting Wolf Lammen's
13-May-2023 proof). (Revised by SN, 3-Jun-2024.) -/
theorem nfcri {A2 : setvar → setvar → «class»}
  (nfcri_1 : ∀ y, ⊦ wnfc (λ x3, A2 x3 y))
  (y : setvar) : ⊦ wnf (λ x3, wcel (cv y) (A2 x3 y)) :=
@ax_mp (wnfc (λ x3, A2 x3 y)) (wnf (λ x3, wcel (cv y) (A2 x3 y)))
  (nfcri_1 y)
  (@nfcr (λ x3 y, A2 x3 y) y)


/-- Deduce that a class ` A ` does not have ` x ` free in it. (Contributed by Mario Carneiro,
11-Aug-2016.) -/
theorem nfcd {ph : setvar → setvar → wff} {A2 : setvar → «class»}
  (nfcd_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (nfcd_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, wcel (cv y) (A2 x3))))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnfc (λ x3, A2 x3)) :=
@sylibr (ph x3 y) (wal (λ y, wnf (λ x3, wcel (cv y) (A2 x3)))) (wnfc (λ x3, A2 x3))
  (@alrimi (λ y, ph x3 y) (λ y, wnf (λ x3, wcel (cv y) (A2 x3)))
    (nfcd_1 x3)
    (λ y, nfcd_2 x3 y) y)
  (@df_nfc (λ x3, A2 x3))


/-- Consequence of the not-free predicate. (Contributed by Mario Carneiro, 11-Aug-2016.) -/
theorem nfcrd {ph : setvar → setvar → wff} {A2 : setvar → setvar → «class»}
  (nfcrd_1 : ∀ x3 y, ⊦ wi (ph x3 y) (wnfc (λ x3, A2 x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnf (λ x3, wcel (cv y) (A2 x3 y))) :=
@syl (ph x3 y) (wnfc (λ x3, A2 x3 y)) (wnf (λ x3, wcel (cv y) (A2 x3 y)))
  (nfcrd_1 x3 y)
  (@nfcr (λ x3 y, A2 x3 y) y)


/-- An equality theorem for effectively not free. (Contributed by Mario Carneiro, 14-Oct-2016.)
Avoid ~ ax-8 and ~ df-clel . (Revised by WL and SN, 23-Aug-2024.) -/
theorem nfceqdf {ph : setvar → wff} {A2 B2 : setvar → «class»}
  (nfceqdf_1 : ⊦ wnf (λ x3, ph x3))
  (nfceqdf_2 : ∀ x3, ⊦ wi (ph x3) (wceq (A2 x3) (B2 x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wnfc (λ x3, A2 x3)) (wnfc (λ x3, B2 x3))) :=
@«3bitr4g» (ph x3) (wal (λ y, wnf (λ x3, wcel (cv y) (A2 x3)))) (wal (λ y, wnf (λ x3, wcel (cv y) (B2 x3)))) (wnfc (λ x3, A2 x3)) (wnfc (λ x3, B2 x3))
  (@albidv (ph x3) (λ y, wnf (λ x3, wcel (cv y) (A2 x3))) (λ y, wnf (λ x3, wcel (cv y) (B2 x3)))
    (λ y, @nfbidf (λ x3, ph x3) (λ x3, wcel (cv y) (A2 x3)) (λ x3, wcel (cv y) (B2 x3))
      nfceqdf_1
      (λ x3, @syl (ph x3) (wceq (A2 x3) (B2 x3)) (wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))
        (nfceqdf_2 x3)
        (@eleq2w2 (A2 x3) (B2 x3) y)) x3))
  (@df_nfc (λ x3, A2 x3))
  (@df_nfc (λ x3, B2 x3))


/-- Equality theorem for class not-free. (Contributed by Mario Carneiro, 11-Aug-2016.) (Proof
shortened by Wolf Lammen, 16-Nov-2019.) Avoid ~ ax-12 . (Revised by Wolf Lammen, 19-Jun-2023.) -/
theorem nfceqi {A2 B2 : setvar → «class»}
  (nfceqi_1 : ∀ x3, ⊦ wceq (A2 x3) (B2 x3)) :
  ⊦ wb (wnfc (λ x3, A2 x3)) (wnfc (λ x3, B2 x3)) :=
@«3bitr4i» (wal (λ y, wnf (λ x3, wcel (cv y) (A2 x3)))) (wal (λ y, wnf (λ x3, wcel (cv y) (B2 x3)))) (wnfc (λ x3, A2 x3)) (wnfc (λ x3, B2 x3))
  (@albii (λ y, wnf (λ x3, wcel (cv y) (A2 x3))) (λ y, wnf (λ x3, wcel (cv y) (B2 x3)))
    (λ y, @nfbii (λ x3, wcel (cv y) (A2 x3)) (λ x3, wcel (cv y) (B2 x3))
      (λ x3, @eleq2i (A2 x3) (B2 x3) (cv y)
        (nfceqi_1 x3))))
  (@df_nfc (λ x3, A2 x3))
  (@df_nfc (λ x3, B2 x3))


/-- A utility lemma to transfer a bound-variable hypothesis builder into a definition. (Contributed
by Mario Carneiro, 11-Aug-2016.) -/
theorem nfcxfr {A2 B2 : setvar → «class»}
  (nfcxfr_1 : ∀ x3, ⊦ wceq (A2 x3) (B2 x3))
  (nfcxfr_2 : ⊦ wnfc (λ x3, B2 x3)) :
  ⊦ wnfc (λ x3, A2 x3) :=
@mpbir (wnfc (λ x3, A2 x3)) (wnfc (λ x3, B2 x3))
  nfcxfr_2
  (@nfceqi (λ x3, A2 x3) (λ x3, B2 x3)
    (λ x3, nfcxfr_1 x3))


/-- A utility lemma to transfer a bound-variable hypothesis builder into a definition. (Contributed
by Mario Carneiro, 11-Aug-2016.) -/
theorem nfcxfrd {ph : setvar → wff} {A2 B2 : setvar → «class»}
  (nfcxfr_1 : ∀ x3, ⊦ wceq (A2 x3) (B2 x3))
  (nfcxfrd_2 : ∀ x3, ⊦ wi (ph x3) (wnfc (λ x3, B2 x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wnfc (λ x3, A2 x3)) :=
@sylibr (ph x3) (wnfc (λ x3, B2 x3)) (wnfc (λ x3, A2 x3))
  (nfcxfrd_2 x3)
  (@nfceqi (λ x3, A2 x3) (λ x3, B2 x3)
    (λ x3, nfcxfr_1 x3))


/-- If ` x ` is disjoint from ` A ` , then ` x ` is not free in ` A ` . (Contributed by Mario
Carneiro, 11-Aug-2016.) -/
theorem nfcv {A2 : «class»} :
  ⊦ wnfc (λ x3, A2) :=
@nfci (λ x3, A2)
  (λ y, @nfv (wcel (cv y) A2))


/-- If ` x ` is disjoint from ` A ` , then ` x ` is not free in ` A ` . (Contributed by Mario
Carneiro, 7-Oct-2016.) -/
theorem nfcvd {ph : setvar → wff} {A2 : «class»}
  (x3 : setvar) : ⊦ wi (ph x3) (wnfc (λ x3, A2)) :=
@a1i (wnfc (λ x3, A2)) (ph x3)
  (@nfcv A2)


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by Mario Carneiro,
11-Aug-2016.) -/
theorem nfab1 {ph : setvar → wff} :
  ⊦ wnfc (λ x3, cab (λ x3, ph x3)) :=
@nfci (λ x3, cab (λ x3, ph x3))
  (λ y, @nfsab1 (λ x3 y, ph x3) y)


/-- The setvar ` x ` is bound in ` F/_ x A ` . (Contributed by Mario Carneiro, 11-Aug-2016.) -/
theorem nfnfc1 {A2 : setvar → «class»} :
  ⊦ wnf (λ x3, wnfc (λ x3, A2 x3)) :=
@nfxfr (λ x3, wnfc (λ x3, A2 x3)) (λ x3, wal (λ y, wnf (λ x3, wcel (cv y) (A2 x3))))
  (λ x3, @df_nfc (λ x3, A2 x3))
  (@nfal (λ x3 y, wnf (λ x3, wcel (cv y) (A2 x3)))
    (λ y, @nfnf1 (λ x3, wcel (cv y) (A2 x3))))


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by Mario Carneiro,
11-Aug-2016.) Add disjoint variable condition to avoid ~ ax-13 . See ~ nfabg for a less restrictive
version requiring more axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem nfab {ph : setvar → setvar → wff}
  (nfab_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y)) :
  ⊦ wnfc (λ x3, cab (λ y, ph x3 y)) :=
@nfci (λ x3, cab (λ y, ph x3 y))
  (λ z, @nfsab (λ x3 y, ph x3 y) z
    (λ y, nfab_1 y))


/-- Bound-variable hypothesis builder for a class abstraction. (Contributed by Mario Carneiro,
14-Oct-2016.) Add disjoint variable condition to avoid ~ ax-13 . See ~ nfaba1g for a less
restrictive version requiring more axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem nfaba1 {ph : setvar → setvar → wff} :
  ⊦ wnfc (λ x3, cab (λ y, wal (λ x3, ph x3 y))) :=
@nfab (λ x3 y, wal (λ x3, ph x3 y))
  (λ y, @nfa1 (λ x3, ph x3 y))


/-- Hypothesis builder for equality. (Contributed by Mario Carneiro, 7-Oct-2016.) -/
theorem nfeqd {ph : setvar → wff} {A2 B2 : setvar → «class»}
  (nfeqd_1 : ∀ x3, ⊦ wi (ph x3) (wnfc (λ x3, A2 x3)))
  (nfeqd_2 : ∀ x3, ⊦ wi (ph x3) (wnfc (λ x3, B2 x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, wceq (A2 x3) (B2 x3))) :=
@nfxfrd (λ x3, wceq (A2 x3) (B2 x3)) (λ x3, wal (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))) (λ x3, ph x3)
  (λ x3, @dfcleq (A2 x3) (B2 x3))
  (λ x3, setvar.forget $ λ y : setvar,
    show ⊦ wi (ph x3) (wnf (λ x3, wal (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3))))), from
    @nfald (λ x3 y, ph x3) (λ x3 y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))
      (λ x3, @nfv (ph x3))
      (λ x3 y, @nfbid (λ x3, ph x3) (λ x3, wcel (cv y) (A2 x3)) (λ x3, wcel (cv y) (B2 x3))
        (λ x3, @«19_21bi» (λ y, ph x3) (λ y, wnf (λ x3, wcel (cv y) (A2 x3)))
          (λ y, @sylib (ph x3) (wnfc (λ x3, A2 x3)) (wal (λ y, wnf (λ x3, wcel (cv y) (A2 x3))))
            (nfeqd_1 x3)
            (@df_nfc (λ x3, A2 x3))) y)
        (λ x3, @«19_21bi» (λ y, ph x3) (λ y, wnf (λ x3, wcel (cv y) (B2 x3)))
          (λ y, @sylib (ph x3) (wnfc (λ x3, B2 x3)) (wal (λ y, wnf (λ x3, wcel (cv y) (B2 x3))))
            (nfeqd_2 x3)
            (@df_nfc (λ x3, B2 x3))) y) x3) x3 y) x3


/-- Hypothesis builder for elementhood. (Contributed by Mario Carneiro, 7-Oct-2016.) -/
theorem nfeld {ph : setvar → wff} {A2 B2 : setvar → «class»}
  (nfeqd_1 : ∀ x3, ⊦ wi (ph x3) (wnfc (λ x3, A2 x3)))
  (nfeqd_2 : ∀ x3, ⊦ wi (ph x3) (wnfc (λ x3, B2 x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wnf (λ x3, wcel (A2 x3) (B2 x3))) :=
@nfxfrd (λ x3, wcel (A2 x3) (B2 x3)) (λ x3, wex (λ y, wa (wceq (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))) (λ x3, ph x3)
  (λ x3, @dfclel (A2 x3) (B2 x3))
  (λ x3, setvar.forget $ λ y : setvar,
    show ⊦ wi (ph x3) (wnf (λ x3, wex (λ y, wa (wceq (cv y) (A2 x3)) (wcel (cv y) (B2 x3))))), from
    @nfexd (λ x3 y, ph x3) (λ x3 y, wa (wceq (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))
      (λ x3, @nfv (ph x3))
      (λ x3 y, @nfand (λ x3, ph x3) (λ x3, wceq (cv y) (A2 x3)) (λ x3, wcel (cv y) (B2 x3))
        (λ x3, @nfeqd (λ x3, ph x3) (λ x3, cv y) (λ x3, A2 x3)
          (λ x3, @nfcvd (λ x3, ph x3) (cv y) x3)
          (λ x3, nfeqd_1 x3) x3)
        (λ x3, @nfcrd (λ x3 y, ph x3) (λ x3 y, B2 x3)
          (λ x3 y, nfeqd_2 x3) x3 y) x3) x3 y) x3


/-- Hypothesis builder for equality. (Contributed by NM, 21-Jun-1993.) (Revised by Mario Carneiro,
11-Aug-2016.) (Proof shortened by Wolf Lammen, 16-Nov-2019.) -/
theorem nfeq {A2 B2 : setvar → «class»}
  (nfnfc_1 : ⊦ wnfc (λ x3, A2 x3))
  (nfeq_2 : ⊦ wnfc (λ x3, B2 x3)) :
  ⊦ wnf (λ x3, wceq (A2 x3) (B2 x3)) :=
@mptru (wnf (λ x3, wceq (A2 x3) (B2 x3)))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi wtru (wnf (λ x3, wceq (A2 x3) (B2 x3))), from
    @nfeqd (λ x3, wtru) (λ x3, A2 x3) (λ x3, B2 x3)
      (λ x3, @a1i (wnfc (λ x3, A2 x3)) wtru
        nfnfc_1)
      (λ x3, @a1i (wnfc (λ x3, B2 x3)) wtru
        nfeq_2) x3)


/-- Hypothesis builder for elementhood. (Contributed by NM, 1-Aug-1993.) (Revised by Mario Carneiro,
11-Aug-2016.) (Proof shortened by Wolf Lammen, 16-Nov-2019.) -/
theorem nfel {A2 B2 : setvar → «class»}
  (nfnfc_1 : ⊦ wnfc (λ x3, A2 x3))
  (nfeq_2 : ⊦ wnfc (λ x3, B2 x3)) :
  ⊦ wnf (λ x3, wcel (A2 x3) (B2 x3)) :=
@mptru (wnf (λ x3, wcel (A2 x3) (B2 x3)))
  (setvar.forget $ λ x3 : setvar,
    show ⊦ wi wtru (wnf (λ x3, wcel (A2 x3) (B2 x3))), from
    @nfeld (λ x3, wtru) (λ x3, A2 x3) (λ x3, B2 x3)
      (λ x3, @a1i (wnfc (λ x3, A2 x3)) wtru
        nfnfc_1)
      (λ x3, @a1i (wnfc (λ x3, B2 x3)) wtru
        nfeq_2) x3)


/-- Hypothesis builder for equality, special case. (Contributed by Mario Carneiro, 10-Oct-2016.) -/
theorem nfeq1 {A2 : setvar → «class»} {B2 : «class»}
  (nfeq1_1 : ⊦ wnfc (λ x3, A2 x3)) :
  ⊦ wnf (λ x3, wceq (A2 x3) B2) :=
@nfeq (λ x3, A2 x3) (λ x3, B2)
  nfeq1_1
  (@nfcv B2)


/-- Hypothesis builder for elementhood, special case. (Contributed by Mario Carneiro, 10-Oct-2016.)
-/
theorem nfel1 {A2 : setvar → «class»} {B2 : «class»}
  (nfeq1_1 : ⊦ wnfc (λ x3, A2 x3)) :
  ⊦ wnf (λ x3, wcel (A2 x3) B2) :=
@nfel (λ x3, A2 x3) (λ x3, B2)
  nfeq1_1
  (@nfcv B2)


/-- Hypothesis builder for equality, special case. (Contributed by Mario Carneiro, 10-Oct-2016.) -/
theorem nfeq2 {A2 : «class»} {B2 : setvar → «class»}
  (nfeq2_1 : ⊦ wnfc (λ x3, B2 x3)) :
  ⊦ wnf (λ x3, wceq A2 (B2 x3)) :=
@nfeq (λ x3, A2) (λ x3, B2 x3)
  (@nfcv A2)
  nfeq2_1


/-- Hypothesis builder for elementhood, special case. (Contributed by Mario Carneiro, 10-Oct-2016.)
-/
theorem nfel2 {A2 : «class»} {B2 : setvar → «class»}
  (nfeq2_1 : ⊦ wnfc (λ x3, B2 x3)) :
  ⊦ wnf (λ x3, wcel A2 (B2 x3)) :=
@nfel (λ x3, A2) (λ x3, B2 x3)
  (@nfcv A2)
  nfeq2_1


/-- Bound-variable hypothesis builder for a class abstraction. Version of ~ nfabd with a disjoint
variable condition, which does not require ~ ax-13 . (Contributed by Mario Carneiro, 8-Oct-2016.)
(Revised by Gino Giotto, 10-Jan-2024.) (Proof shortened by Wolf Lammen, 23-Sep-2024.) -/
theorem nfabdw {ph ps : setvar → setvar → wff}
  (nfabdw_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (nfabdw_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ps x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnfc (λ x3, cab (λ y, ps x3 y))) :=
setvar.forget $ λ z : setvar,
  show ⊦ wi (ph x3 y) (wnfc (λ x3, cab (λ y, ps x3 y))), from
  @nfcd (λ x3 z, ph x3 y) (λ x3, cab (λ y, ps x3 y))
    (λ x3, @nfv (ph x3 y))
    (λ x3 z, @nfxfrd (λ x3, wcel (cv z) (cab (λ y, ps x3 y))) (λ x3, wal (λ y, wi (wceq (cv y) (cv z)) (ps x3 y))) (λ x3, ph x3 y)
      (λ x3, @bitri (wcel (cv z) (cab (λ y, ps x3 y))) (wsb (λ y, ps x3 y) z) (wal (λ y, wi (wceq (cv y) (cv z)) (ps x3 y)))
        (@df_clab (λ y, ps x3 y) z)
        (@sb6 (λ y z, ps x3 y) z))
      (λ x3, @nfald (λ x3 y, ph x3 y) (λ x3 y, wi (wceq (cv y) (cv z)) (ps x3 y))
        (λ x3, nfabdw_1 x3)
        (λ x3 y, @nfimd (λ x3, ph x3 y) (λ x3, wceq (cv y) (cv z)) (λ x3, ps x3 y)
          (λ x3, @nfvd (λ x3, ph x3 y) (wceq (cv y) (cv z)) x3)
          (λ x3, nfabdw_2 x3 y) x3) x3 y) x3) x3 z


/-- Establish equality between classes, using bound-variable hypotheses instead of distinct variable
conditions as in ~ dfcleq . See also ~ cleqh . (Contributed by NM, 26-May-1993.) (Revised by Mario
Carneiro, 7-Oct-2016.) (Proof shortened by Wolf Lammen, 17-Nov-2019.) Avoid ~ ax-13 . (Revised by
Wolf Lammen, 10-May-2023.) Avoid ~ ax-10 . (Revised by Gino Giotto, 20-Aug-2023.) -/
theorem cleqf {A2 B2 : setvar → «class»}
  (cleqf_1 : ⊦ wnfc (λ x3, A2 x3))
  (cleqf_2 : ⊦ wnfc (λ x3, B2 x3))
  (x3 : setvar) : ⊦ wb (wceq (A2 x3) (B2 x3)) (wal (λ x3, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3)))) :=
@bitr4i (wceq (A2 x3) (B2 x3)) (wal (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))) (wal (λ x3, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3))))
  (@dfcleq (A2 x3) (B2 x3))
  (setvar.forget $ λ y : setvar,
    show ⊦ wb (wal (λ x3, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3)))) (wal (λ y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))), from
    @cbvalv1 (λ x3 y, wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3))) (λ x3 y, wb (wcel (cv y) (A2 x3)) (wcel (cv y) (B2 x3)))
      (λ x3, @nfv (wb (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3))))
      (λ y, @nfbi (λ x3, wcel (cv y) (A2 x3)) (λ x3, wcel (cv y) (B2 x3))
        (@nfcri (λ x3 y, A2 x3)
          (λ y, cleqf_1) y)
        (@nfcri (λ x3 y, B2 x3)
          (λ y, cleqf_2) y))
      (λ x3 y, @bibi12d (wceq (cv x3) (cv y)) (wcel (cv x3) (A2 x3)) (wcel (cv y) (A2 x3)) (wcel (cv x3) (B2 x3)) (wcel (cv y) (B2 x3))
        (@eleq1w (λ x3 y, A2 x3) x3 y)
        (@eleq1w (λ x3 y, B2 x3) x3 y)) x3 y)


-- /-- Extend wff notation to include inequality. -/
-- constant wne : «class» → «class» → wff


-- /-- Define inequality. (Contributed by NM, 26-May-1993.) -/
-- axiom df_ne {A2 B2 : «class»} : ⊦ wb (wne A2 B2) (wn (wceq A2 B2))


/-- Inference associated with ~ df-ne . (Contributed by BJ, 7-Jul-2018.) -/
theorem neii {A2 B2 : «class»}
  (neii_1 : ⊦ wne A2 B2) :
  ⊦ wn (wceq A2 B2) :=
@mpbi (wne A2 B2) (wn (wceq A2 B2))
  neii_1
  (@df_ne A2 B2)


/-- Inference associated with ~ df-ne . (Contributed by BJ, 7-Jul-2018.) -/
theorem neir {A2 B2 : «class»}
  (neir_1 : ⊦ wn (wceq A2 B2)) :
  ⊦ wne A2 B2 :=
@mpbir (wne A2 B2) (wn (wceq A2 B2))
  neir_1
  (@df_ne A2 B2)


/-- Negation of inequality. (Contributed by NM, 9-Jun-2006.) -/
theorem nne {A2 B2 : «class»} :
  ⊦ wb (wn (wne A2 B2)) (wceq A2 B2) :=
@bicomi (wceq A2 B2) (wn (wne A2 B2))
  (@con2bii (wne A2 B2) (wceq A2 B2)
    (@df_ne A2 B2))


/-- Deduction eliminating inequality definition. (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) -/
theorem neneqd {ph : wff} {A2 B2 : «class»}
  (neneqd_1 : ⊦ wi ph (wne A2 B2)) :
  ⊦ wi ph (wn (wceq A2 B2)) :=
@sylib ph (wne A2 B2) (wn (wceq A2 B2))
  neneqd_1
  (@df_ne A2 B2)


/-- From inequality to non-equality. (Contributed by Glauco Siliprandi, 11-Dec-2019.) -/
theorem neneq {A2 B2 : «class»} :
  ⊦ wi (wne A2 B2) (wn (wceq A2 B2)) :=
@neneqd (wne A2 B2) A2 B2
  (@id (wne A2 B2))


/-- If it is not the case that two classes are equal, then they are unequal. Converse of ~ neneqd .
One-way deduction form of ~ df-ne . (Contributed by David Moews, 28-Feb-2017.) Allow a shortening of
~ necon3bi . (Revised by Wolf Lammen, 22-Nov-2019.) -/
theorem neqned {ph : wff} {A2 B2 : «class»}
  (neqned_1 : ⊦ wi ph (wn (wceq A2 B2))) :
  ⊦ wi ph (wne A2 B2) :=
@sylibr ph (wn (wceq A2 B2)) (wne A2 B2)
  neqned_1
  (@df_ne A2 B2)


/-- From non-equality to inequality. (Contributed by Glauco Siliprandi, 11-Dec-2019.) -/
theorem neqne {A2 B2 : «class»} :
  ⊦ wi (wn (wceq A2 B2)) (wne A2 B2) :=
@neqned (wn (wceq A2 B2)) A2 B2
  (@id (wn (wceq A2 B2)))


/-- No class is unequal to itself. Inequality is irreflexive. (Contributed by Stefan O'Rear,
1-Jan-2015.) -/
theorem neirr {A2 : «class»} :
  ⊦ wn (wne A2 A2) :=
@mpbir (wn (wne A2 A2)) (wceq A2 A2)
  (@eqid A2)
  (@nne A2 A2)


/-- Excluded middle with equality and inequality. (Contributed by NM, 3-Feb-2012.) (Proof shortened
by Wolf Lammen, 17-Nov-2019.) -/
theorem exmidne {A2 B2 : «class»} :
  ⊦ wo (wceq A2 B2) (wne A2 B2) :=
@orri (wceq A2 B2) (wne A2 B2)
  (@neqne A2 B2)


/-- A contradiction concerning equality implies anything. (Contributed by Alexander van der Vekens,
25-Jan-2018.) -/
theorem eqneqall {ph : wff} {A2 B2 : «class»} :
  ⊦ wi (wceq A2 B2) (wi (wne A2 B2) ph) :=
@syl5bi (wne A2 B2) (wn (wceq A2 B2)) (wceq A2 B2) ph
  (@df_ne A2 B2)
  (@pm2_24 (wceq A2 B2) ph)


/-- Contrapositive law deduction for inequality. (Contributed by NM, 2-Apr-2007.) (Proof shortened
by Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 23-Nov-2019.) -/
theorem necon3ad {ph ps : wff} {A2 B2 : «class»}
  (necon3ad_1 : ⊦ wi ph (wi ps (wceq A2 B2))) :
  ⊦ wi ph (wi (wne A2 B2) (wn ps)) :=
@nsyli ph ps (wceq A2 B2) (wne A2 B2)
  necon3ad_1
  (@neneq A2 B2)


/-- Contrapositive law deduction for inequality. (Contributed by NM, 2-Apr-2007.) (Proof shortened
by Andrew Salmon, 25-May-2011.) -/
theorem necon3bd {ph ps : wff} {A2 B2 : «class»}
  (necon3bd_1 : ⊦ wi ph (wi (wceq A2 B2) ps)) :
  ⊦ wi ph (wi (wn ps) (wne A2 B2)) :=
@con1d ph (wne A2 B2) ps
  (@syl5bi (wn (wne A2 B2)) (wceq A2 B2) ph ps
    (@nne A2 B2)
    necon3bd_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 19-Apr-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 23-Nov-2019.) -/
theorem necon2ad {ph ps : wff} {A2 B2 : «class»}
  (necon2ad_1 : ⊦ wi ph (wi (wceq A2 B2) (wn ps))) :
  ⊦ wi ph (wi ps (wne A2 B2)) :=
@syl5 ps (wn (wn ps)) ph (wne A2 B2)
  (@notnot ps)
  (@necon3bd ph (wn ps) A2 B2
    necon2ad_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 13-Apr-2007.) -/
theorem necon2bd {ph ps : wff} {A2 B2 : «class»}
  (necon2bd_1 : ⊦ wi ph (wi ps (wne A2 B2))) :
  ⊦ wi ph (wi (wceq A2 B2) (wn ps)) :=
@con2d ph ps (wceq A2 B2)
  (@syl6ib ph ps (wne A2 B2) (wn (wceq A2 B2))
    necon2bd_1
    (@df_ne A2 B2))


/-- Contrapositive deduction for inequality. (Contributed by NM, 2-Apr-2007.) (Proof shortened by
Wolf Lammen, 23-Nov-2019.) -/
theorem necon1ad {ph ps : wff} {A2 B2 : «class»}
  (necon1ad_1 : ⊦ wi ph (wi (wn ps) (wceq A2 B2))) :
  ⊦ wi ph (wi (wne A2 B2) ps) :=
@syl6 ph (wne A2 B2) (wn (wn ps)) ps
  (@necon3ad ph (wn ps) A2 B2
    necon1ad_1)
  (@notnotr ps)


/-- Contrapositive deduction for inequality. (Contributed by NM, 21-Mar-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 23-Nov-2019.) -/
theorem necon1bd {ph ps : wff} {A2 B2 : «class»}
  (necon1bd_1 : ⊦ wi ph (wi (wne A2 B2) ps)) :
  ⊦ wi ph (wi (wn ps) (wceq A2 B2)) :=
@con1d ph (wceq A2 B2) ps
  (@syl5bir (wn (wceq A2 B2)) (wne A2 B2) ph ps
    (@df_ne A2 B2)
    necon1bd_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 2-Apr-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 23-Nov-2019.) -/
theorem necon4ad {ph ps : wff} {A2 B2 : «class»}
  (necon4ad_1 : ⊦ wi ph (wi (wne A2 B2) (wn ps))) :
  ⊦ wi ph (wi ps (wceq A2 B2)) :=
@syl5 ps (wn (wn ps)) ph (wceq A2 B2)
  (@notnot ps)
  (@necon1bd ph (wn ps) A2 B2
    necon4ad_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 1-Jun-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 23-Nov-2019.) -/
theorem necon4bd {ph ps : wff} {A2 B2 : «class»}
  (necon4bd_1 : ⊦ wi ph (wi (wn ps) (wne A2 B2))) :
  ⊦ wi ph (wi (wceq A2 B2) ps) :=
@syl6 ph (wceq A2 B2) (wn (wn ps)) ps
  (@necon2bd ph (wn ps) A2 B2
    necon4bd_1)
  (@notnotr ps)


/-- Contrapositive law deduction for inequality. (Contributed by NM, 10-Jun-2006.) -/
theorem necon3d {ph : wff} {A2 B2 C D : «class»}
  (necon3d_1 : ⊦ wi ph (wi (wceq A2 B2) (wceq C D))) :
  ⊦ wi ph (wi (wne C D) (wne A2 B2)) :=
@syl6ibr ph (wne C D) (wn (wceq A2 B2)) (wne A2 B2)
  (@necon3ad ph (wceq A2 B2) C D
    necon3d_1)
  (@df_ne A2 B2)


/-- Contrapositive law deduction for inequality. (Contributed by NM, 28-Dec-2008.) (Proof shortened
by Andrew Salmon, 25-May-2011.) -/
theorem necon1d {ph : wff} {A2 B2 C D : «class»}
  (necon1d_1 : ⊦ wi ph (wi (wne A2 B2) (wceq C D))) :
  ⊦ wi ph (wi (wne C D) (wceq A2 B2)) :=
@necon4ad ph (wne C D) A2 B2
  (@syl6ibr ph (wne A2 B2) (wceq C D) (wn (wne C D))
    necon1d_1
    (@nne C D))


/-- Contrapositive inference for inequality. (Contributed by NM, 28-Dec-2008.) -/
theorem necon2d {ph : wff} {A2 B2 C D : «class»}
  (necon2d_1 : ⊦ wi ph (wi (wceq A2 B2) (wne C D))) :
  ⊦ wi ph (wi (wceq C D) (wne A2 B2)) :=
@necon2ad ph (wceq C D) A2 B2
  (@syl6ib ph (wceq A2 B2) (wne C D) (wn (wceq C D))
    necon2d_1
    (@df_ne C D))


/-- Contrapositive inference for inequality. (Contributed by NM, 2-Apr-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem necon4d {ph : wff} {A2 B2 C D : «class»}
  (necon4d_1 : ⊦ wi ph (wi (wne A2 B2) (wne C D))) :
  ⊦ wi ph (wi (wceq C D) (wceq A2 B2)) :=
@syl6ib ph (wceq C D) (wn (wne A2 B2)) (wceq A2 B2)
  (@necon2bd ph (wne A2 B2) C D
    necon4d_1)
  (@nne A2 B2)


/-- Contrapositive inference for inequality. (Contributed by NM, 23-May-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem necon3ai {ph : wff} {A2 B2 : «class»}
  (necon3ai_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi (wne A2 B2) (wn ph) :=
@con2i ph (wne A2 B2)
  (@sylibr ph (wceq A2 B2) (wn (wne A2 B2))
    necon3ai_1
    (@nne A2 B2))


/-- Contrapositive inference for inequality. (Contributed by NM, 1-Jun-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 22-Nov-2019.) -/
theorem necon3bi {ph : wff} {A2 B2 : «class»}
  (necon3bi_1 : ⊦ wi (wceq A2 B2) ph) :
  ⊦ wi (wn ph) (wne A2 B2) :=
@neqned (wn ph) A2 B2
  (@con3i (wceq A2 B2) ph
    necon3bi_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 12-Feb-2007.) (Proof shortened by
Wolf Lammen, 22-Nov-2019.) -/
theorem necon1ai {ph : wff} {A2 B2 : «class»}
  (necon1ai_1 : ⊦ wi (wn ph) (wceq A2 B2)) :
  ⊦ wi (wne A2 B2) ph :=
@notnotrd (wne A2 B2) ph
  (@necon3ai (wn ph) A2 B2
    necon1ai_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 18-Mar-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 22-Nov-2019.) -/
theorem necon1bi {ph : wff} {A2 B2 : «class»}
  (necon1bi_1 : ⊦ wi (wne A2 B2) ph) :
  ⊦ wi (wn ph) (wceq A2 B2) :=
@con1i (wceq A2 B2) ph
  (@sylbir (wn (wceq A2 B2)) (wne A2 B2) ph
    (@df_ne A2 B2)
    necon1bi_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 16-Jan-2007.) (Proof shortened by
Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 22-Nov-2019.) -/
theorem necon2ai {ph : wff} {A2 B2 : «class»}
  (necon2ai_1 : ⊦ wi (wceq A2 B2) (wn ph)) :
  ⊦ wi ph (wne A2 B2) :=
@neqned ph A2 B2
  (@con2i (wceq A2 B2) ph
    necon2ai_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 1-Apr-2007.) -/
theorem necon2bi {ph : wff} {A2 B2 : «class»}
  (necon2bi_1 : ⊦ wi ph (wne A2 B2)) :
  ⊦ wi (wceq A2 B2) (wn ph) :=
@con2i ph (wceq A2 B2)
  (@neneqd ph A2 B2
    necon2bi_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 9-Aug-2006.) (Proof shortened by
Wolf Lammen, 22-Nov-2019.) -/
theorem necon3i {A2 B2 C D : «class»}
  (necon3i_1 : ⊦ wi (wceq A2 B2) (wceq C D)) :
  ⊦ wi (wne C D) (wne A2 B2) :=
@neqned (wne C D) A2 B2
  (@necon3ai (wceq A2 B2) C D
    necon3i_1)


/-- Deduction from equality to inequality. (Contributed by NM, 21-Mar-2007.) -/
theorem necon3abid {ph ps : wff} {A2 B2 : «class»}
  (necon3abid_1 : ⊦ wi ph (wb (wceq A2 B2) ps)) :
  ⊦ wi ph (wb (wne A2 B2) (wn ps)) :=
@syl5bb (wne A2 B2) (wn (wceq A2 B2)) ph (wn ps)
  (@df_ne A2 B2)
  (@notbid ph (wceq A2 B2) ps
    necon3abid_1)


/-- Deduction from equality to inequality. (Contributed by NM, 2-Jun-2007.) -/
theorem necon3bbid {ph ps : wff} {A2 B2 : «class»}
  (necon3bbid_1 : ⊦ wi ph (wb ps (wceq A2 B2))) :
  ⊦ wi ph (wb (wn ps) (wne A2 B2)) :=
@bicomd ph (wne A2 B2) (wn ps)
  (@necon3abid ph ps A2 B2
    (@bicomd ph ps (wceq A2 B2)
      necon3bbid_1))


/-- Contrapositive deduction for inequality. (Contributed by NM, 21-Aug-2007.) (Proof shortened by
Wolf Lammen, 24-Nov-2019.) -/
theorem necon1abid {ph ps : wff} {A2 B2 : «class»}
  (necon1abid_1 : ⊦ wi ph (wb (wn ps) (wceq A2 B2))) :
  ⊦ wi ph (wb (wne A2 B2) ps) :=
@syl5rbb ps (wn (wn ps)) ph (wne A2 B2)
  (@notnotb ps)
  (@necon3bbid ph (wn ps) A2 B2
    necon1abid_1)


/-- Contrapositive inference for inequality. (Contributed by NM, 31-Jan-2008.) -/
theorem necon1bbid {ph ps : wff} {A2 B2 : «class»}
  (necon1bbid_1 : ⊦ wi ph (wb (wne A2 B2) ps)) :
  ⊦ wi ph (wb (wn ps) (wceq A2 B2)) :=
@con1bid ph (wceq A2 B2) ps
  (@bitr3id (wn (wceq A2 B2)) (wne A2 B2) ph ps
    (@df_ne A2 B2)
    necon1bbid_1)


/-- Contrapositive law deduction for inequality. (Contributed by NM, 11-Jan-2008.) (Proof shortened
by Wolf Lammen, 24-Nov-2019.) -/
theorem necon4abid {ph ps : wff} {A2 B2 : «class»}
  (necon4abid_1 : ⊦ wi ph (wb (wne A2 B2) (wn ps))) :
  ⊦ wi ph (wb (wceq A2 B2) ps) :=
@syl5rbb ps (wn (wn ps)) ph (wceq A2 B2)
  (@notnotb ps)
  (@necon1bbid ph (wn ps) A2 B2
    necon4abid_1)


/-- Contrapositive law deduction for inequality. (Contributed by NM, 9-May-2012.) -/
theorem necon4bbid {ph ps : wff} {A2 B2 : «class»}
  (necon4bbid_1 : ⊦ wi ph (wb (wn ps) (wne A2 B2))) :
  ⊦ wi ph (wb ps (wceq A2 B2)) :=
@bicomd ph (wceq A2 B2) ps
  (@necon4abid ph ps A2 B2
    (@bicomd ph (wn ps) (wne A2 B2)
      necon4bbid_1))


/-- Contrapositive deduction for inequality. (Contributed by NM, 18-Jul-2007.) (Proof shortened by
Wolf Lammen, 24-Nov-2019.) -/
theorem necon2abid {ph ps : wff} {A2 B2 : «class»}
  (necon2abid_1 : ⊦ wi ph (wb (wceq A2 B2) (wn ps))) :
  ⊦ wi ph (wb ps (wne A2 B2)) :=
@bitr4id ph ps (wn (wn ps)) (wne A2 B2)
  (@notnotb ps)
  (@necon3abid ph (wn ps) A2 B2
    necon2abid_1)


/-- Contrapositive deduction for inequality. (Contributed by NM, 13-Apr-2007.) (Proof shortened by
Wolf Lammen, 24-Nov-2019.) -/
theorem necon2bbid {ph ps : wff} {A2 B2 : «class»}
  (necon2bbid_1 : ⊦ wi ph (wb ps (wne A2 B2))) :
  ⊦ wi ph (wb (wceq A2 B2) (wn ps)) :=
@necon4abid ph (wn ps) A2 B2
  (@bitr3di ph ps (wne A2 B2) (wn (wn ps))
    necon2bbid_1
    (@notnotb ps))


/-- Deduction from equality to inequality. (Contributed by NM, 23-Feb-2005.) (Proof shortened by
Andrew Salmon, 25-May-2011.) -/
theorem necon3bid {ph : wff} {A2 B2 C D : «class»}
  (necon3bid_1 : ⊦ wi ph (wb (wceq A2 B2) (wceq C D))) :
  ⊦ wi ph (wb (wne A2 B2) (wne C D)) :=
@syl5bb (wne A2 B2) (wn (wceq A2 B2)) ph (wne C D)
  (@df_ne A2 B2)
  (@necon3bbid ph (wceq A2 B2) C D
    necon3bid_1)


/-- Contrapositive law deduction for inequality. (Contributed by NM, 29-Jun-2007.) -/
theorem necon4bid {ph : wff} {A2 B2 C D : «class»}
  (necon4bid_1 : ⊦ wi ph (wb (wne A2 B2) (wne C D))) :
  ⊦ wi ph (wb (wceq A2 B2) (wceq C D)) :=
@bitr2di ph (wceq C D) (wn (wne A2 B2)) (wceq A2 B2)
  (@necon2bbid ph (wne A2 B2) C D
    necon4bid_1)
  (@nne A2 B2)


/-- Deduction from equality to inequality. (Contributed by NM, 9-Nov-2007.) -/
theorem necon3abii {ph : wff} {A2 B2 : «class»}
  (necon3abii_1 : ⊦ wb (wceq A2 B2) ph) :
  ⊦ wb (wne A2 B2) (wn ph) :=
@xchbinx (wne A2 B2) (wceq A2 B2) ph
  (@df_ne A2 B2)
  necon3abii_1


/-- Deduction from equality to inequality. (Contributed by NM, 13-Apr-2007.) -/
theorem necon3bbii {ph : wff} {A2 B2 : «class»}
  (necon3bbii_1 : ⊦ wb ph (wceq A2 B2)) :
  ⊦ wb (wn ph) (wne A2 B2) :=
@bicomi (wne A2 B2) (wn ph)
  (@necon3abii ph A2 B2
    (@bicomi ph (wceq A2 B2)
      necon3bbii_1))


/-- Contrapositive inference for inequality. (Contributed by NM, 17-Mar-2007.) (Proof shortened by
Wolf Lammen, 24-Nov-2019.) -/
theorem necon1bbii {ph : wff} {A2 B2 : «class»}
  (necon1bbii_1 : ⊦ wb (wne A2 B2) ph) :
  ⊦ wb (wn ph) (wceq A2 B2) :=
@xchnxbi (wne A2 B2) (wceq A2 B2) ph
  (@nne A2 B2)
  necon1bbii_1


/-- Contrapositive inference for inequality. (Contributed by NM, 13-Apr-2007.) -/
theorem necon2bbii {ph : wff} {A2 B2 : «class»}
  (necon2bbii_1 : ⊦ wb ph (wne A2 B2)) :
  ⊦ wb (wceq A2 B2) (wn ph) :=
@bicomi (wn ph) (wceq A2 B2)
  (@necon1bbii ph A2 B2
    (@bicomi ph (wne A2 B2)
      necon2bbii_1))


/-- Inference from equality to inequality. (Contributed by NM, 23-Feb-2005.) -/
theorem necon3bii {A2 B2 C D : «class»}
  (necon3bii_1 : ⊦ wb (wceq A2 B2) (wceq C D)) :
  ⊦ wb (wne A2 B2) (wne C D) :=
@bitr4i (wne A2 B2) (wn (wceq C D)) (wne C D)
  (@necon3abii (wceq C D) A2 B2
    necon3bii_1)
  (@df_ne C D)


/-- Commutation of inequality. (Contributed by NM, 14-May-1999.) -/
theorem necom {A2 B2 : «class»} :
  ⊦ wb (wne A2 B2) (wne B2 A2) :=
@necon3bii A2 B2 B2 A2
  (@eqcom A2 B2)


/-- Inference from commutative law for inequality. (Contributed by NM, 17-Oct-2012.) -/
theorem necomi {A2 B2 : «class»}
  (necomi_1 : ⊦ wne A2 B2) :
  ⊦ wne B2 A2 :=
@mpbi (wne A2 B2) (wne B2 A2)
  necomi_1
  (@necom A2 B2)


/-- Deduction from commutative law for inequality. (Contributed by NM, 12-Feb-2008.) -/
theorem necomd {ph : wff} {A2 B2 : «class»}
  (necomd_1 : ⊦ wi ph (wne A2 B2)) :
  ⊦ wi ph (wne B2 A2) :=
@sylib ph (wne A2 B2) (wne B2 A2)
  necomd_1
  (@necom A2 B2)


/-- Characterization of inequality in terms of reversed equality (see ~ bicom ). (Contributed by BJ,
7-Jul-2018.) -/
theorem nesym {A2 B2 : «class»} :
  ⊦ wb (wne A2 B2) (wn (wceq B2 A2)) :=
@necon3abii (wceq B2 A2) A2 B2
  (@eqcom A2 B2)


/-- Inference associated with ~ nesym . (Contributed by BJ, 7-Jul-2018.) (Proof shortened by Wolf
Lammen, 25-Nov-2019.) -/
theorem nesymi {A2 B2 : «class»}
  (nesymi_1 : ⊦ wne A2 B2) :
  ⊦ wn (wceq B2 A2) :=
@neii B2 A2
  (@necomi A2 B2
    nesymi_1)


/-- Deduction for inequality. (Contributed by NM, 25-Oct-1999.) (Proof shortened by Wolf Lammen,
19-Nov-2019.) -/
theorem neeq1d {ph : wff} {A2 B2 C : «class»}
  (neeq1d_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wb (wne A2 C) (wne B2 C)) :=
@necon3bid ph A2 C B2 C
  (@eqeq1d ph A2 B2 C
    neeq1d_1)


/-- Deduction for inequality. (Contributed by NM, 25-Oct-1999.) (Proof shortened by Wolf Lammen,
19-Nov-2019.) -/
theorem neeq2d {ph : wff} {A2 B2 C : «class»}
  (neeq1d_1 : ⊦ wi ph (wceq A2 B2)) :
  ⊦ wi ph (wb (wne C A2) (wne C B2)) :=
@necon3bid ph C A2 C B2
  (@eqeq2d ph A2 B2 C
    neeq1d_1)


/-- Deduction for inequality. (Contributed by NM, 24-Jul-2012.) (Proof shortened by Wolf Lammen,
25-Nov-2019.) -/
theorem neeq12d {ph : wff} {A2 B2 C D : «class»}
  (neeq1d_1 : ⊦ wi ph (wceq A2 B2))
  (neeq12d_2 : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wb (wne A2 C) (wne B2 D)) :=
@necon3bid ph A2 C B2 D
  (@eqeq12d ph A2 B2 C D
    neeq1d_1
    neeq12d_2)


/-- Equality theorem for inequality. (Contributed by NM, 19-Nov-1994.) (Proof shortened by Wolf
Lammen, 18-Nov-2019.) -/
theorem neeq1 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wne A2 C) (wne B2 C)) :=
@neeq1d (wceq A2 B2) A2 B2 C
  (@id (wceq A2 B2))


/-- Equality theorem for inequality. (Contributed by NM, 19-Nov-1994.) (Proof shortened by Wolf
Lammen, 18-Nov-2019.) -/
theorem neeq2 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wne C A2) (wne C B2)) :=
@neeq2d (wceq A2 B2) A2 B2 C
  (@id (wceq A2 B2))


/-- Inference for inequality. (Contributed by NM, 29-Apr-2005.) (Proof shortened by Wolf Lammen,
19-Nov-2019.) -/
theorem neeq1i {A2 B2 C : «class»}
  (neeq1i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wne A2 C) (wne B2 C) :=
@necon3bii A2 C B2 C
  (@eqeq1i A2 B2 C
    neeq1i_1)


/-- Inference for inequality. (Contributed by NM, 29-Apr-2005.) (Proof shortened by Wolf Lammen,
19-Nov-2019.) -/
theorem neeq2i {A2 B2 C : «class»}
  (neeq1i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wne C A2) (wne C B2) :=
@necon3bii C A2 C B2
  (@eqeq2i A2 B2 C
    neeq1i_1)


/-- Inference for inequality. (Contributed by NM, 24-Jul-2012.) (Proof shortened by Wolf Lammen,
25-Nov-2019.) -/
theorem neeq12i {A2 B2 C D : «class»}
  (neeq1i_1 : ⊦ wceq A2 B2)
  (neeq12i_2 : ⊦ wceq C D) :
  ⊦ wb (wne A2 C) (wne B2 D) :=
@necon3bii A2 C B2 D
  (@eqeq12i A2 B2 C D
    neeq1i_1
    neeq12i_2)


/-- Substitution of equal classes into an inequality. (Contributed by NM, 4-Jul-2012.) -/
theorem eqnetrd {ph : wff} {A2 B2 C : «class»}
  (eqnetrd_1 : ⊦ wi ph (wceq A2 B2))
  (eqnetrd_2 : ⊦ wi ph (wne B2 C)) :
  ⊦ wi ph (wne A2 C) :=
@mpbird ph (wne A2 C) (wne B2 C)
  eqnetrd_2
  (@neeq1d ph A2 B2 C
    eqnetrd_1)


/-- Substitution of equal classes into an inequality. (Contributed by NM, 4-Jul-2012.) -/
theorem eqnetrrd {ph : wff} {A2 B2 C : «class»}
  (eqnetrrd_1 : ⊦ wi ph (wceq A2 B2))
  (eqnetrrd_2 : ⊦ wi ph (wne A2 C)) :
  ⊦ wi ph (wne B2 C) :=
@eqnetrd ph B2 A2 C
  (@eqcomd ph A2 B2
    eqnetrrd_1)
  eqnetrrd_2


/-- Substitution of equal classes into an inequality. (Contributed by NM, 4-Jul-2012.) -/
theorem neeqtrd {ph : wff} {A2 B2 C : «class»}
  (neeqtrd_1 : ⊦ wi ph (wne A2 B2))
  (neeqtrd_2 : ⊦ wi ph (wceq B2 C)) :
  ⊦ wi ph (wne A2 C) :=
@mpbid ph (wne A2 B2) (wne A2 C)
  neeqtrd_1
  (@neeq2d ph B2 C A2
    neeqtrd_2)


/-- Substitution of equal classes into an inequality. (Contributed by NM, 4-Jul-2012.) -/
theorem eqnetri {A2 B2 C : «class»}
  (eqnetr_1 : ⊦ wceq A2 B2)
  (eqnetr_2 : ⊦ wne B2 C) :
  ⊦ wne A2 C :=
@mpbir (wne A2 C) (wne B2 C)
  eqnetr_2
  (@neeq1i A2 B2 C
    eqnetr_1)


/-- Substitution of equal classes into an inequality. (Contributed by NM, 4-Jul-2012.) -/
theorem neeqtri {A2 B2 C : «class»}
  (neeqtr_1 : ⊦ wne A2 B2)
  (neeqtr_2 : ⊦ wceq B2 C) :
  ⊦ wne A2 C :=
@mpbi (wne A2 B2) (wne A2 C)
  neeqtr_1
  (@neeq2i B2 C A2
    neeqtr_2)


/-- Substitution of equal classes into an inequality. (Contributed by NM, 4-Jul-2012.) -/
theorem neeqtrri {A2 B2 C : «class»}
  (neeqtrr_1 : ⊦ wne A2 B2)
  (neeqtrr_2 : ⊦ wceq C B2) :
  ⊦ wne A2 C :=
@neeqtri A2 B2 C
  neeqtrr_1
  (@eqcomi C B2
    neeqtrr_2)


/-- Substitution of equal classes into an inequality. (Contributed by NM, 4-Jul-2012.) -/
theorem neeqtrrd {ph : wff} {A2 B2 C : «class»}
  (neeqtrrd_1 : ⊦ wi ph (wne A2 B2))
  (neeqtrrd_2 : ⊦ wi ph (wceq C B2)) :
  ⊦ wi ph (wne A2 C) :=
@neeqtrd ph A2 B2 C
  neeqtrrd_1
  (@eqcomd ph C B2
    neeqtrrd_2)


/-- Substitution of equality into both sides of an inequality. (Contributed by NM, 24-Jul-2012.)
(Proof shortened by Wolf Lammen, 19-Nov-2019.) -/
theorem «3netr3d» {ph : wff} {A2 B2 C D : «class»}
  («3netr3d_1» : ⊦ wi ph (wne A2 B2))
  («3netr3d_2» : ⊦ wi ph (wceq A2 C))
  («3netr3d_3» : ⊦ wi ph (wceq B2 D)) :
  ⊦ wi ph (wne C D) :=
@eqnetrrd ph A2 C D
  «3netr3d_2»
  (@neeqtrd ph A2 B2 D
    «3netr3d_1»
    «3netr3d_3»)


/-- Substitution of equality into both sides of an inequality. (Contributed by NM, 24-Jul-2012.)
(Proof shortened by Wolf Lammen, 21-Nov-2019.) -/
theorem «3netr4d» {ph : wff} {A2 B2 C D : «class»}
  («3netr4d_1» : ⊦ wi ph (wne A2 B2))
  («3netr4d_2» : ⊦ wi ph (wceq C A2))
  («3netr4d_3» : ⊦ wi ph (wceq D B2)) :
  ⊦ wi ph (wne C D) :=
@neeqtrrd ph C B2 D
  (@eqnetrd ph C A2 B2
    «3netr4d_2»
    «3netr4d_1»)
  «3netr4d_3»


/-- Inference eliminating an inequality in an antecedent. (Contributed by NM, 16-Jan-2007.) (Proof
shortened by Andrew Salmon, 25-May-2011.) -/
theorem pm2_61ine {ph : wff} {A2 B2 : «class»}
  (pm2_61ine_1 : ⊦ wi (wceq A2 B2) ph)
  (pm2_61ine_2 : ⊦ wi (wne A2 B2) ph) :
  ⊦ ph :=
@pm2_61i (wne A2 B2) ph
  pm2_61ine_2
  (@sylbi (wn (wne A2 B2)) (wceq A2 B2) ph
    (@nne A2 B2)
    pm2_61ine_1)


/-- A contradiction implies anything. Equality/inequality deduction form. (Contributed by David
Moews, 28-Feb-2017.) -/
theorem pm2_21ddne {ph ps : wff} {A2 B2 : «class»}
  (pm2_21ddne_1 : ⊦ wi ph (wceq A2 B2))
  (pm2_21ddne_2 : ⊦ wi ph (wne A2 B2)) :
  ⊦ wi ph ps :=
@pm2_21dd ph (wceq A2 B2) ps
  pm2_21ddne_1
  (@neneqd ph A2 B2
    pm2_21ddne_2)


/-- Deduction eliminating an inequality in an antecedent. (Contributed by NM, 24-May-2006.) (Proof
shortened by Andrew Salmon, 25-May-2011.) (Proof shortened by Wolf Lammen, 25-Nov-2019.) -/
theorem pm2_61ne {ph ps ch : wff} {A2 B2 : «class»}
  (pm2_61ne_1 : ⊦ wi (wceq A2 B2) (wb ps ch))
  (pm2_61ne_2 : ⊦ wi (wa ph (wne A2 B2)) ps)
  (pm2_61ne_3 : ⊦ wi ph ch) :
  ⊦ wi ph ps :=
@pm2_61ine (wi ph ps) A2 B2
  (@syl5ibr ph ps (wceq A2 B2) ch
    pm2_61ne_3
    pm2_61ne_1)
  (@expcom ph (wne A2 B2) ps
    pm2_61ne_2)


/-- Deduction eliminating an inequality in an antecedent. (Contributed by NM, 1-Jun-2007.) (Proof
shortened by Andrew Salmon, 25-May-2011.) -/
theorem pm2_61dne {ph ps : wff} {A2 B2 : «class»}
  (pm2_61dne_1 : ⊦ wi ph (wi (wceq A2 B2) ps))
  (pm2_61dne_2 : ⊦ wi ph (wi (wne A2 B2) ps)) :
  ⊦ wi ph ps :=
@pm2_61d ph (wne A2 B2) ps
  pm2_61dne_2
  (@syl5bi (wn (wne A2 B2)) (wceq A2 B2) ph ps
    (@nne A2 B2)
    pm2_61dne_1)


/-- Deduction eliminating an inequality in an antecedent. (Contributed by NM, 30-Nov-2011.) -/
theorem pm2_61dane {ph ps : wff} {A2 B2 : «class»}
  (pm2_61dane_1 : ⊦ wi (wa ph (wceq A2 B2)) ps)
  (pm2_61dane_2 : ⊦ wi (wa ph (wne A2 B2)) ps) :
  ⊦ wi ph ps :=
@pm2_61dne ph ps A2 B2
  (@ex ph (wceq A2 B2) ps
    pm2_61dane_1)
  (@ex ph (wne A2 B2) ps
    pm2_61dane_2)


/-- Logical OR with an equality. (Contributed by NM, 29-Apr-2007.) -/
theorem neor {ps : wff} {A2 B2 : «class»} :
  ⊦ wb (wo (wceq A2 B2) ps) (wi (wne A2 B2) ps) :=
@bitr4i (wo (wceq A2 B2) ps) (wi (wn (wceq A2 B2)) ps) (wi (wne A2 B2) ps)
  (@df_or (wceq A2 B2) ps)
  (@imbi1i (wne A2 B2) (wn (wceq A2 B2)) ps
    (@df_ne A2 B2))


/-- A De Morgan's law for inequality. (Contributed by NM, 18-May-2007.) -/
theorem neanior {A2 B2 C D : «class»} :
  ⊦ wb (wa (wne A2 B2) (wne C D)) (wn (wo (wceq A2 B2) (wceq C D))) :=
@bitri (wa (wne A2 B2) (wne C D)) (wa (wn (wceq A2 B2)) (wn (wceq C D))) (wn (wo (wceq A2 B2) (wceq C D)))
  (@anbi12i (wne A2 B2) (wn (wceq A2 B2)) (wne C D) (wn (wceq C D))
    (@df_ne A2 B2)
    (@df_ne C D))
  (@pm4_56 (wceq A2 B2) (wceq C D))


/-- A De Morgan's law for inequality. (Contributed by NM, 18-May-2007.) -/
theorem neorian {A2 B2 C D : «class»} :
  ⊦ wb (wo (wne A2 B2) (wne C D)) (wn (wa (wceq A2 B2) (wceq C D))) :=
@bitr4i (wo (wne A2 B2) (wne C D)) (wo (wn (wceq A2 B2)) (wn (wceq C D))) (wn (wa (wceq A2 B2) (wceq C D)))
  (@orbi12i (wne A2 B2) (wn (wceq A2 B2)) (wne C D) (wn (wceq C D))
    (@df_ne A2 B2)
    (@df_ne C D))
  (@ianor (wceq A2 B2) (wceq C D))


/-- Two classes are different if they don't contain the same element. (Contributed by NM,
3-Feb-2012.) (Proof shortened by Wolf Lammen, 14-May-2023.) -/
theorem nelne1 {A2 B2 C : «class»} :
  ⊦ wi (wa (wcel A2 B2) (wn (wcel A2 C))) (wne B2 C) :=
@neqned (wa (wcel A2 B2) (wn (wcel A2 C))) B2 C
  (@nelneq2 A2 B2 C)


/-- Two classes are different if they don't belong to the same class. (Contributed by NM,
25-Jun-2012.) (Proof shortened by Wolf Lammen, 14-May-2023.) -/
theorem nelne2 {A2 B2 C : «class»} :
  ⊦ wi (wa (wcel A2 C) (wn (wcel B2 C))) (wne A2 B2) :=
@neqned (wa (wcel A2 C) (wn (wcel B2 C))) A2 B2
  (@nelneq A2 B2 C)


/-- Two classes are different if they don't belong to the same class. (Contributed by Rodolfo
Medina, 17-Oct-2010.) (Proof shortened by AV, 10-May-2020.) -/
theorem nelelne {A2 B2 C : «class»} :
  ⊦ wi (wn (wcel A2 B2)) (wi (wcel C B2) (wne C A2)) :=
@expcom (wcel C B2) (wn (wcel A2 B2)) (wne C A2)
  (@nelne2 C A2 B2)


/-- Bound-variable hypothesis builder for inequality. (Contributed by NM, 10-Nov-2007.) (Revised by
Mario Carneiro, 7-Oct-2016.) -/
theorem nfne {A2 B2 : setvar → «class»}
  (nfne_1 : ⊦ wnfc (λ x3, A2 x3))
  (nfne_2 : ⊦ wnfc (λ x3, B2 x3)) :
  ⊦ wnf (λ x3, wne (A2 x3) (B2 x3)) :=
@nfxfr (λ x3, wne (A2 x3) (B2 x3)) (λ x3, wn (wceq (A2 x3) (B2 x3)))
  (λ x3, @df_ne (A2 x3) (B2 x3))
  (@nfn (λ x3, wceq (A2 x3) (B2 x3))
    (@nfeq (λ x3, A2 x3) (λ x3, B2 x3)
      nfne_1
      nfne_2))


/-- Not equivalent wff's correspond to not equal class abstractions. (Contributed by AV,
7-Apr-2019.) (Proof shortened by Wolf Lammen, 25-Nov-2019.) -/
theorem nabbi {ph ps : setvar → wff} :
  ⊦ wb (wex (λ x3, wb (ph x3) (wn (ps x3)))) (wne (cab (λ x3, ph x3)) (cab (λ x3, ps x3))) :=
@bitr2i (wne (cab (λ x3, ph x3)) (cab (λ x3, ps x3))) (wn (wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3)))) (wex (λ x3, wb (ph x3) (wn (ps x3))))
  (@df_ne (cab (λ x3, ph x3)) (cab (λ x3, ps x3)))
  (@xchnxbi (wal (λ x3, wb (ph x3) (ps x3))) (wex (λ x3, wb (ph x3) (wn (ps x3)))) (wceq (cab (λ x3, ph x3)) (cab (λ x3, ps x3)))
    (@bitr3i (wn (wal (λ x3, wb (ph x3) (ps x3)))) (wex (λ x3, wn (wb (ph x3) (ps x3)))) (wex (λ x3, wb (ph x3) (wn (ps x3))))
      (@exnal (λ x3, wb (ph x3) (ps x3)))
      (@exbii (λ x3, wn (wb (ph x3) (ps x3))) (λ x3, wb (ph x3) (wn (ps x3)))
        (λ x3, @xor3 (ph x3) (ps x3))))
    (@abbi (λ x3, ph x3) (λ x3, ps x3)))


-- /-- Extend wff notation to include negated membership. -/
-- constant wnel : «class» → «class» → wff


-- /-- Define negated membership. (Contributed by NM, 7-Aug-1994.) -/
-- axiom df_nel {A2 B2 : «class»} : ⊦ wb (wnel A2 B2) (wn (wcel A2 B2))


/-- Inference associated with ~ df-nel . (Contributed by BJ, 7-Jul-2018.) -/
theorem neli {A2 B2 : «class»}
  (neli_1 : ⊦ wnel A2 B2) :
  ⊦ wn (wcel A2 B2) :=
@mpbi (wnel A2 B2) (wn (wcel A2 B2))
  neli_1
  (@df_nel A2 B2)


/-- Inference associated with ~ df-nel . (Contributed by BJ, 7-Jul-2018.) -/
theorem nelir {A2 B2 : «class»}
  (nelir_1 : ⊦ wn (wcel A2 B2)) :
  ⊦ wnel A2 B2 :=
@mpbir (wnel A2 B2) (wn (wcel A2 B2))
  nelir_1
  (@df_nel A2 B2)


/-- Equality theorem for negated membership. (Contributed by FL, 10-Aug-2016.) (Proof shortened by
Wolf Lammen, 25-Nov-2019.) -/
theorem neleq12d {ph : wff} {A2 B2 C D : «class»}
  (neleq12d_1 : ⊦ wi ph (wceq A2 B2))
  (neleq12d_2 : ⊦ wi ph (wceq C D)) :
  ⊦ wi ph (wb (wnel A2 C) (wnel B2 D)) :=
@«3bitr4g» ph (wn (wcel A2 C)) (wn (wcel B2 D)) (wnel A2 C) (wnel B2 D)
  (@notbid ph (wcel A2 C) (wcel B2 D)
    (@eleq12d ph A2 B2 C D
      neleq12d_1
      neleq12d_2))
  (@df_nel A2 C)
  (@df_nel B2 D)


/-- Equality theorem for negated membership. (Contributed by NM, 20-Nov-1994.) (Proof shortened by
Wolf Lammen, 25-Nov-2019.) -/
theorem neleq1 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wnel A2 C) (wnel B2 C)) :=
@neleq12d (wceq A2 B2) A2 B2 C C
  (@id (wceq A2 B2))
  (@eqidd (wceq A2 B2) C)


/-- Equality theorem for negated membership. (Contributed by NM, 20-Nov-1994.) (Proof shortened by
Wolf Lammen, 25-Nov-2019.) -/
theorem neleq2 {A2 B2 C : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wnel C A2) (wnel C B2)) :=
@neleq12d (wceq A2 B2) C C A2 B2
  (@eqidd (wceq A2 B2) C)
  (@id (wceq A2 B2))


-- /-- Extend wff notation to include restricted universal quantification. -/
-- constant wral : (setvar → wff) → (setvar → «class») → wff


-- /-- Extend wff notation to include restricted existential quantification. -/
-- constant wrex : (setvar → wff) → (setvar → «class») → wff


-- /-- Extend wff notation to include restricted existential uniqueness. -/
-- constant wreu : (setvar → wff) → (setvar → «class») → wff


-- /-- Extend wff notation to include restricted "at most one." -/
-- constant wrmo : (setvar → wff) → (setvar → «class») → wff


-- /-- Extend class notation to include the restricted class abstraction (class builder). -/
-- constant crab : (setvar → wff) → (setvar → «class») → «class»


-- /-- Define restricted universal quantification. Special case of Definition 4.15(3) of
-- [TakeutiZaring] p. 22. Note: This notation is most often used to express that ` ph ` holds for
-- all elements of a given class ` A ` . For this reading ` F/_ x A ` is required, though, for
-- example, asserted when ` x ` and ` A ` are disjoint. Should instead ` A ` depend on ` x ` , you
-- rather focus on those ` x ` that happen to be contained in the corresponding ` A ( x ) ` . This
-- hardly used interpretation could still occur naturally. For some examples, look at ~ ralndv1 or ~
-- ralndv2 , courtesy of AV. So be careful to either keep ` A ` independent of ` x ` , or adjust
-- your comments to include such exotic cases. (Contributed by NM, 19-Aug-1993.) -/
-- axiom df_ral {ph : setvar → wff} {A2 : setvar → «class»} : ⊦ wb (wral (λ x3, ph x3) (λ x3, A2 x3)) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)))


-- /-- Define restricted existential quantification. Special case of Definition 4.15(4) of
-- [TakeutiZaring] p. 22. Note: This notation is most often used to express that ` ph ` holds for at
-- least one element of a given class ` A ` . For this reading ` F/_ x A ` is required, though, for
-- example, asserted when ` x ` and ` A ` are disjoint. Should instead ` A ` depend on ` x ` , you
-- rather assert at least one ` x ` fulfilling ` ph ` happens to be contained in the corresponding `
-- A ( x ) ` . This interpretation is rarely needed (see also ~ df-ral ). (Contributed by NM,
-- 30-Aug-1993.) -/
-- axiom df_rex {ph : setvar → wff} {A2 : setvar → «class»} : ⊦ wb (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))


-- /-- Define restricted existential uniqueness. Note: This notation is most often used to express
-- that ` ph ` holds for exactly one element of a given class ` A ` . For this reading ` F/_ x A `
-- is required, though, for example, asserted when ` x ` and ` A ` are disjoint. Should instead ` A
-- ` depend on ` x ` , you rather assert exactly one ` x ` fulfilling ` ph ` happens to be contained
-- in the corresponding ` A ( x ) ` . This interpretation is rarely needed (see also ~ df-ral ).
-- (Contributed by NM, 22-Nov-1994.) -/
-- axiom df_reu {ph : setvar → wff} {A2 : setvar → «class»} : ⊦ wb (wreu (λ x3, ph x3) (λ x3, A2 x3)) (weu (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))


-- /-- Define restricted "at most one". Note: This notation is most often used to express that ` ph
-- ` holds for at most one element of a given class ` A ` . For this reading ` F/_ x A ` is
-- required, though, for example, asserted when ` x ` and ` A ` are disjoint. Should instead ` A `
-- depend on ` x ` , you rather assert at most one ` x ` fulfilling ` ph ` happens to be contained
-- in the corresponding ` A ( x ) ` . This interpretation is rarely needed (see also ~ df-ral ).
-- (Contributed by NM, 16-Jun-2017.) -/
-- axiom df_rmo {ph : setvar → wff} {A2 : setvar → «class»} : ⊦ wb (wrmo (λ x3, ph x3) (λ x3, A2 x3)) (wmo (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))


-- /-- Define a restricted class abstraction (class builder): ` { x e. A | ph } ` is the class of
-- all sets ` x ` in ` A ` such that ` ph ( x ) ` is true. Definition of [TakeutiZaring] p. 20. For
-- the interpretation given in the previous paragraph to be correct, we need to assume ` F/_ x A ` ,
-- which is the case as soon as ` x ` and ` A ` are disjoint, which is generally the case. If ` A `
-- were to depend on ` x ` , then the interpretation would be less obvious (think of the two extreme
-- cases ` A = { x } ` and ` A = x ` , for instance). See also ~ df-ral . (Contributed by NM,
-- 22-Nov-1994.) -/
-- axiom df_rab {ph : setvar → wff} {A2 : setvar → «class»} : ⊦ wceq (crab (λ x3, ph x3) (λ x3, A2 x3)) (cab (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))


/-- Generalization rule for restricted quantification. (Contributed by NM, 19-Nov-1994.) -/
theorem rgen {ph : setvar → wff} {A2 : setvar → «class»}
  (rgen_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (ph x3)) :
  ⊦ wral (λ x3, ph x3) (λ x3, A2 x3) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wral (λ x3, ph x3) (λ x3, A2 x3), from
  @mpgbir (λ x3, wral (λ x3, ph x3) (λ x3, A2 x3)) (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3))
    (λ x3, @df_ral (λ x3, ph x3) (λ x3, A2 x3))
    (λ x3, rgen_1 x3) x3


/-- All elements of a class are elements of the class. (Contributed by AV, 30-Oct-2020.) -/
theorem ralel {A2 : setvar → «class»} :
  ⊦ wral (λ x3, wcel (cv x3) (A2 x3)) (λ x3, A2 x3) :=
@rgen (λ x3, wcel (cv x3) (A2 x3)) (λ x3, A2 x3)
  (λ x3, @id (wcel (cv x3) (A2 x3)))


/-- Generalization rule for restricted quantification. (Contributed by NM, 18-Jun-2014.) -/
theorem rgenw {ph : setvar → wff} {A2 : setvar → «class»}
  (rgenw_1 : ∀ x3, ⊦ ph x3) :
  ⊦ wral (λ x3, ph x3) (λ x3, A2 x3) :=
@rgen (λ x3, ph x3) (λ x3, A2 x3)
  (λ x3, @a1i (ph x3) (wcel (cv x3) (A2 x3))
    (rgenw_1 x3))


/-- Generalization rule for restricted quantification. Note that ` x ` and ` y ` needn't be
distinct. (Contributed by NM, 18-Jun-2014.) -/
theorem rgen2w {ph : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (rgenw_1 : ∀ x3 y, ⊦ ph x3 y)
  (y : setvar) : ⊦ wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y) :=
@rgenw (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)
  (λ x3, @rgenw (λ y, ph x3 y) (λ y, B2 x3 y)
    (λ y, rgenw_1 x3 y))


/-- Modus ponens combined with restricted generalization. (Contributed by NM, 10-Aug-2004.) -/
theorem mprg {ph ps : setvar → wff} {A2 : setvar → «class»}
  (mprg_1 : ∀ x3, ⊦ wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (ps x3))
  (mprg_2 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (ph x3))
  (x3 : setvar) : ⊦ ps x3 :=
@ax_mp (wral (λ x3, ph x3) (λ x3, A2 x3)) (ps x3)
  (@rgen (λ x3, ph x3) (λ x3, A2 x3)
    (λ x3, mprg_2 x3))
  (mprg_1 x3)


/-- Modus ponens on biconditional combined with restricted generalization. (Contributed by NM,
21-Mar-2004.) -/
theorem mprgbir {ph ps : setvar → wff} {A2 : setvar → «class»}
  (mprgbir_1 : ∀ x3, ⊦ wb (ph x3) (wral (λ x3, ps x3) (λ x3, A2 x3)))
  (mprgbir_2 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (ps x3))
  (x3 : setvar) : ⊦ ph x3 :=
@mpbir (ph x3) (wral (λ x3, ps x3) (λ x3, A2 x3))
  (@rgen (λ x3, ps x3) (λ x3, A2 x3)
    (λ x3, mprgbir_2 x3))
  (mprgbir_1 x3)


/-- Restricted universally quantified negation expressed as a universally quantified negation.
(Contributed by BJ, 16-Jul-2021.) -/
theorem raln {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wal (λ x3, wn (wa (wcel (cv x3) (A2 x3)) (ph x3)))) :=
@bitri (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wn (ph x3)))) (wal (λ x3, wn (wa (wcel (cv x3) (A2 x3)) (ph x3))))
  (@df_ral (λ x3, wn (ph x3)) (λ x3, A2 x3))
  (@imnang (λ x3, wcel (cv x3) (A2 x3)) (λ x3, ph x3))


/-- Inference quantifying antecedent, nested antecedent, and consequent, with a strong hypothesis.
(Contributed by NM, 19-Dec-2006.) Allow shortening of ~ ralim . (Revised by Wolf Lammen,
1-Dec-2019.) -/
theorem ral2imi {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (ral2imi_1 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (ch x3))) :
  ⊦ wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wi (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@sylbi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3))) (wi (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3)))
  (@df_ral (λ x3, ph x3) (λ x3, A2 x3))
  (@«3imtr4g» (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3))) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ch x3))) (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))
    (@al2imi (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wi (wcel (cv x3) (A2 x3)) (ch x3))
      (λ x3, @imim3i (ph x3) (ps x3) (ch x3) (wcel (cv x3) (A2 x3))
        (ral2imi_1 x3)))
    (@df_ral (λ x3, ps x3) (λ x3, A2 x3))
    (@df_ral (λ x3, ch x3) (λ x3, A2 x3)))


/-- Inference quantifying both antecedent and consequent. (Contributed by NM, 22-Feb-2004.) -/
theorem ralimi2 {ph ps : setvar → wff} {A2 B2 : setvar → «class»}
  (ralimi2_1 : ∀ x3, ⊦ wi (wi (wcel (cv x3) (A2 x3)) (ph x3)) (wi (wcel (cv x3) (B2 x3)) (ps x3))) :
  ⊦ wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, B2 x3)) :=
@«3imtr4i» (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3))) (wal (λ x3, wi (wcel (cv x3) (B2 x3)) (ps x3))) (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, B2 x3))
  (@alimi (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wi (wcel (cv x3) (B2 x3)) (ps x3))
    (λ x3, ralimi2_1 x3))
  (@df_ral (λ x3, ph x3) (λ x3, A2 x3))
  (@df_ral (λ x3, ps x3) (λ x3, B2 x3))


/-- Inference quantifying both antecedent and consequent. (Contributed by NM, 19-Jul-1996.) -/
theorem ralimia {ph ps : setvar → wff} {A2 : setvar → «class»}
  (ralimia_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wi (ph x3) (ps x3))) :
  ⊦ wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@ralimi2 (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3) (λ x3, A2 x3)
  (λ x3, @a2i (wcel (cv x3) (A2 x3)) (ph x3) (ps x3)
    (ralimia_1 x3))


/-- Inference quantifying both antecedent and consequent. (Contributed by NM, 4-Aug-2007.) -/
theorem ralimiaa {ph ps : setvar → wff} {A2 : setvar → «class»}
  (ralimiaa_1 : ∀ x3, ⊦ wi (wa (wcel (cv x3) (A2 x3)) (ph x3)) (ps x3)) :
  ⊦ wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@ralimia (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @ex (wcel (cv x3) (A2 x3)) (ph x3) (ps x3)
    (ralimiaa_1 x3))


/-- Inference quantifying both antecedent and consequent, with strong hypothesis. (Contributed by
NM, 4-Mar-1997.) -/
theorem ralimi {ph ps : setvar → wff} {A2 : setvar → «class»}
  (ralimi_1 : ∀ x3, ⊦ wi (ph x3) (ps x3)) :
  ⊦ wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@ralimia (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @a1i (wi (ph x3) (ps x3)) (wcel (cv x3) (A2 x3))
    (ralimi_1 x3))


/-- Inference quantifying both antecedent and consequent two times, with strong hypothesis.
(Contributed by AV, 3-Dec-2021.) -/
theorem «2ralimi» {ph ps : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (ralimi_1 : ∀ x3 y, ⊦ wi (ph x3 y) (ps x3 y))
  (y : setvar) : ⊦ wi (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) :=
@ralimi (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)
  (λ x3, @ralimi (λ y, ph x3 y) (λ y, ps x3 y) (λ y, B2 x3 y)
    (λ y, ralimi_1 x3 y))


/-- Distribution of restricted quantification over implication. (Contributed by NM, 9-Feb-1997.)
(Proof shortened by Wolf Lammen, 1-Dec-2019.) -/
theorem ralim {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wi (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3))) :=
@ral2imi (λ x3, wi (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @id (wi (ph x3) (ps x3)))


/-- Inference adding different restricted universal quantifiers to each side of an equivalence.
(Contributed by NM, 15-Aug-2005.) -/
theorem ralbii2 {ph ps : setvar → wff} {A2 B2 : setvar → «class»}
  (ralbii2_1 : ∀ x3, ⊦ wb (wi (wcel (cv x3) (A2 x3)) (ph x3)) (wi (wcel (cv x3) (B2 x3)) (ps x3))) :
  ⊦ wb (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, B2 x3)) :=
@«3bitr4i» (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3))) (wal (λ x3, wi (wcel (cv x3) (B2 x3)) (ps x3))) (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, B2 x3))
  (@albii (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wi (wcel (cv x3) (B2 x3)) (ps x3))
    (λ x3, ralbii2_1 x3))
  (@df_ral (λ x3, ph x3) (λ x3, A2 x3))
  (@df_ral (λ x3, ps x3) (λ x3, B2 x3))


/-- Inference adding restricted universal quantifier to both sides of an equivalence. (Contributed
by NM, 26-Nov-2000.) -/
theorem ralbiia {ph ps : setvar → wff} {A2 : setvar → «class»}
  (ralbiia_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wb (ph x3) (ps x3))) :
  ⊦ wb (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@ralbii2 (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3) (λ x3, A2 x3)
  (λ x3, @pm5_74i (wcel (cv x3) (A2 x3)) (ph x3) (ps x3)
    (ralbiia_1 x3))


/-- Inference adding restricted universal quantifier to both sides of an equivalence. (Contributed
by NM, 23-Nov-1994.) (Revised by Mario Carneiro, 17-Oct-2016.) (Proof shortened by Wolf Lammen,
4-Dec-2019.) -/
theorem ralbii {ph ps : setvar → wff} {A2 : setvar → «class»}
  (ralbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@ralbiia (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @a1i (wb (ph x3) (ps x3)) (wcel (cv x3) (A2 x3))
    (ralbii_1 x3))


/-- Inference adding two restricted universal quantifiers to both sides of an equivalence.
(Contributed by NM, 1-Aug-2004.) -/
theorem «2ralbii» {ph ps : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (ralbii_1 : ∀ x3 y, ⊦ wb (ph x3 y) (ps x3 y))
  (y : setvar) : ⊦ wb (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) :=
@ralbii (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)
  (λ x3, @ralbii (λ y, ph x3 y) (λ y, ps x3 y) (λ y, B2 x3 y)
    (λ y, ralbii_1 x3 y))


/-- Distribute a restricted universal quantifier over a biconditional. Restricted quantification
version of ~ albi . (Contributed by NM, 6-Oct-2003.) Reduce axiom usage. (Revised by Wolf Lammen,
17-Jun-2023.) -/
theorem ralbi {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wi (wral (λ x3, wb (ph x3) (ps x3)) (λ x3, A2 x3)) (wb (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3))) :=
@impbid (wral (λ x3, wb (ph x3) (ps x3)) (λ x3, A2 x3)) (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3))
  (@ral2imi (λ x3, wb (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
    (λ x3, @biimp (ph x3) (ps x3)))
  (@ral2imi (λ x3, wb (ph x3) (ps x3)) (λ x3, ps x3) (λ x3, ph x3) (λ x3, A2 x3)
    (λ x3, @biimpr (ph x3) (ps x3)))


/-- Restricted quantifier version of ~ 19.26 . (Contributed by NM, 28-Jan-1997.) (Proof shortened by
Andrew Salmon, 30-May-2011.) -/
theorem r19_26 {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)) (wa (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3))) :=
@impbii (wral (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)) (wa (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3)))
  (@jca (wral (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)) (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3))
    (@ralimi (λ x3, wa (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, A2 x3)
      (λ x3, @simpl (ph x3) (ps x3)))
    (@ralimi (λ x3, wa (ph x3) (ps x3)) (λ x3, ps x3) (λ x3, A2 x3)
      (λ x3, @simpr (ph x3) (ps x3))))
  (@imp (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3))
    (@ral2imi (λ x3, ph x3) (λ x3, ps x3) (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)
      (λ x3, @pm3_2 (ph x3) (ps x3))))


/-- Restricted quantifier version of ~ 19.26-2 . Version of ~ r19.26 with two quantifiers.
(Contributed by NM, 10-Aug-2004.) -/
theorem r19_26_2 {ph ps : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (y : setvar) : ⊦ wb (wral (λ x3, wral (λ y, wa (ph x3 y) (ps x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wa (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))) :=
@bitri (wral (λ x3, wral (λ y, wa (ph x3 y) (ps x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ x3, wa (wral (λ y, ph x3 y) (λ y, B2 x3 y)) (wral (λ y, ps x3 y) (λ y, B2 x3 y))) (λ x3, A2 x3 y)) (wa (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)))
  (@ralbii (λ x3, wral (λ y, wa (ph x3 y) (ps x3 y)) (λ y, B2 x3 y)) (λ x3, wa (wral (λ y, ph x3 y) (λ y, B2 x3 y)) (wral (λ y, ps x3 y) (λ y, B2 x3 y))) (λ x3, A2 x3 y)
    (λ x3, @r19_26 (λ y, ph x3 y) (λ y, ps x3 y) (λ y, B2 x3 y)))
  (@r19_26 (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))


/-- Split a biconditional and distribute quantifier. Restricted quantifier version of ~ albiim .
(Contributed by NM, 3-Jun-2012.) -/
theorem ralbiim {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wb (ph x3) (ps x3)) (λ x3, A2 x3)) (wa (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wral (λ x3, wi (ps x3) (ph x3)) (λ x3, A2 x3))) :=
@bitri (wral (λ x3, wb (ph x3) (ps x3)) (λ x3, A2 x3)) (wral (λ x3, wa (wi (ph x3) (ps x3)) (wi (ps x3) (ph x3))) (λ x3, A2 x3)) (wa (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wral (λ x3, wi (ps x3) (ph x3)) (λ x3, A2 x3)))
  (@ralbii (λ x3, wb (ph x3) (ps x3)) (λ x3, wa (wi (ph x3) (ps x3)) (wi (ps x3) (ph x3))) (λ x3, A2 x3)
    (λ x3, @dfbi2 (ph x3) (ps x3)))
  (@r19_26 (λ x3, wi (ph x3) (ps x3)) (λ x3, wi (ps x3) (ph x3)) (λ x3, A2 x3))


/-- Restricted quantifier version of ~ 19.21v . (Contributed by NM, 15-Oct-2003.) (Proof shortened
by Andrew Salmon, 30-May-2011.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 2-Jan-2020.)
-/
theorem r19_21v {ph : wff} {ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wi ph (ps x3)) (λ x3, A2 x3)) (wi ph (wral (λ x3, ps x3) (λ x3, A2 x3))) :=
@«3bitr4i» (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wi ph (ps x3)))) (wi ph (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3)))) (wral (λ x3, wi ph (ps x3)) (λ x3, A2 x3)) (wi ph (wral (λ x3, ps x3) (λ x3, A2 x3)))
  (@bitri (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wi ph (ps x3)))) (wal (λ x3, wi ph (wi (wcel (cv x3) (A2 x3)) (ps x3)))) (wi ph (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))))
    (@albii (λ x3, wi (wcel (cv x3) (A2 x3)) (wi ph (ps x3))) (λ x3, wi ph (wi (wcel (cv x3) (A2 x3)) (ps x3)))
      (λ x3, @bi2_04 (wcel (cv x3) (A2 x3)) ph (ps x3)))
    (@«19_21v» ph (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))))
  (@df_ral (λ x3, wi ph (ps x3)) (λ x3, A2 x3))
  (@imbi2i (wral (λ x3, ps x3) (λ x3, A2 x3)) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))) ph
    (@df_ral (λ x3, ps x3) (λ x3, A2 x3)))


/-- Inference quantifying both antecedent and consequent. (Contributed by NM, 1-Feb-2005.) -/
theorem ralimdv2 {ph : wff} {ps ch : setvar → wff} {A2 B2 : setvar → «class»}
  (ralimdv2_1 : ∀ x3, ⊦ wi ph (wi (wi (wcel (cv x3) (A2 x3)) (ps x3)) (wi (wcel (cv x3) (B2 x3)) (ch x3)))) :
  ⊦ wi ph (wi (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, B2 x3))) :=
@«3imtr4g» ph (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))) (wal (λ x3, wi (wcel (cv x3) (B2 x3)) (ch x3))) (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, B2 x3))
  (@alimdv ph (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wi (wcel (cv x3) (B2 x3)) (ch x3))
    (λ x3, ralimdv2_1 x3))
  (@df_ral (λ x3, ps x3) (λ x3, A2 x3))
  (@df_ral (λ x3, ch x3) (λ x3, B2 x3))


/-- Deduction quantifying both antecedent and consequent, based on Theorem 19.20 of [Margaris] p.
90. (Contributed by NM, 22-May-1999.) Reduce dependencies on axioms. (Revised by Wolf Lammen,
5-Dec-2019.) -/
theorem ralimdva {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralimdva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wi (ps x3) (ch x3))) :
  ⊦ wi ph (wi (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@ralimdv2 ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3) (λ x3, A2 x3)
  (λ x3, @a2d ph (wcel (cv x3) (A2 x3)) (ps x3) (ch x3)
    (@ex ph (wcel (cv x3) (A2 x3)) (wi (ps x3) (ch x3))
      (ralimdva_1 x3)))


/-- Deduction quantifying both antecedent and consequent, based on Theorem 19.20 of [Margaris] p. 90
( ~ alim ). (Contributed by NM, 8-Oct-2003.) -/
theorem ralimdv {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralimdv_1 : ∀ x3, ⊦ wi ph (wi (ps x3) (ch x3))) :
  ⊦ wi ph (wi (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@ralimdva ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  (λ x3, @adantr ph (wi (ps x3) (ch x3)) (wcel (cv x3) (A2 x3))
    (ralimdv_1 x3))


/-- Deduction doubly quantifying both antecedent and consequent, based on Theorem 19.20 of
[Margaris] p. 90 ( ~ alim ). (Contributed by AV, 27-Nov-2019.) -/
theorem ralimdvva {ph : wff} {ps ch : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (ralimdvva_1 : ∀ x3 y, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)))) (wi (ps x3 y) (ch x3 y))) :
  ⊦ wi ph (wi (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wral (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3))) :=
@ralimdva ph (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)
  (λ x3, @ralimdva (wa ph (wcel (cv x3) (A2 x3))) (λ y, ps x3 y) (λ y, ch x3 y) (λ y, B2 x3 y)
    (λ y, @anassrs ph (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wi (ps x3 y) (ch x3 y))
      (ralimdvva_1 x3 y)))


/-- Inference from Theorem 19.21 of [Margaris] p. 90 (restricted quantifier version). This theorem
contains the common proof steps for ~ ralrimi and ~ ralrimiv . Its main advantage over these two is
its minimal references to axioms. The proof is extracted from NM's previous work. (Contributed by
Wolf Lammen, 4-Dec-2019.) -/
theorem hbralrimi {ph ps : setvar → wff} {A2 : setvar → «class»}
  (hbralrimi_1 : ∀ x3, ⊦ wi (ph x3) (wal (λ x3, ph x3)))
  (hbralrimi_2 : ∀ x3, ⊦ wi (ph x3) (wi (wcel (cv x3) (A2 x3)) (ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@sylibr (ph x3) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))) (wral (λ x3, ps x3) (λ x3, A2 x3))
  (@alrimih (λ x3, ph x3) (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))
    (λ x3, hbralrimi_1 x3)
    (λ x3, hbralrimi_2 x3) x3)
  (@df_ral (λ x3, ps x3) (λ x3, A2 x3))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 22-Nov-1994.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 4-Dec-2019.) -/
theorem ralrimiv {ph : wff} {ps : setvar → wff} {A2 : setvar → «class»}
  (ralrimiv_1 : ∀ x3, ⊦ wi ph (wi (wcel (cv x3) (A2 x3)) (ps x3))) :
  ⊦ wi ph (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi ph (wral (λ x3, ps x3) (λ x3, A2 x3)), from
  @hbralrimi (λ x3, ph) (λ x3, ps x3) (λ x3, A2 x3)
    (λ x3, @ax_5 ph)
    (λ x3, ralrimiv_1 x3) x3


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 2-Jan-2006.) -/
theorem ralrimiva {ph : wff} {ps : setvar → wff} {A2 : setvar → «class»}
  (ralrimiva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (ps x3)) :
  ⊦ wi ph (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@ralrimiv ph (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @ex ph (wcel (cv x3) (A2 x3)) (ps x3)
    (ralrimiva_1 x3))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 18-Jun-2014.) -/
theorem ralrimivw {ph : wff} {ps : setvar → wff} {A2 : setvar → «class»}
  (ralrimivw_1 : ∀ x3, ⊦ wi ph (ps x3)) :
  ⊦ wi ph (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@ralrimiv ph (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @a1d ph (ps x3) (wcel (cv x3) (A2 x3))
    (ralrimivw_1 x3))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 27-May-1998.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 28-Dec-2019.) -/
theorem ralrimdv {ph ps : wff} {ch : setvar → wff} {A2 : setvar → «class»}
  (ralrimdv_1 : ∀ x3, ⊦ wi ph (wi ps (wi (wcel (cv x3) (A2 x3)) (ch x3)))) :
  ⊦ wi ph (wi ps (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@ex ph ps (wral (λ x3, ch x3) (λ x3, A2 x3))
  (@ralrimiv (wa ph ps) (λ x3, ch x3) (λ x3, A2 x3)
    (λ x3, @imp ph ps (wi (wcel (cv x3) (A2 x3)) (ch x3))
      (ralrimdv_1 x3)))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 2-Feb-2008.) (Proof shortened by Wolf Lammen, 28-Dec-2019.) -/
theorem ralrimdva {ph ps : wff} {ch : setvar → wff} {A2 : setvar → «class»}
  (ralrimdva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wi ps (ch x3))) :
  ⊦ wi ph (wi ps (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@ralrimdv ph ps (λ x3, ch x3) (λ x3, A2 x3)
  (λ x3, @expcomd ph (wcel (cv x3) (A2 x3)) ps (ch x3)
    (@expimpd ph (wcel (cv x3) (A2 x3)) ps (ch x3)
      (ralrimdva_1 x3)))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version with double
quantification.) (Contributed by NM, 24-Jul-2004.) -/
theorem ralrimivv {ph : wff} {ps : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (ralrimivv_1 : ∀ x3 y, ⊦ wi ph (wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ps x3 y))) :
  ⊦ wi ph (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) :=
@ralrimiv ph (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)
  (λ x3, @ralrimdv ph (wcel (cv x3) (A2 x3)) (λ y, ps x3 y) (λ y, B2 x3 y)
    (λ y, @expd ph (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (ps x3 y)
      (ralrimivv_1 x3 y)))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version with double
quantification.) (Contributed by Jeff Madsen, 19-Jun-2011.) -/
theorem ralrimivva {ph : wff} {ps : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (ralrimivva_1 : ∀ x3 y, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)))) (ps x3 y)) :
  ⊦ wi ph (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) :=
@ralrimivv ph (λ x3 y, ps x3 y) (λ x3, A2 x3) (λ x3 y, B2 x3 y)
  (λ x3 y, @ex ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ps x3 y)
    (ralrimivva_1 x3 y))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version with triple
quantification.) (Contributed by Mario Carneiro, 9-Jul-2014.) -/
theorem ralrimivvva {ph : wff} {ps : setvar → setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»} {C : setvar → setvar → setvar → «class»}
  (ralrimivvva_1 : ∀ x3 y z, ⊦ wi (wa ph (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z)))) (ps x3 y z)) :
  ⊦ wi ph (wral (λ x3, wral (λ y, wral (λ z, ps x3 y z) (λ z, C x3 y z)) (λ y, B2 x3 y)) (λ x3, A2 x3)) :=
@ralrimiva ph (λ x3, wral (λ y, wral (λ z, ps x3 y z) (λ z, C x3 y z)) (λ y, B2 x3 y)) (λ x3, A2 x3)
  (λ x3, @ralrimiva (wa ph (wcel (cv x3) (A2 x3))) (λ y, wral (λ z, ps x3 y z) (λ z, C x3 y z)) (λ y, B2 x3 y)
    (λ y, @ralrimiva (wa (wa ph (wcel (cv x3) (A2 x3))) (wcel (cv y) (B2 x3 y))) (λ z, ps x3 y z) (λ z, C x3 y z)
      (λ z, @«3anassrs» ph (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z)) (ps x3 y z)
        (ralrimivvva_1 x3 y z))))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version with double
quantification.) (Contributed by NM, 1-Jun-2005.) -/
theorem ralrimdvv {ph ps : wff} {ch : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (ralrimdvv_1 : ∀ x3 y, ⊦ wi ph (wi ps (wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ch x3 y)))) :
  ⊦ wi ph (wi ps (wral (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3))) :=
@ex ph ps (wral (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3))
  (@ralrimivv (wa ph ps) (λ x3 y, ch x3 y) (λ x3, A2 x3) (λ x3 y, B2 x3 y)
    (λ x3 y, @imp ph ps (wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ch x3 y))
      (ralrimdvv_1 x3 y)))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version with double
quantification.) (Contributed by NM, 2-Feb-2008.) -/
theorem ralrimdvva {ph ps : wff} {ch : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (ralrimdvva_1 : ∀ x3 y, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)))) (wi ps (ch x3 y))) :
  ⊦ wi ph (wi ps (wral (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3))) :=
@ralrimdvv ph ps (λ x3 y, ch x3 y) (λ x3, A2 x3) (λ x3 y, B2 x3 y)
  (λ x3 y, @com23 ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) ps (ch x3 y)
    (@ex ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wi ps (ch x3 y))
      (ralrimdvva_1 x3 y)))


/-- Formula-building rule for restricted universal quantifier (deduction form). (Contributed by NM,
6-Apr-1997.) -/
theorem ralbidv2 {ph : wff} {ps ch : setvar → wff} {A2 B2 : setvar → «class»}
  (ralbidv2_1 : ∀ x3, ⊦ wi ph (wb (wi (wcel (cv x3) (A2 x3)) (ps x3)) (wi (wcel (cv x3) (B2 x3)) (ch x3)))) :
  ⊦ wi ph (wb (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, B2 x3))) :=
@«3bitr4g» ph (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))) (wal (λ x3, wi (wcel (cv x3) (B2 x3)) (ch x3))) (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, B2 x3))
  (@albidv ph (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wi (wcel (cv x3) (B2 x3)) (ch x3))
    (λ x3, ralbidv2_1 x3))
  (@df_ral (λ x3, ps x3) (λ x3, A2 x3))
  (@df_ral (λ x3, ch x3) (λ x3, B2 x3))


/-- Formula-building rule for restricted universal quantifier (deduction form). (Contributed by NM,
4-Mar-1997.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 29-Dec-2019.) -/
theorem ralbidva {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralbidva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@ralbidv2 ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3) (λ x3, A2 x3)
  (λ x3, @pm5_74da ph (wcel (cv x3) (A2 x3)) (ps x3) (ch x3)
    (ralbidva_1 x3))


/-- Formula-building rule for restricted universal quantifier (deduction form). (Contributed by NM,
20-Nov-1994.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 5-Dec-2019.) -/
theorem ralbidv {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralbidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@ralbidva ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  (λ x3, @adantr ph (wb (ps x3) (ch x3)) (wcel (cv x3) (A2 x3))
    (ralbidv_1 x3))


/-- Formula-building rule for restricted universal quantifiers (deduction form). (Contributed by NM,
4-Mar-1997.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 9-Dec-2019.) -/
theorem «2ralbidva» {ph : wff} {ps ch : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  («2ralbidva_1» : ∀ x3 y, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)))) (wb (ps x3 y) (ch x3 y))) :
  ⊦ wi ph (wb (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wral (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3))) :=
@ralbidva ph (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)
  (λ x3, @ralbidva (wa ph (wcel (cv x3) (A2 x3))) (λ y, ps x3 y) (λ y, ch x3 y) (λ y, B2 x3 y)
    (λ y, @anassrs ph (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wb (ps x3 y) (ch x3 y))
      («2ralbidva_1» x3 y)))


/-- Formula-building rule for restricted universal quantifiers (deduction form). (Contributed by NM,
28-Jan-2006.) (Revised by Szymon Jaroszewicz, 16-Mar-2007.) -/
theorem «2ralbidv» {ph : wff} {ps ch : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  («2ralbidv_1» : ∀ x3 y, ⊦ wi ph (wb (ps x3 y) (ch x3 y)))
  (y : setvar) : ⊦ wi ph (wb (wral (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))) :=
@ralbidv ph (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)
  (λ x3, @ralbidv ph (λ y, ps x3 y) (λ y, ch x3 y) (λ y, B2 x3 y)
    (λ y, «2ralbidv_1» x3 y))


/-- Lemma factoring out common proof steps of ~ r2alf and ~ r2al . Introduced to reduce dependencies
on axioms. (Contributed by Wolf Lammen, 9-Jan-2020.) -/
theorem r2allem {ph : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (r2allem_1 : ∀ x3 y, ⊦ wb (wal (λ y, wi (wcel (cv x3) (A2 x3 y)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))) (wi (wcel (cv x3) (A2 x3 y)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))
  (y : setvar) : ⊦ wb (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) :=
@bitr4i (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wal (λ x3, wi (wcel (cv x3) (A2 x3 y)) (wral (λ y, ph x3 y) (λ y, B2 x3 y)))) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y))))
  (@df_ral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))
  (@albii (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y))) (λ x3, wi (wcel (cv x3) (A2 x3 y)) (wral (λ y, ph x3 y) (λ y, B2 x3 y)))
    (λ x3, @«3bitr4i» (wal (λ y, wi (wcel (cv x3) (A2 x3 y)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))) (wi (wcel (cv x3) (A2 x3 y)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))) (wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y))) (wi (wcel (cv x3) (A2 x3 y)) (wral (λ y, ph x3 y) (λ y, B2 x3 y)))
      (r2allem_1 x3 y)
      (@albii (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)) (λ y, wi (wcel (cv x3) (A2 x3 y)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))
        (λ y, @impexp (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y)) (ph x3 y)))
      (@imbi2i (wral (λ y, ph x3 y) (λ y, B2 x3 y)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y))) (wcel (cv x3) (A2 x3 y))
        (@df_ral (λ y, ph x3 y) (λ y, B2 x3 y)))))


/-- Double restricted universal quantification. (Contributed by NM, 19-Nov-1995.) Reduce
dependencies on axioms. (Revised by Wolf Lammen, 9-Jan-2020.) -/
theorem r2al {ph : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»} :
  ⊦ wb (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) :=
setvar.forget $ λ y : setvar,
  show ⊦ wb (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))), from
  @r2allem (λ x3 y, ph x3 y) (λ x3 y, A2 x3) (λ x3 y, B2 x3 y)
    (λ x3 y, @«19_21v» (wcel (cv x3) (A2 x3)) (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y))) y


/-- Triple restricted universal quantification. (Contributed by NM, 19-Nov-1995.) (Proof shortened
by Wolf Lammen, 30-Dec-2019.) -/
theorem r3al {ph : setvar → setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»} {C : setvar → setvar → setvar → «class»} :
  ⊦ wb (wral (λ x3, wral (λ y, wral (λ z, ph x3 y z) (λ z, C x3 y z)) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wal (λ x3, wal (λ y, wal (λ z, wi (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (ph x3 y z))))) :=
@bitri (wral (λ x3, wral (λ y, wral (λ z, ph x3 y z) (λ z, C x3 y z)) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wral (λ z, ph x3 y z) (λ z, C x3 y z))))) (wal (λ x3, wal (λ y, wal (λ z, wi (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (ph x3 y z)))))
  (@r2al (λ x3 y, wral (λ z, ph x3 y z) (λ z, C x3 y z)) (λ x3, A2 x3) (λ x3 y, B2 x3 y))
  (@«2albii» (λ x3 y, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wral (λ z, ph x3 y z) (λ z, C x3 y z))) (λ x3 y, wal (λ z, wi (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (ph x3 y z)))
    (λ x3 y, @«3bitr4ri» (wal (λ z, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wi (wcel (cv z) (C x3 y z)) (ph x3 y z)))) (wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wal (λ z, wi (wcel (cv z) (C x3 y z)) (ph x3 y z)))) (wal (λ z, wi (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (ph x3 y z))) (wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wral (λ z, ph x3 y z) (λ z, C x3 y z)))
      (@«19_21v» (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (λ z, wi (wcel (cv z) (C x3 y z)) (ph x3 y z)))
      (@albii (λ z, wi (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (ph x3 y z)) (λ z, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wi (wcel (cv z) (C x3 y z)) (ph x3 y z)))
        (λ z, @bitri (wi (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (ph x3 y z)) (wi (wa (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wcel (cv z) (C x3 y z))) (ph x3 y z)) (wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wi (wcel (cv z) (C x3 y z)) (ph x3 y z)))
          (@imbi1i (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (wa (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wcel (cv z) (C x3 y z))) (ph x3 y z)
            (@df_3an (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))))
          (@impexp (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wcel (cv z) (C x3 y z)) (ph x3 y z))))
      (@imbi2i (wral (λ z, ph x3 y z) (λ z, C x3 y z)) (wal (λ z, wi (wcel (cv z) (C x3 y z)) (ph x3 y z))) (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)))
        (@df_ral (λ z, ph x3 y z) (λ z, C x3 y z)))))


/-- Generalization rule for restricted quantification, with two quantifiers. This theorem should be
used in place of ~ rgen2a since it depends on a smaller set of axioms. (Contributed by NM,
30-May-1999.) -/
theorem rgen2 {ph : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (rgen2_1 : ∀ x3 y, ⊦ wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ph x3 y)) :
  ⊦ wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3) :=
@rgen (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)
  (λ x3, @ralrimiva (wcel (cv x3) (A2 x3)) (λ y, ph x3 y) (λ y, B2 x3 y)
    (λ y, rgen2_1 x3 y))


/-- Generalization rule for restricted quantification, with three quantifiers. (Contributed by NM,
12-Jan-2008.) -/
theorem rgen3 {ph : setvar → setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»} {C : setvar → setvar → setvar → «class»}
  (rgen3_1 : ∀ x3 y z, ⊦ wi (w3a (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z))) (ph x3 y z)) :
  ⊦ wral (λ x3, wral (λ y, wral (λ z, ph x3 y z) (λ z, C x3 y z)) (λ y, B2 x3 y)) (λ x3, A2 x3) :=
@rgen2 (λ x3 y, wral (λ z, ph x3 y z) (λ z, C x3 y z)) (λ x3, A2 x3) (λ x3 y, B2 x3 y)
  (λ x3 y, @ralrimiva (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (λ z, ph x3 y z) (λ z, C x3 y z)
    (λ z, @«3expa» (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wcel (cv z) (C x3 y z)) (ph x3 y z)
      (rgen3_1 x3 y z)))


/-- Restricted specialization. (Contributed by NM, 17-Oct-1996.) -/
theorem rsp {ph : setvar → wff} {A2 : setvar → «class»}
  (x3 : setvar) : ⊦ wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wi (wcel (cv x3) (A2 x3)) (ph x3)) :=
@sylbi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3))) (wi (wcel (cv x3) (A2 x3)) (ph x3))
  (@df_ral (λ x3, ph x3) (λ x3, A2 x3))
  (@sp (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) x3)


/-- Restricted specialization. (Contributed by Glauco Siliprandi, 11-Dec-2019.) -/
theorem rspa {ph : setvar → wff} {A2 : setvar → «class»}
  (x3 : setvar) : ⊦ wi (wa (wral (λ x3, ph x3) (λ x3, A2 x3)) (wcel (cv x3) (A2 x3))) (ph x3) :=
@imp (wral (λ x3, ph x3) (λ x3, A2 x3)) (wcel (cv x3) (A2 x3)) (ph x3)
  (@rsp (λ x3, ph x3) (λ x3, A2 x3) x3)


/-- Specialization rule for restricted quantification. (Contributed by NM, 19-Nov-1994.) -/
theorem rspec {ph : setvar → wff} {A2 : setvar → «class»}
  (rspec_1 : ⊦ wral (λ x3, ph x3) (λ x3, A2 x3))
  (x3 : setvar) : ⊦ wi (wcel (cv x3) (A2 x3)) (ph x3) :=
@ax_mp (wral (λ x3, ph x3) (λ x3, A2 x3)) (wi (wcel (cv x3) (A2 x3)) (ph x3))
  rspec_1
  (@rsp (λ x3, ph x3) (λ x3, A2 x3) x3)


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 20-Nov-1994.) (Proof shortened by Wolf Lammen, 11-Jun-2023.) -/
theorem r19_21bi {ph ps : setvar → wff} {A2 : setvar → «class»}
  (r19_21bi_1 : ∀ x3, ⊦ wi (ph x3) (wral (λ x3, ps x3) (λ x3, A2 x3)))
  (x3 : setvar) : ⊦ wi (wa (ph x3) (wcel (cv x3) (A2 x3))) (ps x3) :=
@sylan (ph x3) (wral (λ x3, ps x3) (λ x3, A2 x3)) (wcel (cv x3) (A2 x3)) (ps x3)
  (r19_21bi_1 x3)
  (@rspa (λ x3, ps x3) (λ x3, A2 x3) x3)


/-- Restricted specialization, with two quantifiers. (Contributed by NM, 11-Feb-1997.) -/
theorem rsp2 {ph : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (x3 y : setvar) : ⊦ wi (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)) :=
@impd (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y)) (ph x3 y)
  (@syl6 (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wcel (cv x3) (A2 x3 y)) (wral (λ y, ph x3 y) (λ y, B2 x3 y)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y))
    (@rsp (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y) x3)
    (@rsp (λ y, ph x3 y) (λ y, B2 x3 y) y))


/-- Inference from Theorem 19.21 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by NM, 10-Oct-1999.) Shortened after introduction of ~ hbralrimi . (Revised by Wolf Lammen,
4-Dec-2019.) -/
theorem ralrimi {ph ps : setvar → wff} {A2 : setvar → «class»}
  (ralrimi_1 : ⊦ wnf (λ x3, ph x3))
  (ralrimi_2 : ∀ x3, ⊦ wi (ph x3) (wi (wcel (cv x3) (A2 x3)) (ps x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wral (λ x3, ps x3) (λ x3, A2 x3)) :=
@hbralrimi (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @nf5ri (λ x3, ph x3)
    ralrimi_1 x3)
  (λ x3, ralrimi_2 x3) x3


/-- Deduction quantifying both antecedent and consequent, based on Theorem 19.20 of [Margaris] p.
90. (Contributed by NM, 22-Sep-2003.) (Proof shortened by Wolf Lammen, 29-Dec-2019.) -/
theorem ralimdaa {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralimdaa_1 : ⊦ wnf (λ x3, ph x3))
  (ralimdaa_2 : ∀ x3, ⊦ wi (wa (ph x3) (wcel (cv x3) (A2 x3))) (wi (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@syl (ph x3) (wral (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)) (wi (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3)))
  (@ralrimi (λ x3, ph x3) (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)
    ralimdaa_1
    (λ x3, @ex (ph x3) (wcel (cv x3) (A2 x3)) (wi (ps x3) (ch x3))
      (ralimdaa_2 x3)) x3)
  (@ralim (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3))


/-- Inference from Theorem 19.21 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 16-Feb-2004.) -/
theorem ralrimd {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralrimd_1 : ⊦ wnf (λ x3, ph x3))
  (ralrimd_2 : ⊦ wnf (λ x3, ps x3))
  (ralrimd_3 : ∀ x3, ⊦ wi (ph x3) (wi (ps x3) (wi (wcel (cv x3) (A2 x3)) (ch x3))))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (ps x3) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@syl6ibr (ph x3) (ps x3) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ch x3))) (wral (λ x3, ch x3) (λ x3, A2 x3))
  (@alrimd (λ x3, ph x3) (λ x3, ps x3) (λ x3, wi (wcel (cv x3) (A2 x3)) (ch x3))
    ralrimd_1
    ralrimd_2
    (λ x3, ralrimd_3 x3) x3)
  (@df_ral (λ x3, ch x3) (λ x3, A2 x3))


/-- The setvar ` x ` is not free in ` A. x e. A ph ` . (Contributed by NM, 18-Oct-1996.) (Revised by
Mario Carneiro, 7-Oct-2016.) -/
theorem nfra1 {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wnf (λ x3, wral (λ x3, ph x3) (λ x3, A2 x3)) :=
@nfxfr (λ x3, wral (λ x3, ph x3) (λ x3, A2 x3)) (λ x3, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)))
  (λ x3, @df_ral (λ x3, ph x3) (λ x3, A2 x3))
  (@nfa1 (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)))


/-- Double restricted universal quantification. (Contributed by Mario Carneiro, 14-Oct-2016.) Use ~
r2allem . (Revised by Wolf Lammen, 9-Jan-2020.) -/
theorem r2alf {ph : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (r2alf_1 : ∀ x3, ⊦ wnfc (λ y, A2 x3 y))
  (y : setvar) : ⊦ wb (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) :=
@r2allem (λ x3 y, ph x3 y) (λ x3 y, A2 x3 y) (λ x3 y, B2 x3 y)
  (λ x3 y, @«19_21» (λ y, wcel (cv x3) (A2 x3 y)) (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y))
    (@nfcri (λ y x3, A2 x3 y)
      (λ x3, r2alf_1 x3) x3) y) y


/-- Deduction version of ~ nfralw . Version of ~ nfrald with a disjoint variable condition, which
does not require ~ ax-13 . (Contributed by NM, 15-Feb-2013.) (Revised by Gino Giotto, 24-Sep-2024.)
-/
theorem nfraldw {ph ps : setvar → setvar → wff} {A2 : setvar → setvar → «class»}
  (nfraldw_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (nfraldw_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnfc (λ x3, A2 x3 y)))
  (nfraldw_3 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ps x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnf (λ x3, wral (λ y, ps x3 y) (λ y, A2 x3 y))) :=
@nfxfrd (λ x3, wral (λ y, ps x3 y) (λ y, A2 x3 y)) (λ x3, wal (λ y, wi (wcel (cv y) (A2 x3 y)) (ps x3 y))) (λ x3, ph x3 y)
  (λ x3, @df_ral (λ y, ps x3 y) (λ y, A2 x3 y))
  (λ x3, @nfald (λ x3 y, ph x3 y) (λ x3 y, wi (wcel (cv y) (A2 x3 y)) (ps x3 y))
    (λ x3, nfraldw_1 x3)
    (λ x3 y, @nfimd (λ x3, ph x3 y) (λ x3, wcel (cv y) (A2 x3 y)) (λ x3, ps x3 y)
      (λ x3, @nfcrd (λ x3 y, ph x3 y) (λ x3 y, A2 x3 y)
        (λ x3 y, nfraldw_2 x3 y) x3 y)
      (λ x3, nfraldw_3 x3 y) x3) x3 y) x3


/-- Bound-variable hypothesis builder for restricted quantification. Version of ~ nfral with a
disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM, 1-Sep-1999.)
(Revised by Gino Giotto, 10-Jan-2024.) -/
theorem nfralw {ph : setvar → setvar → wff} {A2 : setvar → setvar → «class»}
  (nfralw_1 : ∀ y, ⊦ wnfc (λ x3, A2 x3 y))
  (nfralw_2 : ∀ y, ⊦ wnf (λ x3, ph x3 y)) :
  ⊦ wnf (λ x3, wral (λ y, ph x3 y) (λ y, A2 x3 y)) :=
@mptru (wnf (λ x3, wral (λ y, ph x3 y) (λ y, A2 x3 y)))
  (setvar.forget $ λ x3 : setvar,
    setvar.forget $ λ y : setvar,
    show ⊦ wi wtru (wnf (λ x3, wral (λ y, ph x3 y) (λ y, A2 x3 y))), from
    @nfraldw (λ x3 y, wtru) (λ x3 y, ph x3 y) (λ x3 y, A2 x3 y)
      (λ x3, nftru)
      (λ x3 y, @a1i (wnfc (λ x3, A2 x3 y)) wtru
        (nfralw_1 y))
      (λ x3 y, @a1i (wnf (λ x3, ph x3 y)) wtru
        (nfralw_2 y)) x3 y)


/-- Similar to Lemma 24 of [Monk2] p. 114, except the quantification of the antecedent is
restricted. Derived automatically from ~ hbra2VD . Version of ~ nfra2 with a disjoint variable
condition, which does not require ~ ax-13 . (Contributed by Alan Sare, 31-Dec-2011.) (Revised by
Gino Giotto, 24-Sep-2024.) -/
theorem nfra2w {ph : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»} :
  ⊦ wnf (λ y, wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) :=
@nfxfr (λ y, wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))
  (λ y, @bitri (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wral (λ y, ph x3 y) (λ y, B2 x3 y)))) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))
    (@df_ral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3))
    (@albii (λ x3, wi (wcel (cv x3) (A2 x3)) (wral (λ y, ph x3 y) (λ y, B2 x3 y))) (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y))))
      (λ x3, @imbi2i (wral (λ y, ph x3 y) (λ y, B2 x3 y)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y))) (wcel (cv x3) (A2 x3))
        (@df_ral (λ y, ph x3 y) (λ y, B2 x3 y)))))
  (@mpbi (wnf (λ y, wal (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))) (wnf (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y))))))
    (@nfa1 (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))
    (@nfbii (λ y, wal (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y))))) (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))
      (λ y, @bitri (wal (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y))))) (wal (λ x3, wal (λ y, wi (wcel (cv x3) (A2 x3)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y))))) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))
        (@alcom (λ y x3, wi (wcel (cv x3) (A2 x3)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y))))
        (@albii (λ x3, wal (λ y, wi (wcel (cv x3) (A2 x3)) (wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))) (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y))))
          (λ x3, @«19_21v» (wcel (cv x3) (A2 x3)) (λ y, wi (wcel (cv y) (B2 x3 y)) (ph x3 y)))))))


/-- Formula-building rule for restricted universal quantifier (deduction form). (Contributed by NM,
6-Oct-2003.) -/
theorem ralbida {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralbida_1 : ⊦ wnf (λ x3, ph x3))
  (ralbida_2 : ∀ x3, ⊦ wi (wa (ph x3) (wcel (cv x3) (A2 x3))) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@«3bitr4g» (ph x3) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3))) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ch x3))) (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))
  (@albid (λ x3, ph x3) (λ x3, wi (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wi (wcel (cv x3) (A2 x3)) (ch x3))
    ralbida_1
    (λ x3, @pm5_74da (ph x3) (wcel (cv x3) (A2 x3)) (ps x3) (ch x3)
      (ralbida_2 x3)) x3)
  (@df_ral (λ x3, ps x3) (λ x3, A2 x3))
  (@df_ral (λ x3, ch x3) (λ x3, A2 x3))


/-- Formula-building rule for restricted universal quantifier (deduction form). (Contributed by NM,
27-Jun-1998.) -/
theorem ralbid {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (ralbid_1 : ⊦ wnf (λ x3, ph x3))
  (ralbid_2 : ∀ x3, ⊦ wi (ph x3) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, A2 x3))) :=
@ralbida (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  ralbid_1
  (λ x3, @adantr (ph x3) (wb (ps x3) (ch x3)) (wcel (cv x3) (A2 x3))
    (ralbid_2 x3)) x3


/-- Commutation of restricted and unrestricted universal quantifiers. (Contributed by NM,
26-Mar-2004.) (Proof shortened by Andrew Salmon, 8-Jun-2011.) Reduce axiom dependencies. (Revised by
BJ, 13-Jun-2019.) -/
theorem ralcom4 {ph : setvar → setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wal (λ y, ph x3 y)) (λ x3, A2 x3)) (wal (λ y, wral (λ x3, ph x3 y) (λ x3, A2 x3))) :=
@«3bitr4i» (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, ph x3 y)))) (wal (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3 y)))) (wral (λ x3, wal (λ y, ph x3 y)) (λ x3, A2 x3)) (wal (λ y, wral (λ x3, ph x3 y) (λ x3, A2 x3)))
  (@bitri (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, ph x3 y)))) (wal (λ x3, wal (λ y, wi (wcel (cv x3) (A2 x3)) (ph x3 y)))) (wal (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3 y))))
    (@albii (λ x3, wi (wcel (cv x3) (A2 x3)) (wal (λ y, ph x3 y))) (λ x3, wal (λ y, wi (wcel (cv x3) (A2 x3)) (ph x3 y)))
      (λ x3, @bicomi (wal (λ y, wi (wcel (cv x3) (A2 x3)) (ph x3 y))) (wi (wcel (cv x3) (A2 x3)) (wal (λ y, ph x3 y)))
        (@«19_21v» (wcel (cv x3) (A2 x3)) (λ y, ph x3 y))))
    (@alcom (λ x3 y, wi (wcel (cv x3) (A2 x3)) (ph x3 y))))
  (@df_ral (λ x3, wal (λ y, ph x3 y)) (λ x3, A2 x3))
  (@albii (λ y, wral (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, wal (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3 y)))
    (λ y, @df_ral (λ x3, ph x3 y) (λ x3, A2 x3)))


/-- Relationship between restricted universal and existential quantifiers. (Contributed by NM,
21-Jan-1997.) (Proof shortened by BJ, 16-Jul-2021.) -/
theorem ralnex {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wn (wrex (λ x3, ph x3) (λ x3, A2 x3))) :=
@bitri (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wal (λ x3, wn (wa (wcel (cv x3) (A2 x3)) (ph x3)))) (wn (wrex (λ x3, ph x3) (λ x3, A2 x3)))
  (@raln (λ x3, ph x3) (λ x3, A2 x3))
  (@xchbinxr (wal (λ x3, wn (wa (wcel (cv x3) (A2 x3)) (ph x3)))) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (wrex (λ x3, ph x3) (λ x3, A2 x3))
    (@alnex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))
    (@df_rex (λ x3, ph x3) (λ x3, A2 x3)))


/-- Relationship between restricted universal and existential quantifiers. (Contributed by NM,
21-Jan-1997.) Allow shortening of ~ rexnal . (Revised by Wolf Lammen, 9-Dec-2019.) -/
theorem dfral2 {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, ph x3) (λ x3, A2 x3)) (wn (wrex (λ x3, wn (ph x3)) (λ x3, A2 x3))) :=
@bitri (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, wn (wn (ph x3))) (λ x3, A2 x3)) (wn (wrex (λ x3, wn (ph x3)) (λ x3, A2 x3)))
  (@ralbii (λ x3, ph x3) (λ x3, wn (wn (ph x3))) (λ x3, A2 x3)
    (λ x3, @notnotb (ph x3)))
  (@ralnex (λ x3, wn (ph x3)) (λ x3, A2 x3))


/-- Relationship between restricted universal and existential quantifiers. (Contributed by NM,
21-Jan-1997.) (Proof shortened by Wolf Lammen, 9-Dec-2019.) -/
theorem rexnal {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wn (wral (λ x3, ph x3) (λ x3, A2 x3))) :=
@con2bii (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, wn (ph x3)) (λ x3, A2 x3))
  (@dfral2 (λ x3, ph x3) (λ x3, A2 x3))


/-- Relationship between restricted universal and existential quantifiers. (Contributed by NM,
21-Jan-1997.) (Proof shortened by Wolf Lammen, 26-Nov-2019.) -/
theorem dfrex2 {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wn (wral (λ x3, wn (ph x3)) (λ x3, A2 x3))) :=
@con2bii (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wrex (λ x3, ph x3) (λ x3, A2 x3))
  (@ralnex (λ x3, ph x3) (λ x3, A2 x3))


/-- Restricted existence implies existence. (Contributed by NM, 11-Nov-1995.) -/
theorem rexex {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wex (λ x3, ph x3)) :=
@sylbi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (wex (λ x3, ph x3))
  (@df_rex (λ x3, ph x3) (λ x3, A2 x3))
  (@exsimpr (λ x3, wcel (cv x3) (A2 x3)) (λ x3, ph x3))


/-- Theorem 19.22 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed by NM,
22-Nov-1994.) (Proof shortened by Andrew Salmon, 30-May-2011.) -/
theorem rexim {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wi (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) :=
@«3imtr4g» (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wn (wral (λ x3, wn (ph x3)) (λ x3, A2 x3))) (wn (wral (λ x3, wn (ps x3)) (λ x3, A2 x3))) (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))
  (@con3d (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wral (λ x3, wn (ps x3)) (λ x3, A2 x3)) (wral (λ x3, wn (ph x3)) (λ x3, A2 x3))
    (@ral2imi (λ x3, wi (ph x3) (ps x3)) (λ x3, wn (ps x3)) (λ x3, wn (ph x3)) (λ x3, A2 x3)
      (λ x3, @con3 (ph x3) (ps x3))))
  (@dfrex2 (λ x3, ph x3) (λ x3, A2 x3))
  (@dfrex2 (λ x3, ps x3) (λ x3, A2 x3))


/-- Inference quantifying both antecedent and consequent. (Contributed by NM, 10-Feb-1997.) -/
theorem reximia {ph ps : setvar → wff} {A2 : setvar → «class»}
  (reximia_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wi (ph x3) (ps x3))) :
  ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)) :=
setvar.forget $ λ x3 : setvar,
  show ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)), from
  @mprg (λ x3, wi (ph x3) (ps x3)) (λ x3, wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) (λ x3, A2 x3)
    (λ x3, @rexim (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3))
    (λ x3, reximia_1 x3) x3


/-- Inference quantifying both antecedent and consequent. (Contributed by NM, 18-Oct-1996.) -/
theorem reximi {ph ps : setvar → wff} {A2 : setvar → «class»}
  (reximi_1 : ∀ x3, ⊦ wi (ph x3) (ps x3)) :
  ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)) :=
@reximia (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @a1i (wi (ph x3) (ps x3)) (wcel (cv x3) (A2 x3))
    (reximi_1 x3))


/-- Inference quantifying both antecedent and consequent, based on Theorem 19.22 of [Margaris] p.
90. (Contributed by NM, 8-Nov-2004.) -/
theorem reximi2 {ph ps : setvar → wff} {A2 B2 : setvar → «class»}
  (reximi2_1 : ∀ x3, ⊦ wi (wa (wcel (cv x3) (A2 x3)) (ph x3)) (wa (wcel (cv x3) (B2 x3)) (ps x3))) :
  ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, B2 x3)) :=
@«3imtr4i» (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (wex (λ x3, wa (wcel (cv x3) (B2 x3)) (ps x3))) (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, B2 x3))
  (@eximi (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wa (wcel (cv x3) (B2 x3)) (ps x3))
    (λ x3, reximi2_1 x3))
  (@df_rex (λ x3, ph x3) (λ x3, A2 x3))
  (@df_rex (λ x3, ps x3) (λ x3, B2 x3))


/-- Inference adding different restricted existential quantifiers to each side of an equivalence.
(Contributed by NM, 4-Feb-2004.) -/
theorem rexbii2 {ph ps : setvar → wff} {A2 B2 : setvar → «class»}
  (rexbii2_1 : ∀ x3, ⊦ wb (wa (wcel (cv x3) (A2 x3)) (ph x3)) (wa (wcel (cv x3) (B2 x3)) (ps x3))) :
  ⊦ wb (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, B2 x3)) :=
@«3bitr4i» (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (wex (λ x3, wa (wcel (cv x3) (B2 x3)) (ps x3))) (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, B2 x3))
  (@exbii (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wa (wcel (cv x3) (B2 x3)) (ps x3))
    (λ x3, rexbii2_1 x3))
  (@df_rex (λ x3, ph x3) (λ x3, A2 x3))
  (@df_rex (λ x3, ps x3) (λ x3, B2 x3))


/-- Inference adding restricted existential quantifier to both sides of an equivalence. (Contributed
by NM, 26-Oct-1999.) -/
theorem rexbiia {ph ps : setvar → wff} {A2 : setvar → «class»}
  (rexbiia_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wb (ph x3) (ps x3))) :
  ⊦ wb (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)) :=
@rexbii2 (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3) (λ x3, A2 x3)
  (λ x3, @pm5_32i (wcel (cv x3) (A2 x3)) (ph x3) (ps x3)
    (rexbiia_1 x3))


/-- Inference adding restricted existential quantifier to both sides of an equivalence. (Contributed
by NM, 23-Nov-1994.) (Revised by Mario Carneiro, 17-Oct-2016.) (Proof shortened by Wolf Lammen,
6-Dec-2019.) -/
theorem rexbii {ph ps : setvar → wff} {A2 : setvar → «class»}
  (rexbii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)) :=
@rexbiia (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @a1i (wb (ph x3) (ps x3)) (wcel (cv x3) (A2 x3))
    (rexbii_1 x3))


/-- Inference adding two restricted existential quantifiers to both sides of an equivalence.
(Contributed by NM, 11-Nov-1995.) -/
theorem «2rexbii» {ph ps : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (rexbii_1 : ∀ x3 y, ⊦ wb (ph x3 y) (ps x3 y))
  (y : setvar) : ⊦ wb (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wrex (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) :=
@rexbii (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)
  (λ x3, @rexbii (λ y, ph x3 y) (λ y, ps x3 y) (λ y, B2 x3 y)
    (λ y, rexbii_1 x3 y))


/-- Commutation of restricted and unrestricted existential quantifiers. (Contributed by NM,
12-Apr-2004.) (Proof shortened by Andrew Salmon, 8-Jun-2011.) Reduce axiom dependencies. (Revised by
BJ, 13-Jun-2019.) -/
theorem rexcom4 {ph : setvar → setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wex (λ y, ph x3 y)) (λ x3, A2 x3)) (wex (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3))) :=
@«3bitr4ri» (wex (λ x3, wex (λ y, wa (wcel (cv x3) (A2 x3)) (ph x3 y)))) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (wex (λ y, ph x3 y)))) (wex (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3))) (wrex (λ x3, wex (λ y, ph x3 y)) (λ x3, A2 x3))
  (@exdistr (λ x3, wcel (cv x3) (A2 x3)) (λ x3 y, ph x3 y))
  (@bitri (wex (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3))) (wex (λ y, wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3 y)))) (wex (λ x3, wex (λ y, wa (wcel (cv x3) (A2 x3)) (ph x3 y))))
    (@exbii (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3 y)))
      (λ y, @df_rex (λ x3, ph x3 y) (λ x3, A2 x3)))
    (@excom (λ y x3, wa (wcel (cv x3) (A2 x3)) (ph x3 y))))
  (@df_rex (λ x3, wex (λ y, ph x3 y)) (λ x3, A2 x3))


/-- Restricted quantifier version of ~ 19.29 . See also ~ r19.29r . (Contributed by NM,
31-Aug-1999.) (Proof shortened by Andrew Salmon, 30-May-2011.) -/
theorem r19_29 {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wi (wa (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) (wrex (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)) :=
@imp (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3))
  (@syl (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, wi (ps x3) (wa (ph x3) (ps x3))) (λ x3, A2 x3)) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)))
    (@ralimi (λ x3, ph x3) (λ x3, wi (ps x3) (wa (ph x3) (ps x3))) (λ x3, A2 x3)
      (λ x3, @pm3_2 (ph x3) (ps x3)))
    (@rexim (λ x3, ps x3) (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)))


/-- Restricted quantifier version of ~ 19.29r ; variation of ~ r19.29 . (Contributed by NM,
31-Aug-1999.) (Proof shortened by Wolf Lammen, 29-Jun-2023.) -/
theorem r19_29r {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wi (wa (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3))) (wrex (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)) :=
@syl (wa (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, ps x3) (λ x3, A2 x3))) (wrex (λ x3, wa (ps x3) (ph x3)) (λ x3, A2 x3)) (wrex (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3))
  (@ancoms (wral (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, wa (ps x3) (ph x3)) (λ x3, A2 x3))
    (@r19_29 (λ x3, ps x3) (λ x3, ph x3) (λ x3, A2 x3)))
  (@reximi (λ x3, wa (ps x3) (ph x3)) (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)
    (λ x3, @pm3_22 (ps x3) (ph x3)))


/-- Relationship between two restricted universal and existential quantifiers. (Contributed by
Glauco Siliprandi, 11-Dec-2019.) (Proof shortened by Wolf Lammen, 18-May-2023.) -/
theorem ralnex2 {ph : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (y : setvar) : ⊦ wb (wral (λ x3, wral (λ y, wn (ph x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wn (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))) :=
@bitri (wral (λ x3, wral (λ y, wn (ph x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ x3, wn (wrex (λ y, ph x3 y) (λ y, B2 x3 y))) (λ x3, A2 x3 y)) (wn (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)))
  (@ralbii (λ x3, wral (λ y, wn (ph x3 y)) (λ y, B2 x3 y)) (λ x3, wn (wrex (λ y, ph x3 y) (λ y, B2 x3 y))) (λ x3, A2 x3 y)
    (λ x3, @ralnex (λ y, ph x3 y) (λ y, B2 x3 y)))
  (@ralnex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))


/-- A transformation of restricted quantifiers and logical connectives. (Contributed by NM,
4-Sep-2005.) (Proof shortened by Wolf Lammen, 27-Dec-2019.) -/
theorem rexanali {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wa (ph x3) (wn (ps x3))) (λ x3, A2 x3)) (wn (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3))) :=
@xchbinxr (wrex (λ x3, wa (ph x3) (wn (ps x3))) (λ x3, A2 x3)) (wral (λ x3, wn (wa (ph x3) (wn (ps x3)))) (λ x3, A2 x3)) (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3))
  (@dfrex2 (λ x3, wa (ph x3) (wn (ps x3))) (λ x3, A2 x3))
  (@ralbii (λ x3, wi (ph x3) (ps x3)) (λ x3, wn (wa (ph x3) (wn (ps x3)))) (λ x3, A2 x3)
    (λ x3, @iman (ph x3) (ps x3)))


/-- Two ways to say " ` A ` belongs to ` B ` ". (Contributed by NM, 22-Nov-1994.) -/
theorem risset {A2 B2 : «class»} :
  ⊦ wb (wcel A2 B2) (wrex (λ x3, wceq (cv x3) A2) (λ x3, B2)) :=
@«3bitr4ri» (wex (λ x3, wa (wcel (cv x3) B2) (wceq (cv x3) A2))) (wex (λ x3, wa (wceq (cv x3) A2) (wcel (cv x3) B2))) (wrex (λ x3, wceq (cv x3) A2) (λ x3, B2)) (wcel A2 B2)
  (@exancom (λ x3, wcel (cv x3) B2) (λ x3, wceq (cv x3) A2))
  (@df_rex (λ x3, wceq (cv x3) A2) (λ x3, B2))
  (@dfclel A2 B2)


/-- Inference adding restricted existential quantifier to negated wff. (Contributed by NM,
16-Oct-2003.) -/
theorem nrex {ps : setvar → wff} {A2 : setvar → «class»}
  (nrex_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wn (ps x3))) :
  ⊦ wn (wrex (λ x3, ps x3) (λ x3, A2 x3)) :=
@mpbi (wral (λ x3, wn (ps x3)) (λ x3, A2 x3)) (wn (wrex (λ x3, ps x3) (λ x3, A2 x3)))
  (@rgen (λ x3, wn (ps x3)) (λ x3, A2 x3)
    (λ x3, nrex_1 x3))
  (@ralnex (λ x3, ps x3) (λ x3, A2 x3))


/-- Deduction adding restricted existential quantifier to negated wff. (Contributed by NM,
16-Oct-2003.) (Proof shortened by Wolf Lammen, 5-Jan-2020.) -/
theorem nrexdv {ph : wff} {ps : setvar → wff} {A2 : setvar → «class»}
  (nrexdv_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wn (ps x3))) :
  ⊦ wi ph (wn (wrex (λ x3, ps x3) (λ x3, A2 x3))) :=
@sylib ph (wral (λ x3, wn (ps x3)) (λ x3, A2 x3)) (wn (wrex (λ x3, ps x3) (λ x3, A2 x3)))
  (@ralrimiva ph (λ x3, wn (ps x3)) (λ x3, A2 x3)
    (λ x3, nrexdv_1 x3))
  (@ralnex (λ x3, ps x3) (λ x3, A2 x3))


/-- Deduction quantifying both antecedent and consequent, based on Theorem 19.22 of [Margaris] p.
90. (Contributed by NM, 17-Sep-2003.) -/
theorem reximdv2 {ph : wff} {ps ch : setvar → wff} {A2 B2 : setvar → «class»}
  (reximdv2_1 : ∀ x3, ⊦ wi ph (wi (wa (wcel (cv x3) (A2 x3)) (ps x3)) (wa (wcel (cv x3) (B2 x3)) (ch x3)))) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, B2 x3))) :=
@«3imtr4g» ph (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))) (wex (λ x3, wa (wcel (cv x3) (B2 x3)) (ch x3))) (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, B2 x3))
  (@eximdv ph (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wa (wcel (cv x3) (B2 x3)) (ch x3))
    (λ x3, reximdv2_1 x3))
  (@df_rex (λ x3, ps x3) (λ x3, A2 x3))
  (@df_rex (λ x3, ch x3) (λ x3, B2 x3))


/-- Deduction quantifying both antecedent and consequent, based on Theorem 19.22 of [Margaris] p.
90. (Contributed by NM, 14-Nov-2002.) Reduce dependencies on axioms. (Revised by Wolf Lammen,
8-Jan-2020.) -/
theorem reximdvai {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (reximdvai_1 : ∀ x3, ⊦ wi ph (wi (wcel (cv x3) (A2 x3)) (wi (ps x3) (ch x3)))) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))) :=
@syl ph (wral (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3)))
  (@ralrimiv ph (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)
    (λ x3, reximdvai_1 x3))
  (@rexim (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3))


/-- Deduction from Theorem 19.22 of [Margaris] p. 90. (Restricted quantifier version with strong
hypothesis.) (Contributed by NM, 24-Jun-1998.) -/
theorem reximdv {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (reximdv_1 : ∀ x3, ⊦ wi ph (wi (ps x3) (ch x3))) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))) :=
@reximdvai ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  (λ x3, @a1d ph (wi (ps x3) (ch x3)) (wcel (cv x3) (A2 x3))
    (reximdv_1 x3))


/-- Deduction quantifying both antecedent and consequent, based on Theorem 19.22 of [Margaris] p.
90. (Contributed by NM, 22-May-1999.) -/
theorem reximdva {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (reximdva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wi (ps x3) (ch x3))) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))) :=
@reximdvai ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  (λ x3, @ex ph (wcel (cv x3) (A2 x3)) (wi (ps x3) (ch x3))
    (reximdva_1 x3))


/-- Deduction from Theorem 19.22 of [Margaris] p. 90. (Contributed by Thierry Arnoux, 7-Dec-2016.)
-/
theorem reximddv {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (reximddva_1 : ∀ x3, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (ps x3))) (ch x3))
  (reximddva_2 : ⊦ wi ph (wrex (λ x3, ps x3) (λ x3, A2 x3))) :
  ⊦ wi ph (wrex (λ x3, ch x3) (λ x3, A2 x3)) :=
@mpd ph (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))
  reximddva_2
  (@reximdva ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
    (λ x3, @expr ph (wcel (cv x3) (A2 x3)) (ps x3) (ch x3)
      (reximddva_1 x3)))


/-- Restricted quantifier version of ~ 19.23v . Version of ~ r19.23 with a disjoint variable
condition. (Contributed by NM, 31-Aug-1999.) Reduce dependencies on axioms. (Revised by Wolf Lammen,
14-Jan-2020.) -/
theorem r19_23v {ph : setvar → wff} {ps : wff} {A2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wi (ph x3) ps) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps) :=
@«3bitri» (wral (λ x3, wi (ph x3) ps) (λ x3, A2 x3)) (wral (λ x3, wi (wn ps) (wn (ph x3))) (λ x3, A2 x3)) (wi (wn ps) (wral (λ x3, wn (ph x3)) (λ x3, A2 x3))) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps)
  (@ralbii (λ x3, wi (ph x3) ps) (λ x3, wi (wn ps) (wn (ph x3))) (λ x3, A2 x3)
    (λ x3, @con34b (ph x3) ps))
  (@r19_21v (wn ps) (λ x3, wn (ph x3)) (λ x3, A2 x3))
  (@bitr2i (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps) (wi (wn (wral (λ x3, wn (ph x3)) (λ x3, A2 x3))) ps) (wi (wn ps) (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)))
    (@imbi1i (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wn (wral (λ x3, wn (ph x3)) (λ x3, A2 x3))) ps
      (@dfrex2 (λ x3, ph x3) (λ x3, A2 x3)))
    (@con1b (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) ps))


/-- Inference from Theorem 19.23 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 20-Nov-1994.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 14-Jan-2020.) -/
theorem rexlimiv {ph : setvar → wff} {ps : wff} {A2 : setvar → «class»}
  (rexlimiv_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wi (ph x3) ps)) :
  ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps :=
@mpbi (wral (λ x3, wi (ph x3) ps) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps)
  (@rgen (λ x3, wi (ph x3) ps) (λ x3, A2 x3)
    (λ x3, rexlimiv_1 x3))
  (@r19_23v (λ x3, ph x3) ps (λ x3, A2 x3))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by NM, 18-Dec-2006.) -/
theorem rexlimiva {ph : setvar → wff} {ps : wff} {A2 : setvar → «class»}
  (rexlimiva_1 : ∀ x3, ⊦ wi (wa (wcel (cv x3) (A2 x3)) (ph x3)) ps) :
  ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps :=
@rexlimiv (λ x3, ph x3) ps (λ x3, A2 x3)
  (λ x3, @ex (wcel (cv x3) (A2 x3)) (ph x3) ps
    (rexlimiva_1 x3))


/-- Weaker version of ~ rexlimiv . (Contributed by FL, 19-Sep-2011.) -/
theorem rexlimivw {ph : setvar → wff} {ps : wff} {A2 : setvar → «class»}
  (rexlimivw_1 : ∀ x3, ⊦ wi (ph x3) ps) :
  ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps :=
@rexlimiv (λ x3, ph x3) ps (λ x3, A2 x3)
  (λ x3, @a1i (wi (ph x3) ps) (wcel (cv x3) (A2 x3))
    (rexlimivw_1 x3))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by NM, 14-Nov-2002.) (Proof shortened by Eric Schmidt, 22-Dec-2006.) Reduce dependencies on axioms.
(Revised by Wolf Lammen, 14-Jan-2020.) -/
theorem rexlimdv {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdv_1 : ∀ x3, ⊦ wi ph (wi (wcel (cv x3) (A2 x3)) (wi (ps x3) ch))) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch) :=
@com12 (wrex (λ x3, ps x3) (λ x3, A2 x3)) ph ch
  (@rexlimiv (λ x3, ps x3) (wi ph ch) (λ x3, A2 x3)
    (λ x3, @com3l ph (wcel (cv x3) (A2 x3)) (ps x3) ch
      (rexlimdv_1 x3)))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by NM, 20-Jan-2007.) -/
theorem rexlimdva {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wi (ps x3) ch)) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch) :=
@rexlimdv ph (λ x3, ps x3) ch (λ x3, A2 x3)
  (λ x3, @ex ph (wcel (cv x3) (A2 x3)) (wi (ps x3) ch)
    (rexlimdva_1 x3))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by Mario Carneiro, 15-Jun-2016.) -/
theorem rexlimdvaa {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdvaa_1 : ∀ x3, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (ps x3))) ch) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch) :=
@rexlimdva ph (λ x3, ps x3) ch (λ x3, A2 x3)
  (λ x3, @expr ph (wcel (cv x3) (A2 x3)) (ps x3) ch
    (rexlimdvaa_1 x3))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version).
Frequently-used variant of ~ rexlimdv . (Contributed by NM, 7-Jun-2015.) -/
theorem rexlimdv3a {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdv3a_1 : ∀ x3, ⊦ wi (w3a ph (wcel (cv x3) (A2 x3)) (ps x3)) ch) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch) :=
@rexlimdv ph (λ x3, ps x3) ch (λ x3, A2 x3)
  (λ x3, @«3exp» ph (wcel (cv x3) (A2 x3)) (ps x3) ch
    (rexlimdv3a_1 x3))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by Glauco Siliprandi, 2-Jan-2022.) -/
theorem rexlimdva2 {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdva2_1 : ∀ x3, ⊦ wi (wa (wa ph (wcel (cv x3) (A2 x3))) (ps x3)) ch) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch) :=
@rexlimdv ph (λ x3, ps x3) ch (λ x3, A2 x3)
  (λ x3, @exp31 ph (wcel (cv x3) (A2 x3)) (ps x3) ch
    (rexlimdva2_1 x3))


/-- A commonly used pattern in the spirit of ~ r19.29 . (Contributed by Thierry Arnoux,
29-Dec-2019.) (Proof shortened by Wolf Lammen, 17-Jun-2023.) -/
theorem r19_29an {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdva2_1 : ∀ x3, ⊦ wi (wa (wa ph (wcel (cv x3) (A2 x3))) (ps x3)) ch) :
  ⊦ wi (wa ph (wrex (λ x3, ps x3) (λ x3, A2 x3))) ch :=
@imp ph (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch
  (@rexlimdva2 ph (λ x3, ps x3) ch (λ x3, A2 x3)
    (λ x3, rexlimdva2_1 x3))


/-- A commonly used pattern in the spirit of ~ r19.29 . (Contributed by Thierry Arnoux,
22-Nov-2017.) Reduce axiom usage. (Revised by Wolf Lammen, 17-Jun-2023.) -/
theorem r19_29a {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdva2_1 : ∀ x3, ⊦ wi (wa (wa ph (wcel (cv x3) (A2 x3))) (ps x3)) ch)
  (r19_29a_1 : ⊦ wi ph (wrex (λ x3, ps x3) (λ x3, A2 x3))) :
  ⊦ wi ph ch :=
@mpd ph (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch
  r19_29a_1
  (@rexlimdva2 ph (λ x3, ps x3) ch (λ x3, A2 x3)
    (λ x3, rexlimdva2_1 x3))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by NM, 18-Jun-2014.) -/
theorem rexlimdvw {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimdvw_1 : ∀ x3, ⊦ wi ph (wi (ps x3) ch)) :
  ⊦ wi ph (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch) :=
@rexlimdv ph (λ x3, ps x3) ch (λ x3, A2 x3)
  (λ x3, @a1d ph (wi (ps x3) ch) (wcel (cv x3) (A2 x3))
    (rexlimdvw_1 x3))


/-- Restricted existential elimination rule of natural deduction. (Contributed by Mario Carneiro,
15-Jun-2016.) -/
theorem rexlimddv {ph : wff} {ps : setvar → wff} {ch : wff} {A2 : setvar → «class»}
  (rexlimddv_1 : ⊦ wi ph (wrex (λ x3, ps x3) (λ x3, A2 x3)))
  (rexlimddv_2 : ∀ x3, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (ps x3))) ch) :
  ⊦ wi ph ch :=
@mpd ph (wrex (λ x3, ps x3) (λ x3, A2 x3)) ch
  rexlimddv_1
  (@rexlimdvaa ph (λ x3, ps x3) ch (λ x3, A2 x3)
    (λ x3, rexlimddv_2 x3))


/-- Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier version). (Contributed
by NM, 17-Feb-2004.) -/
theorem rexlimivv {ph : setvar → setvar → wff} {ps : wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (rexlimivv_1 : ∀ x3 y, ⊦ wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wi (ph x3 y) ps)) :
  ⊦ wi (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) ps :=
@rexlimiv (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) ps (λ x3, A2 x3)
  (λ x3, @rexlimdva (wcel (cv x3) (A2 x3)) (λ y, ph x3 y) ps (λ y, B2 x3 y)
    (λ y, rexlimivv_1 x3 y))


/-- Inference from Theorem 19.23 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 22-Jul-2004.) -/
theorem rexlimdvv {ph : wff} {ps : setvar → setvar → wff} {ch : wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (rexlimdvv_1 : ∀ x3 y, ⊦ wi ph (wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wi (ps x3 y) ch))) :
  ⊦ wi ph (wi (wrex (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) ch) :=
@rexlimdva ph (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) ch (λ x3, A2 x3)
  (λ x3, @rexlimdv (wa ph (wcel (cv x3) (A2 x3))) (λ y, ps x3 y) ch (λ y, B2 x3 y)
    (λ y, @expdimp ph (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wi (ps x3 y) ch)
      (rexlimdvv_1 x3 y)))


/-- Inference from Theorem 19.23 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 18-Jun-2014.) -/
theorem rexlimdvva {ph : wff} {ps : setvar → setvar → wff} {ch : wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  (rexlimdvva_1 : ∀ x3 y, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)))) (wi (ps x3 y) ch)) :
  ⊦ wi ph (wi (wrex (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) ch) :=
@rexlimdvv ph (λ x3 y, ps x3 y) ch (λ x3, A2 x3) (λ x3 y, B2 x3 y)
  (λ x3 y, @ex ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (wi (ps x3 y) ch)
    (rexlimdvva_1 x3 y))


/-- Formula-building rule for restricted existential quantifier (deduction form). (Contributed by
NM, 22-May-1999.) -/
theorem rexbidv2 {ph : wff} {ps ch : setvar → wff} {A2 B2 : setvar → «class»}
  (rexbidv2_1 : ∀ x3, ⊦ wi ph (wb (wa (wcel (cv x3) (A2 x3)) (ps x3)) (wa (wcel (cv x3) (B2 x3)) (ch x3)))) :
  ⊦ wi ph (wb (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, B2 x3))) :=
@«3bitr4g» ph (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))) (wex (λ x3, wa (wcel (cv x3) (B2 x3)) (ch x3))) (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, B2 x3))
  (@exbidv ph (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wa (wcel (cv x3) (B2 x3)) (ch x3))
    (λ x3, rexbidv2_1 x3))
  (@df_rex (λ x3, ps x3) (λ x3, A2 x3))
  (@df_rex (λ x3, ch x3) (λ x3, B2 x3))


/-- Formula-building rule for restricted existential quantifier (deduction form). (Contributed by
NM, 9-Mar-1997.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 6-Dec-2019.) (Proof
shortened by Wolf Lammen, 10-Dec-2019.) -/
theorem rexbidva {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (rexbidva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))) :=
@rexbidv2 ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3) (λ x3, A2 x3)
  (λ x3, @pm5_32da ph (wcel (cv x3) (A2 x3)) (ps x3) (ch x3)
    (rexbidva_1 x3))


/-- Formula-building rule for restricted existential quantifier (deduction form). (Contributed by
NM, 20-Nov-1994.) Reduce dependencies on axioms. (Revised by Wolf Lammen, 6-Dec-2019.) -/
theorem rexbidv {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (rexbidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))) :=
@rexbidva ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  (λ x3, @adantr ph (wb (ps x3) (ch x3)) (wcel (cv x3) (A2 x3))
    (rexbidv_1 x3))


/-- Formula-building rule for restricted existential quantifiers (deduction form). (Contributed by
NM, 15-Dec-2004.) -/
theorem «2rexbidva» {ph : wff} {ps ch : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»}
  («2rexbidva_1» : ∀ x3 y, ⊦ wi (wa ph (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)))) (wb (ps x3 y) (ch x3 y))) :
  ⊦ wi ph (wb (wrex (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wrex (λ x3, wrex (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3))) :=
@rexbidva ph (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, wrex (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)
  (λ x3, @rexbidva (wa ph (wcel (cv x3) (A2 x3))) (λ y, ps x3 y) (λ y, ch x3 y) (λ y, B2 x3 y)
    (λ y, @anassrs ph (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y)) (wb (ps x3 y) (ch x3 y))
      («2rexbidva_1» x3 y)))


/-- Formula-building rule for restricted existential quantifiers (deduction form). (Contributed by
NM, 28-Jan-2006.) -/
theorem «2rexbidv» {ph : wff} {ps ch : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  («2rexbidv_1» : ∀ x3 y, ⊦ wi ph (wb (ps x3 y) (ch x3 y)))
  (y : setvar) : ⊦ wi ph (wb (wrex (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wrex (λ x3, wrex (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))) :=
@rexbidv ph (λ x3, wrex (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, wrex (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)
  (λ x3, @rexbidv ph (λ y, ps x3 y) (λ y, ch x3 y) (λ y, B2 x3 y)
    (λ y, «2rexbidv_1» x3 y))


/-- Formula-building rule for restricted quantifiers (deduction form). (Contributed by NM,
28-Jan-2006.) -/
theorem rexralbidv {ph : wff} {ps ch : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  («2rexbidv_1» : ∀ x3 y, ⊦ wi ph (wb (ps x3 y) (ch x3 y)))
  (y : setvar) : ⊦ wi ph (wb (wrex (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wrex (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))) :=
@rexbidv ph (λ x3, wral (λ y, ps x3 y) (λ y, B2 x3 y)) (λ x3, wral (λ y, ch x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)
  (λ x3, @ralbidv ph (λ y, ps x3 y) (λ y, ch x3 y) (λ y, B2 x3 y)
    (λ y, «2rexbidv_1» x3 y))


/-- Lemma factoring out common proof steps in ~ r2exf an ~ r2ex . Introduced to reduce dependencies
on axioms. (Contributed by Wolf Lammen, 10-Jan-2020.) -/
theorem r2exlem {ph : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (r2exlem_1 : ∀ y, ⊦ wb (wral (λ x3, wral (λ y, wn (ph x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (wn (ph x3 y))))))
  (y : setvar) : ⊦ wb (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) :=
@«3bitr4ri» (wex (λ x3, wn (wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (wn (ph x3 y)))))) (wn (wral (λ x3, wral (λ y, wn (ph x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y))) (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))
  (@xchbinxr (wex (λ x3, wn (wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (wn (ph x3 y)))))) (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (wn (ph x3 y))))) (wral (λ x3, wral (λ y, wn (ph x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y))
    (@exnal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (wn (ph x3 y)))))
    (r2exlem_1 y))
  (@exbii (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y))) (λ x3, wn (wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (wn (ph x3 y)))))
    (λ x3, @exnalimn (λ y, wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (λ y, ph x3 y)))
  (@con2bii (wral (λ x3, wral (λ y, wn (ph x3 y)) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y))
    (@ralnex2 (λ x3 y, ph x3 y) (λ x3 y, A2 x3 y) (λ x3 y, B2 x3 y) y))


/-- Double restricted existential quantification. (Contributed by NM, 11-Nov-1995.) Reduce
dependencies on axioms. (Revised by Wolf Lammen, 10-Jan-2020.) -/
theorem r2ex {ph : setvar → setvar → wff} {A2 : setvar → «class»} {B2 : setvar → setvar → «class»} :
  ⊦ wb (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) :=
setvar.forget $ λ y : setvar,
  show ⊦ wb (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3)) (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))), from
  @r2exlem (λ x3 y, ph x3 y) (λ x3 y, A2 x3) (λ x3 y, B2 x3 y)
    (λ y, @r2al (λ x3 y, wn (ph x3 y)) (λ x3, A2 x3) (λ x3 y, B2 x3 y)) y


/-- Restricted specialization. (Contributed by NM, 12-Oct-1999.) -/
theorem rspe {ph : setvar → wff} {A2 : setvar → «class»}
  (x3 : setvar) : ⊦ wi (wa (wcel (cv x3) (A2 x3)) (ph x3)) (wrex (λ x3, ph x3) (λ x3, A2 x3)) :=
@sylibr (wa (wcel (cv x3) (A2 x3)) (ph x3)) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (wrex (λ x3, ph x3) (λ x3, A2 x3))
  (@«19_8a» (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) x3)
  (@df_rex (λ x3, ph x3) (λ x3, A2 x3))


/-- The setvar ` x ` is not free in ` E. x e. A ph ` . (Contributed by NM, 19-Mar-1997.) (Revised by
Mario Carneiro, 7-Oct-2016.) -/
theorem nfre1 {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wnf (λ x3, wrex (λ x3, ph x3) (λ x3, A2 x3)) :=
@nfxfr (λ x3, wrex (λ x3, ph x3) (λ x3, A2 x3)) (λ x3, wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))
  (λ x3, @df_rex (λ x3, ph x3) (λ x3, A2 x3))
  (@nfe1 (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))


/-- Deduction version of ~ nfrex . (Contributed by Mario Carneiro, 14-Oct-2016.) Add disjoint
variable condition to avoid ~ ax-13 . See ~ nfrexdg for a less restrictive version requiring more
axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem nfrexd {ph ps : setvar → setvar → wff} {A2 : setvar → setvar → «class»}
  (nfrexd_1 : ∀ x3, ⊦ wnf (λ y, ph x3 y))
  (nfrexd_2 : ∀ x3 y, ⊦ wi (ph x3 y) (wnfc (λ x3, A2 x3 y)))
  (nfrexd_3 : ∀ x3 y, ⊦ wi (ph x3 y) (wnf (λ x3, ps x3 y)))
  (x3 y : setvar) : ⊦ wi (ph x3 y) (wnf (λ x3, wrex (λ y, ps x3 y) (λ y, A2 x3 y))) :=
@nfxfrd (λ x3, wrex (λ y, ps x3 y) (λ y, A2 x3 y)) (λ x3, wn (wral (λ y, wn (ps x3 y)) (λ y, A2 x3 y))) (λ x3, ph x3 y)
  (λ x3, @dfrex2 (λ y, ps x3 y) (λ y, A2 x3 y))
  (λ x3, @nfnd (λ x3, ph x3 y) (λ x3, wral (λ y, wn (ps x3 y)) (λ y, A2 x3 y))
    (λ x3, @nfraldw (λ x3 y, ph x3 y) (λ x3 y, wn (ps x3 y)) (λ x3 y, A2 x3 y)
      (λ x3, nfrexd_1 x3)
      (λ x3 y, nfrexd_2 x3 y)
      (λ x3 y, @nfnd (λ x3, ph x3 y) (λ x3, ps x3 y)
        (λ x3, nfrexd_3 x3 y) x3) x3 y) x3) x3


/-- Bound-variable hypothesis builder for restricted quantification. (Contributed by NM,
1-Sep-1999.) (Revised by Mario Carneiro, 7-Oct-2016.) (Proof shortened by Wolf Lammen, 30-Dec-2019.)
Add disjoint variable condition to avoid ~ ax-13 . See ~ nfrexg for a less restrictive version
requiring more axioms. (Revised by Gino Giotto, 20-Jan-2024.) -/
theorem nfrex {ph : setvar → setvar → wff} {A2 : setvar → setvar → «class»}
  (nfrex_1 : ∀ y, ⊦ wnfc (λ x3, A2 x3 y))
  (nfrex_2 : ∀ y, ⊦ wnf (λ x3, ph x3 y)) :
  ⊦ wnf (λ x3, wrex (λ y, ph x3 y) (λ y, A2 x3 y)) :=
@mptru (wnf (λ x3, wrex (λ y, ph x3 y) (λ y, A2 x3 y)))
  (setvar.forget $ λ x3 : setvar,
    setvar.forget $ λ y : setvar,
    show ⊦ wi wtru (wnf (λ x3, wrex (λ y, ph x3 y) (λ y, A2 x3 y))), from
    @nfrexd (λ x3 y, wtru) (λ x3 y, ph x3 y) (λ x3 y, A2 x3 y)
      (λ x3, nftru)
      (λ x3 y, @a1i (wnfc (λ x3, A2 x3 y)) wtru
        (nfrex_1 y))
      (λ x3 y, @a1i (wnf (λ x3, ph x3 y)) wtru
        (nfrex_2 y)) x3 y)


/-- Deduction from Theorem 19.22 of [Margaris] p. 90. (Restricted quantifier version.) (Contributed
by NM, 31-Aug-1999.) -/
theorem reximdai {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (reximdai_1 : ⊦ wnf (λ x3, ph x3))
  (reximdai_2 : ∀ x3, ⊦ wi (ph x3) (wi (wcel (cv x3) (A2 x3)) (wi (ps x3) (ch x3))))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))) :=
@syl (ph x3) (wral (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3)))
  (@ralrimi (λ x3, ph x3) (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)
    reximdai_1
    (λ x3, reximdai_2 x3) x3)
  (@rexim (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3))


/-- Closed theorem form of ~ r19.23 . (Contributed by NM, 4-Mar-2013.) (Revised by Mario Carneiro,
8-Oct-2016.) -/
theorem r19_23t {ph ps : setvar → wff} {A2 : setvar → «class»}
  (x3 : setvar) : ⊦ wi (wnf (λ x3, ps x3)) (wb (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (ps x3))) :=
@«3bitr4g» (wnf (λ x3, ps x3)) (wal (λ x3, wi (wa (wcel (cv x3) (A2 x3)) (ph x3)) (ps x3))) (wi (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (ps x3)) (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (ps x3))
  (@«19_23t» (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, ps x3) x3)
  (@bitr4i (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wal (λ x3, wi (wcel (cv x3) (A2 x3)) (wi (ph x3) (ps x3)))) (wal (λ x3, wi (wa (wcel (cv x3) (A2 x3)) (ph x3)) (ps x3)))
    (@df_ral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3))
    (@albii (λ x3, wi (wa (wcel (cv x3) (A2 x3)) (ph x3)) (ps x3)) (λ x3, wi (wcel (cv x3) (A2 x3)) (wi (ph x3) (ps x3)))
      (λ x3, @impexp (wcel (cv x3) (A2 x3)) (ph x3) (ps x3))))
  (@imbi1i (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (ps x3)
    (@df_rex (λ x3, ph x3) (λ x3, A2 x3)))


/-- Restricted quantifier version of ~ 19.23 . See ~ r19.23v for a version requiring fewer axioms.
(Contributed by NM, 22-Oct-2010.) (Proof shortened by Mario Carneiro, 8-Oct-2016.) -/
theorem r19_23 {ph ps : setvar → wff} {A2 : setvar → «class»}
  (r19_23_1 : ⊦ wnf (λ x3, ps x3))
  (x3 : setvar) : ⊦ wb (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (ps x3)) :=
@ax_mp (wnf (λ x3, ps x3)) (wb (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (ps x3)))
  r19_23_1
  (@r19_23t (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3) x3)


/-- Restricted quantifier version of ~ exlimi . (Contributed by NM, 30-Nov-2003.) (Proof shortened
by Andrew Salmon, 30-May-2011.) -/
theorem rexlimi {ph ps : setvar → wff} {A2 : setvar → «class»}
  (rexlimi_1 : ⊦ wnf (λ x3, ps x3))
  (rexlimi_2 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wi (ph x3) (ps x3)))
  (x3 : setvar) : ⊦ wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (ps x3) :=
@mpbi (wral (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ph x3) (λ x3, A2 x3)) (ps x3))
  (@rgen (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)
    (λ x3, rexlimi_2 x3))
  (@r19_23 (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
    rexlimi_1 x3)


/-- Version of ~ rexlimd with deduction version of second hypothesis. (Contributed by NM,
21-Jul-2013.) (Revised by Mario Carneiro, 8-Oct-2016.) -/
theorem rexlimd2 {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (rexlimd2_1 : ⊦ wnf (λ x3, ph x3))
  (rexlimd2_2 : ∀ x3, ⊦ wi (ph x3) (wnf (λ x3, ch x3)))
  (rexlimd2_3 : ∀ x3, ⊦ wi (ph x3) (wi (wcel (cv x3) (A2 x3)) (wi (ps x3) (ch x3))))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (ch x3)) :=
@mpbid (ph x3) (wral (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (ch x3))
  (@ralrimi (λ x3, ph x3) (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)
    rexlimd2_1
    (λ x3, rexlimd2_3 x3) x3)
  (@syl (ph x3) (wnf (λ x3, ch x3)) (wb (wral (λ x3, wi (ps x3) (ch x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (ch x3)))
    (rexlimd2_2 x3)
    (@r19_23t (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3) x3))


/-- Deduction form of ~ rexlimd . (Contributed by NM, 27-May-1998.) (Proof shortened by Andrew
Salmon, 30-May-2011.) (Proof shortened by Wolf Lammen, 14-Jan-2020.) -/
theorem rexlimd {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (rexlimd_1 : ⊦ wnf (λ x3, ph x3))
  (rexlimd_2 : ⊦ wnf (λ x3, ch x3))
  (rexlimd_3 : ∀ x3, ⊦ wi (ph x3) (wi (wcel (cv x3) (A2 x3)) (wi (ps x3) (ch x3))))
  (x3 : setvar) : ⊦ wi (ph x3) (wi (wrex (λ x3, ps x3) (λ x3, A2 x3)) (ch x3)) :=
@rexlimd2 (λ x3, ph x3) (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  rexlimd_1
  (λ x3, @a1i (wnf (λ x3, ch x3)) (ph x3)
    rexlimd_2)
  (λ x3, rexlimd_3 x3) x3


/-- Formula-building rule for restricted existential quantifier (deduction form). (Contributed by
NM, 6-Oct-2003.) -/
theorem rexbida {ph ps ch : setvar → wff} {A2 : setvar → «class»}
  (rexbida_1 : ⊦ wnf (λ x3, ph x3))
  (rexbida_2 : ∀ x3, ⊦ wi (wa (ph x3) (wcel (cv x3) (A2 x3))) (wb (ps x3) (ch x3)))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))) :=
@«3bitr4g» (ph x3) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ch x3))) (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, A2 x3))
  (@exbid (λ x3, ph x3) (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wa (wcel (cv x3) (A2 x3)) (ch x3))
    rexbida_1
    (λ x3, @pm5_32da (ph x3) (wcel (cv x3) (A2 x3)) (ps x3) (ch x3)
      (rexbida_2 x3)) x3)
  (@df_rex (λ x3, ps x3) (λ x3, A2 x3))
  (@df_rex (λ x3, ch x3) (λ x3, A2 x3))


/-- Restricted quantifier version of ~ 19.35 . (Contributed by NM, 20-Sep-2003.) -/
theorem r19_35 {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) :=
@impbii (wrex (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)))
  (@com12 (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))
    (@syl (wral (λ x3, ph x3) (λ x3, A2 x3)) (wral (λ x3, wi (wi (ph x3) (ps x3)) (ps x3)) (λ x3, A2 x3)) (wi (wrex (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)))
      (@ralimi (λ x3, ph x3) (λ x3, wi (wi (ph x3) (ps x3)) (ps x3)) (λ x3, A2 x3)
        (λ x3, @pm2_27 (ph x3) (ps x3)))
      (@rexim (λ x3, wi (ph x3) (ps x3)) (λ x3, ps x3) (λ x3, A2 x3))))
  (@ja (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3))
    (@sylbir (wn (wral (λ x3, ph x3) (λ x3, A2 x3))) (wrex (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wrex (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3))
      (@rexnal (λ x3, ph x3) (λ x3, A2 x3))
      (@reximi (λ x3, wn (ph x3)) (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)
        (λ x3, @pm2_21 (ph x3) (ps x3))))
    (@reximi (λ x3, ps x3) (λ x3, wi (ph x3) (ps x3)) (λ x3, A2 x3)
      (λ x3, @ax_1 (ps x3) (ph x3))))


/-- Restricted quantifier version of one direction of ~ 19.36 . (The other direction holds iff ` A `
is nonempty, see ~ r19.36zv .) (Contributed by NM, 22-Oct-2003.) -/
theorem r19_36v {ph : setvar → wff} {ps : wff} {A2 : setvar → «class»} :
  ⊦ wi (wrex (λ x3, wi (ph x3) ps) (λ x3, A2 x3)) (wi (wral (λ x3, ph x3) (λ x3, A2 x3)) ps) :=
@sylbi (wrex (λ x3, wi (ph x3) ps) (λ x3, A2 x3)) (wi (wral (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps) (λ x3, A2 x3))) (wi (wral (λ x3, ph x3) (λ x3, A2 x3)) ps)
  (@r19_35 (λ x3, ph x3) (λ x3, ps) (λ x3, A2 x3))
  (@imim2i (wrex (λ x3, ps) (λ x3, A2 x3)) ps (wral (λ x3, ph x3) (λ x3, A2 x3))
    (@rexlimivw (λ x3, ps) ps (λ x3, A2 x3)
      (λ x3, @id ps)))


/-- Restricted quantifier version of Theorem 19.40 of [Margaris] p. 90. (Contributed by NM,
2-Apr-2004.) -/
theorem r19_40 {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wi (wrex (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)) (wa (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) :=
@jca (wrex (λ x3, wa (ph x3) (ps x3)) (λ x3, A2 x3)) (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))
  (@reximi (λ x3, wa (ph x3) (ps x3)) (λ x3, ph x3) (λ x3, A2 x3)
    (λ x3, @simpl (ph x3) (ps x3)))
  (@reximi (λ x3, wa (ph x3) (ps x3)) (λ x3, ps x3) (λ x3, A2 x3)
    (λ x3, @simpr (ph x3) (ps x3)))


/-- Restricted quantifier version ~ 19.41v . Version of ~ r19.41 with a disjoint variable condition,
requiring fewer axioms. (Contributed by NM, 17-Dec-2003.) Reduce dependencies on axioms. (Revised by
BJ, 29-Mar-2020.) -/
theorem r19_41v {ph : setvar → wff} {ps : wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wa (ph x3) ps) (λ x3, A2 x3)) (wa (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps) :=
@«3bitr4i» (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (wa (ph x3) ps))) (wa (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) ps) (wrex (λ x3, wa (ph x3) ps) (λ x3, A2 x3)) (wa (wrex (λ x3, ph x3) (λ x3, A2 x3)) ps)
  (@bitr3i (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (wa (ph x3) ps))) (wex (λ x3, wa (wa (wcel (cv x3) (A2 x3)) (ph x3)) ps)) (wa (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) ps)
    (@exbii (λ x3, wa (wa (wcel (cv x3) (A2 x3)) (ph x3)) ps) (λ x3, wa (wcel (cv x3) (A2 x3)) (wa (ph x3) ps))
      (λ x3, @anass (wcel (cv x3) (A2 x3)) (ph x3) ps))
    (@«19_41v» (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) ps))
  (@df_rex (λ x3, wa (ph x3) ps) (λ x3, A2 x3))
  (@anbi1i (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) ps
    (@df_rex (λ x3, ph x3) (λ x3, A2 x3)))


/-- Version of ~ r19.41v with two quantifiers. (Contributed by Thierry Arnoux, 25-Jan-2017.) -/
theorem r19_41vv {ph : setvar → setvar → wff} {ps : wff} {A2 B2 : setvar → setvar → «class»}
  (y : setvar) : ⊦ wb (wrex (λ x3, wrex (λ y, wa (ph x3 y) ps) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wa (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) ps) :=
@bitri (wrex (λ x3, wrex (λ y, wa (ph x3 y) ps) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wrex (λ x3, wa (wrex (λ y, ph x3 y) (λ y, B2 x3 y)) ps) (λ x3, A2 x3 y)) (wa (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) ps)
  (@rexbii (λ x3, wrex (λ y, wa (ph x3 y) ps) (λ y, B2 x3 y)) (λ x3, wa (wrex (λ y, ph x3 y) (λ y, B2 x3 y)) ps) (λ x3, A2 x3 y)
    (λ x3, @r19_41v (λ y, ph x3 y) ps (λ y, B2 x3 y)))
  (@r19_41v (λ x3, wrex (λ y, ph x3 y) (λ y, B2 x3 y)) ps (λ x3, A2 x3 y))


/-- Restricted quantifier version of ~ 19.42v (see also ~ 19.42 ). (Contributed by NM, 27-May-1998.)
-/
theorem r19_42v {ph : wff} {ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wa ph (ps x3)) (λ x3, A2 x3)) (wa ph (wrex (λ x3, ps x3) (λ x3, A2 x3))) :=
@«3bitr4i» (wrex (λ x3, wa (ps x3) ph) (λ x3, A2 x3)) (wa (wrex (λ x3, ps x3) (λ x3, A2 x3)) ph) (wrex (λ x3, wa ph (ps x3)) (λ x3, A2 x3)) (wa ph (wrex (λ x3, ps x3) (λ x3, A2 x3)))
  (@r19_41v (λ x3, ps x3) ph (λ x3, A2 x3))
  (@rexbii (λ x3, wa ph (ps x3)) (λ x3, wa (ps x3) ph) (λ x3, A2 x3)
    (λ x3, @ancom ph (ps x3)))
  (@ancom ph (wrex (λ x3, ps x3) (λ x3, A2 x3)))


/-- Restricted quantifier version of ~ 19.43 . (Contributed by NM, 27-May-1998.) (Proof shortened by
Andrew Salmon, 30-May-2011.) -/
theorem r19_43 {ph ps : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wo (ph x3) (ps x3)) (λ x3, A2 x3)) (wo (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) :=
@«3bitr4i» (wrex (λ x3, wi (wn (ph x3)) (ps x3)) (λ x3, A2 x3)) (wi (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) (wrex (λ x3, wo (ph x3) (ps x3)) (λ x3, A2 x3)) (wo (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)))
  (@r19_35 (λ x3, wn (ph x3)) (λ x3, ps x3) (λ x3, A2 x3))
  (@rexbii (λ x3, wo (ph x3) (ps x3)) (λ x3, wi (wn (ph x3)) (ps x3)) (λ x3, A2 x3)
    (λ x3, @df_or (ph x3) (ps x3)))
  (@bitr4i (wo (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3))) (wi (wn (wrex (λ x3, ph x3) (λ x3, A2 x3))) (wrex (λ x3, ps x3) (λ x3, A2 x3))) (wi (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)))
    (@df_or (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ x3, ps x3) (λ x3, A2 x3)))
    (@imbi1i (wral (λ x3, wn (ph x3)) (λ x3, A2 x3)) (wn (wrex (λ x3, ph x3) (λ x3, A2 x3))) (wrex (λ x3, ps x3) (λ x3, A2 x3))
      (@ralnex (λ x3, ph x3) (λ x3, A2 x3))))


/-- Commutation of restricted universal quantifiers. See ~ ralcom2 for a version without disjoint
variable condition on ` x , y ` . This theorem should be used in place of ~ ralcom2 since it depends
on a smaller set of axioms. (Contributed by NM, 13-Oct-1999.) (Revised by Mario Carneiro,
14-Oct-2016.) -/
theorem ralcom {ph : setvar → setvar → wff} {A2 B2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 y)) (λ x3, A2 x3)) (wral (λ y, wral (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, B2 y)) :=
@«3bitr4i» (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y))) (ph x3 y)))) (wal (λ y, wal (λ x3, wi (wa (wcel (cv y) (B2 y)) (wcel (cv x3) (A2 x3))) (ph x3 y)))) (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 y)) (λ x3, A2 x3)) (wral (λ y, wral (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, B2 y))
  (@bitri (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y))) (ph x3 y)))) (wal (λ x3, wal (λ y, wi (wa (wcel (cv y) (B2 y)) (wcel (cv x3) (A2 x3))) (ph x3 y)))) (wal (λ y, wal (λ x3, wi (wa (wcel (cv y) (B2 y)) (wcel (cv x3) (A2 x3))) (ph x3 y))))
    (@«2albii» (λ x3 y, wi (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y))) (ph x3 y)) (λ x3 y, wi (wa (wcel (cv y) (B2 y)) (wcel (cv x3) (A2 x3))) (ph x3 y))
      (λ x3 y, @ancomst (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y)) (ph x3 y)))
    (@alcom (λ x3 y, wi (wa (wcel (cv y) (B2 y)) (wcel (cv x3) (A2 x3))) (ph x3 y))))
  (@r2al (λ x3 y, ph x3 y) (λ x3, A2 x3) (λ x3 y, B2 y))
  (@r2al (λ y x3, ph x3 y) (λ y, B2 y) (λ y x3, A2 x3))


/-- Commutation of restricted existential quantifiers. (Contributed by NM, 19-Nov-1995.) (Revised by
Mario Carneiro, 14-Oct-2016.) (Proof shortened by BJ, 26-Aug-2023.) -/
theorem rexcom {ph : setvar → setvar → wff} {A2 B2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 y)) (λ x3, A2 x3)) (wrex (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, B2 y)) :=
@«3bitri» (wrex (λ x3, wrex (λ y, ph x3 y) (λ y, B2 y)) (λ x3, A2 x3)) (wrex (λ x3, wex (λ y, wa (wcel (cv y) (B2 y)) (ph x3 y))) (λ x3, A2 x3)) (wex (λ y, wrex (λ x3, wa (wcel (cv y) (B2 y)) (ph x3 y)) (λ x3, A2 x3))) (wrex (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, B2 y))
  (@rexbii (λ x3, wrex (λ y, ph x3 y) (λ y, B2 y)) (λ x3, wex (λ y, wa (wcel (cv y) (B2 y)) (ph x3 y))) (λ x3, A2 x3)
    (λ x3, @df_rex (λ y, ph x3 y) (λ y, B2 y)))
  (@rexcom4 (λ x3 y, wa (wcel (cv y) (B2 y)) (ph x3 y)) (λ x3, A2 x3))
  (@bitr4i (wex (λ y, wrex (λ x3, wa (wcel (cv y) (B2 y)) (ph x3 y)) (λ x3, A2 x3))) (wex (λ y, wa (wcel (cv y) (B2 y)) (wrex (λ x3, ph x3 y) (λ x3, A2 x3)))) (wrex (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, B2 y))
    (@exbii (λ y, wrex (λ x3, wa (wcel (cv y) (B2 y)) (ph x3 y)) (λ x3, A2 x3)) (λ y, wa (wcel (cv y) (B2 y)) (wrex (λ x3, ph x3 y) (λ x3, A2 x3)))
      (λ y, @r19_42v (wcel (cv y) (B2 y)) (λ x3, ph x3 y) (λ x3, A2 x3)))
    (@df_rex (λ y, wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (λ y, B2 y)))


/-- Commutation of restricted universal quantifiers. (Contributed by Mario Carneiro, 14-Oct-2016.)
-/
theorem ralcomf {ph : setvar → setvar → wff} {A2 B2 : setvar → setvar → «class»}
  (ralcomf_1 : ∀ x3, ⊦ wnfc (λ y, A2 x3 y))
  (ralcomf_2 : ∀ y, ⊦ wnfc (λ x3, B2 x3 y))
  (x3 y : setvar) : ⊦ wb (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ y, wral (λ x3, ph x3 y) (λ x3, A2 x3 y)) (λ y, B2 x3 y)) :=
@«3bitr4i» (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) (wal (λ y, wal (λ x3, wi (wa (wcel (cv y) (B2 x3 y)) (wcel (cv x3) (A2 x3 y))) (ph x3 y)))) (wral (λ x3, wral (λ y, ph x3 y) (λ y, B2 x3 y)) (λ x3, A2 x3 y)) (wral (λ y, wral (λ x3, ph x3 y) (λ x3, A2 x3 y)) (λ y, B2 x3 y))
  (@bitri (wal (λ x3, wal (λ y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)))) (wal (λ x3, wal (λ y, wi (wa (wcel (cv y) (B2 x3 y)) (wcel (cv x3) (A2 x3 y))) (ph x3 y)))) (wal (λ y, wal (λ x3, wi (wa (wcel (cv y) (B2 x3 y)) (wcel (cv x3) (A2 x3 y))) (ph x3 y))))
    (@«2albii» (λ x3 y, wi (wa (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y))) (ph x3 y)) (λ x3 y, wi (wa (wcel (cv y) (B2 x3 y)) (wcel (cv x3) (A2 x3 y))) (ph x3 y))
      (λ x3 y, @ancomst (wcel (cv x3) (A2 x3 y)) (wcel (cv y) (B2 x3 y)) (ph x3 y)))
    (@alcom (λ x3 y, wi (wa (wcel (cv y) (B2 x3 y)) (wcel (cv x3) (A2 x3 y))) (ph x3 y))))
  (@r2alf (λ x3 y, ph x3 y) (λ x3 y, A2 x3 y) (λ x3 y, B2 x3 y)
    (λ x3, ralcomf_1 x3) y)
  (@r2alf (λ y x3, ph x3 y) (λ y x3, B2 x3 y) (λ y x3, A2 x3 y)
    (λ y, ralcomf_2 y) x3)


/-- A commutation law for restricted universal quantifiers that swaps the domains of the
restriction. (Contributed by NM, 22-Feb-2004.) -/
theorem ralcom3 {ph : setvar → wff} {A2 B2 : setvar → «class»} :
  ⊦ wb (wral (λ x3, wi (wcel (cv x3) (B2 x3)) (ph x3)) (λ x3, A2 x3)) (wral (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, B2 x3)) :=
@impbii (wral (λ x3, wi (wcel (cv x3) (B2 x3)) (ph x3)) (λ x3, A2 x3)) (wral (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, B2 x3))
  (@ralimi2 (λ x3, wi (wcel (cv x3) (B2 x3)) (ph x3)) (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, A2 x3) (λ x3, B2 x3)
    (λ x3, @pm2_04 (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3)) (ph x3)))
  (@ralimi2 (λ x3, wi (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wi (wcel (cv x3) (B2 x3)) (ph x3)) (λ x3, B2 x3) (λ x3, A2 x3)
    (λ x3, @pm2_04 (wcel (cv x3) (B2 x3)) (wcel (cv x3) (A2 x3)) (ph x3)))


/-- Lemma factoring out common proof steps of ~ reeanv and ~ reean . (Contributed by Wolf Lammen,
20-Aug-2023.) -/
theorem reeanlem {ph ps : setvar → setvar → wff} {A2 B2 : setvar → «class»}
  (reeanlem_1 : ∀ x3 y, ⊦ wb (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3)) (ph x3 y)) (wa (wcel (cv y) (B2 y)) (ps x3 y))))) (wa (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3 y))) (wex (λ y, wa (wcel (cv y) (B2 y)) (ps x3 y)))))
  (x3 y : setvar) : ⊦ wb (wrex (λ x3, wrex (λ y, wa (ph x3 y) (ps x3 y)) (λ y, B2 y)) (λ x3, A2 x3)) (wa (wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (wrex (λ y, ps x3 y) (λ y, B2 y))) :=
@«3bitr4i» (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y))) (wa (ph x3 y) (ps x3 y))))) (wa (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3 y))) (wex (λ y, wa (wcel (cv y) (B2 y)) (ps x3 y)))) (wrex (λ x3, wrex (λ y, wa (ph x3 y) (ps x3 y)) (λ y, B2 y)) (λ x3, A2 x3)) (wa (wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (wrex (λ y, ps x3 y) (λ y, B2 y)))
  (@bitri (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y))) (wa (ph x3 y) (ps x3 y))))) (wex (λ x3, wex (λ y, wa (wa (wcel (cv x3) (A2 x3)) (ph x3 y)) (wa (wcel (cv y) (B2 y)) (ps x3 y))))) (wa (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3 y))) (wex (λ y, wa (wcel (cv y) (B2 y)) (ps x3 y))))
    (@«2exbii» (λ x3 y, wa (wa (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y))) (wa (ph x3 y) (ps x3 y))) (λ x3 y, wa (wa (wcel (cv x3) (A2 x3)) (ph x3 y)) (wa (wcel (cv y) (B2 y)) (ps x3 y)))
      (λ x3 y, @an4 (wcel (cv x3) (A2 x3)) (wcel (cv y) (B2 y)) (ph x3 y) (ps x3 y)))
    (reeanlem_1 x3 y))
  (@r2ex (λ x3 y, wa (ph x3 y) (ps x3 y)) (λ x3, A2 x3) (λ x3 y, B2 y))
  (@anbi12i (wrex (λ x3, ph x3 y) (λ x3, A2 x3)) (wex (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3 y))) (wrex (λ y, ps x3 y) (λ y, B2 y)) (wex (λ y, wa (wcel (cv y) (B2 y)) (ps x3 y)))
    (@df_rex (λ x3, ph x3 y) (λ x3, A2 x3))
    (@df_rex (λ y, ps x3 y) (λ y, B2 y)))


/-- Rearrange restricted existential quantifiers. (Contributed by NM, 9-May-1999.) -/
theorem reeanv {ph ps : setvar → wff} {A2 B2 : setvar → «class»} :
  ⊦ wb (wrex (λ x3, wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (λ x3, A2 x3)) (wa (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ y, ps y) (λ y, B2 y))) :=
setvar.forget $ λ x3 : setvar,
  setvar.forget $ λ y : setvar,
  show ⊦ wb (wrex (λ x3, wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (λ x3, A2 x3)) (wa (wrex (λ x3, ph x3) (λ x3, A2 x3)) (wrex (λ y, ps y) (λ y, B2 y))), from
  @reeanlem (λ x3 y, ph x3) (λ x3 y, ps y) (λ x3, A2 x3) (λ y, B2 y)
    (λ x3 y, @exdistrv (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) (λ y, wa (wcel (cv y) (B2 y)) (ps y))) x3 y


/-- Rearrange three restricted existential quantifiers. (Contributed by Jeff Madsen, 11-Jun-2010.)
-/
theorem «3reeanv» {ph ps ch : setvar → wff} {A2 : setvar → setvar → «class»} {B2 C : setvar → «class»}
  (z : setvar) : ⊦ wb (wrex (λ x3, wrex (λ y, wrex (λ z, w3a (ph x3) (ps y) (ch z)) (λ z, C z)) (λ y, B2 y)) (λ x3, A2 x3 z)) (w3a (wrex (λ x3, ph x3) (λ x3, A2 x3 z)) (wrex (λ y, ps y) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z))) :=
@«3bitr4i» (wrex (λ x3, wa (wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z))) (λ x3, A2 x3 z)) (wa (wa (wrex (λ x3, ph x3) (λ x3, A2 x3 z)) (wrex (λ y, ps y) (λ y, B2 y))) (wrex (λ z, ch z) (λ z, C z))) (wrex (λ x3, wrex (λ y, wrex (λ z, w3a (ph x3) (ps y) (ch z)) (λ z, C z)) (λ y, B2 y)) (λ x3, A2 x3 z)) (w3a (wrex (λ x3, ph x3) (λ x3, A2 x3 z)) (wrex (λ y, ps y) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z)))
  (@bitri (wrex (λ x3, wa (wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z))) (λ x3, A2 x3 z)) (wa (wrex (λ x3, wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (λ x3, A2 x3 z)) (wrex (λ z, ch z) (λ z, C z))) (wa (wa (wrex (λ x3, ph x3) (λ x3, A2 x3 z)) (wrex (λ y, ps y) (λ y, B2 y))) (wrex (λ z, ch z) (λ z, C z)))
    (@r19_41v (λ x3, wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z)) (λ x3, A2 x3 z))
    (@anbi1i (wrex (λ x3, wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (λ x3, A2 x3 z)) (wa (wrex (λ x3, ph x3) (λ x3, A2 x3 z)) (wrex (λ y, ps y) (λ y, B2 y))) (wrex (λ z, ch z) (λ z, C z))
      (@reeanv (λ x3, ph x3) (λ y, ps y) (λ x3, A2 x3 z) (λ y, B2 y))))
  (@rexbii (λ x3, wrex (λ y, wrex (λ z, w3a (ph x3) (ps y) (ch z)) (λ z, C z)) (λ y, B2 y)) (λ x3, wa (wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z))) (λ x3, A2 x3 z)
    (λ x3, @bitri (wrex (λ y, wrex (λ z, w3a (ph x3) (ps y) (ch z)) (λ z, C z)) (λ y, B2 y)) (wrex (λ y, wrex (λ z, wa (wa (ph x3) (ps y)) (ch z)) (λ z, C z)) (λ y, B2 y)) (wa (wrex (λ y, wa (ph x3) (ps y)) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z)))
      (setvar.forget $ λ z : setvar,
        show ⊦ wb (wrex (λ y, wrex (λ z, w3a (ph x3) (ps y) (ch z)) (λ z, C z)) (λ y, B2 y)) (wrex (λ y, wrex (λ z, wa (wa (ph x3) (ps y)) (ch z)) (λ z, C z)) (λ y, B2 y)), from
        @«2rexbii» (λ y z, w3a (ph x3) (ps y) (ch z)) (λ y z, wa (wa (ph x3) (ps y)) (ch z)) (λ y z, B2 y) (λ y z, C z)
          (λ y z, @df_3an (ph x3) (ps y) (ch z)) z)
      (@reeanv (λ y, wa (ph x3) (ps y)) (λ z, ch z) (λ y, B2 y) (λ z, C z))))
  (@df_3an (wrex (λ x3, ph x3) (λ x3, A2 x3 z)) (wrex (λ y, ps y) (λ y, B2 y)) (wrex (λ z, ch z) (λ z, C z)))


/-- The setvar ` x ` is not free in ` E! x e. A ph ` . (Contributed by NM, 19-Mar-1997.) -/
theorem nfreu1 {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wnf (λ x3, wreu (λ x3, ph x3) (λ x3, A2 x3)) :=
@nfxfr (λ x3, wreu (λ x3, ph x3) (λ x3, A2 x3)) (λ x3, weu (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))
  (λ x3, @df_reu (λ x3, ph x3) (λ x3, A2 x3))
  (@nfeu1 (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))


/-- An "identity" law of concretion for restricted abstraction. Special case of Definition 2.1 of
[Quine] p. 16. (Contributed by NM, 9-Oct-2003.) -/
theorem rabid {ph : setvar → wff} {A2 : setvar → «class»}
  (x3 : setvar) : ⊦ wb (wcel (cv x3) (crab (λ x3, ph x3) (λ x3, A2 x3))) (wa (wcel (cv x3) (A2 x3)) (ph x3)) :=
@abeq2i (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, crab (λ x3, ph x3) (λ x3, A2 x3))
  (λ x3, @df_rab (λ x3, ph x3) (λ x3, A2 x3)) x3


/-- An "identity" law for restricted class abstraction. (Contributed by NM, 9-Oct-2003.) (Proof
shortened by Andrew Salmon, 30-May-2011.) -/
theorem rabid2 {ph : setvar → wff} {A2 : «class»} :
  ⊦ wb (wceq A2 (crab (λ x3, ph x3) (λ x3, A2))) (wral (λ x3, ph x3) (λ x3, A2)) :=
@«3bitr4i» (wceq A2 (cab (λ x3, wa (wcel (cv x3) A2) (ph x3)))) (wal (λ x3, wi (wcel (cv x3) A2) (ph x3))) (wceq A2 (crab (λ x3, ph x3) (λ x3, A2))) (wral (λ x3, ph x3) (λ x3, A2))
  (@bitr4i (wceq A2 (cab (λ x3, wa (wcel (cv x3) A2) (ph x3)))) (wal (λ x3, wb (wcel (cv x3) A2) (wa (wcel (cv x3) A2) (ph x3)))) (wal (λ x3, wi (wcel (cv x3) A2) (ph x3)))
    (@abeq2 (λ x3, wa (wcel (cv x3) A2) (ph x3)) A2)
    (@albii (λ x3, wi (wcel (cv x3) A2) (ph x3)) (λ x3, wb (wcel (cv x3) A2) (wa (wcel (cv x3) A2) (ph x3)))
      (λ x3, @pm4_71 (wcel (cv x3) A2) (ph x3))))
  (@eqeq2i (crab (λ x3, ph x3) (λ x3, A2)) (cab (λ x3, wa (wcel (cv x3) A2) (ph x3))) A2
    (@df_rab (λ x3, ph x3) (λ x3, A2)))
  (@df_ral (λ x3, ph x3) (λ x3, A2))


/-- The abstraction variable in a restricted class abstraction isn't free. (Contributed by NM,
19-Mar-1997.) -/
theorem nfrab1 {ph : setvar → wff} {A2 : setvar → «class»} :
  ⊦ wnfc (λ x3, crab (λ x3, ph x3) (λ x3, A2 x3)) :=
@nfcxfr (λ x3, crab (λ x3, ph x3) (λ x3, A2 x3)) (λ x3, cab (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))
  (λ x3, @df_rab (λ x3, ph x3) (λ x3, A2 x3))
  (@nfab1 (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)))


/-- A variable not free in a wff remains so in a restricted class abstraction. Version of ~ nfrab
with a disjoint variable condition, which does not require ~ ax-13 . (Contributed by NM,
13-Oct-2003.) (Revised by Gino Giotto, 10-Jan-2024.) -/
theorem nfrabw {ph : setvar → setvar → wff} {A2 : setvar → setvar → «class»}
  (nfrabw_1 : ∀ y, ⊦ wnf (λ x3, ph x3 y))
  (nfrabw_2 : ∀ y, ⊦ wnfc (λ x3, A2 x3 y)) :
  ⊦ wnfc (λ x3, crab (λ y, ph x3 y) (λ y, A2 x3 y)) :=
@nfcxfr (λ x3, crab (λ y, ph x3 y) (λ y, A2 x3 y)) (λ x3, cab (λ y, wa (wcel (cv y) (A2 x3 y)) (ph x3 y)))
  (λ x3, @df_rab (λ y, ph x3 y) (λ y, A2 x3 y))
  (@mptru (wnfc (λ x3, cab (λ y, wa (wcel (cv y) (A2 x3 y)) (ph x3 y))))
    (setvar.forget $ λ x3 : setvar,
      setvar.forget $ λ y : setvar,
      show ⊦ wi wtru (wnfc (λ x3, cab (λ y, wa (wcel (cv y) (A2 x3 y)) (ph x3 y)))), from
      @nfabdw (λ x3 y, wtru) (λ x3 y, wa (wcel (cv y) (A2 x3 y)) (ph x3 y))
        (λ x3, nftru)
        (λ x3 y, setvar.forget $ λ x3 : setvar,
          show ⊦ wi wtru (wnf (λ x3, wa (wcel (cv y) (A2 x3 y)) (ph x3 y))), from
          @nfand (λ x3, wtru) (λ x3, wcel (cv y) (A2 x3 y)) (λ x3, ph x3 y)
            (λ x3, @a1i (wnf (λ x3, wcel (cv y) (A2 x3 y))) wtru
              (@nfcri (λ x3 y, A2 x3 y)
                (λ y, nfrabw_2 y) y))
            (λ x3, @a1i (wnf (λ x3, ph x3 y)) wtru
              (nfrabw_1 y)) x3) x3 y))


/-- Formula-building rule for restricted existential quantifier (deduction form). (Contributed by
NM, 13-Nov-2004.) Reduce axiom usage. (Revised by Wolf Lammen, 14-Jan-2023.) -/
theorem reubidva {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (reubidva_1 : ∀ x3, ⊦ wi (wa ph (wcel (cv x3) (A2 x3))) (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wreu (λ x3, ps x3) (λ x3, A2 x3)) (wreu (λ x3, ch x3) (λ x3, A2 x3))) :=
@«3bitr4g» ph (weu (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))) (weu (λ x3, wa (wcel (cv x3) (A2 x3)) (ch x3))) (wreu (λ x3, ps x3) (λ x3, A2 x3)) (wreu (λ x3, ch x3) (λ x3, A2 x3))
  (@eubidv ph (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3)) (λ x3, wa (wcel (cv x3) (A2 x3)) (ch x3))
    (λ x3, @pm5_32da ph (wcel (cv x3) (A2 x3)) (ps x3) (ch x3)
      (reubidva_1 x3)))
  (@df_reu (λ x3, ps x3) (λ x3, A2 x3))
  (@df_reu (λ x3, ch x3) (λ x3, A2 x3))


/-- Formula-building rule for restricted existential quantifier (deduction form). (Contributed by
NM, 17-Oct-1996.) -/
theorem reubidv {ph : wff} {ps ch : setvar → wff} {A2 : setvar → «class»}
  (reubidv_1 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wreu (λ x3, ps x3) (λ x3, A2 x3)) (wreu (λ x3, ch x3) (λ x3, A2 x3))) :=
@reubidva ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3)
  (λ x3, @adantr ph (wb (ps x3) (ch x3)) (wcel (cv x3) (A2 x3))
    (reubidv_1 x3))


/-- Formula-building rule for restricted existential quantifier (inference form). (Contributed by
NM, 14-Nov-2004.) -/
theorem reubiia {ph ps : setvar → wff} {A2 : setvar → «class»}
  (reubiia_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wb (ph x3) (ps x3))) :
  ⊦ wb (wreu (λ x3, ph x3) (λ x3, A2 x3)) (wreu (λ x3, ps x3) (λ x3, A2 x3)) :=
@«3bitr4i» (weu (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (weu (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))) (wreu (λ x3, ph x3) (λ x3, A2 x3)) (wreu (λ x3, ps x3) (λ x3, A2 x3))
  (@eubii (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))
    (λ x3, @pm5_32i (wcel (cv x3) (A2 x3)) (ph x3) (ps x3)
      (reubiia_1 x3)))
  (@df_reu (λ x3, ph x3) (λ x3, A2 x3))
  (@df_reu (λ x3, ps x3) (λ x3, A2 x3))


/-- Formula-building rule for restricted existential quantifier (inference form). (Contributed by
NM, 22-Oct-1999.) -/
theorem reubii {ph ps : setvar → wff} {A2 : setvar → «class»}
  (reubii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wreu (λ x3, ph x3) (λ x3, A2 x3)) (wreu (λ x3, ps x3) (λ x3, A2 x3)) :=
@reubiia (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @a1i (wb (ph x3) (ps x3)) (wcel (cv x3) (A2 x3))
    (reubii_1 x3))


/-- Formula-building rule for restricted existential quantifier (inference form). (Contributed by
NM, 16-Jun-2017.) -/
theorem rmobiia {ph ps : setvar → wff} {A2 : setvar → «class»}
  (rmobiia_1 : ∀ x3, ⊦ wi (wcel (cv x3) (A2 x3)) (wb (ph x3) (ps x3))) :
  ⊦ wb (wrmo (λ x3, ph x3) (λ x3, A2 x3)) (wrmo (λ x3, ps x3) (λ x3, A2 x3)) :=
@«3bitr4i» (wmo (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3))) (wmo (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))) (wrmo (λ x3, ph x3) (λ x3, A2 x3)) (wrmo (λ x3, ps x3) (λ x3, A2 x3))
  (@mobii (λ x3, wa (wcel (cv x3) (A2 x3)) (ph x3)) (λ x3, wa (wcel (cv x3) (A2 x3)) (ps x3))
    (λ x3, @pm5_32i (wcel (cv x3) (A2 x3)) (ph x3) (ps x3)
      (rmobiia_1 x3)))
  (@df_rmo (λ x3, ph x3) (λ x3, A2 x3))
  (@df_rmo (λ x3, ps x3) (λ x3, A2 x3))


/-- Formula-building rule for restricted existential quantifier (inference form). (Contributed by
NM, 16-Jun-2017.) -/
theorem rmobii {ph ps : setvar → wff} {A2 : setvar → «class»}
  (rmobii_1 : ∀ x3, ⊦ wb (ph x3) (ps x3)) :
  ⊦ wb (wrmo (λ x3, ph x3) (λ x3, A2 x3)) (wrmo (λ x3, ps x3) (λ x3, A2 x3)) :=
@rmobiia (λ x3, ph x3) (λ x3, ps x3) (λ x3, A2 x3)
  (λ x3, @a1i (wb (ph x3) (ps x3)) (wcel (cv x3) (A2 x3))
    (rmobii_1 x3))


/-- Equality deduction for restricted universal quantifier. (Contributed by NM, 6-Nov-2007.) Remove
usage of ~ ax-10 , ~ ax-11 , and ~ ax-12 and reduce distinct variable conditions. (Revised by Steven
Nguyen, 30-Apr-2023.) -/
theorem raleqbidv {ph : wff} {ps ch : setvar → wff} {A2 B2 : setvar → «class»}
  (raleqbidv_1 : ∀ x3, ⊦ wi ph (wceq (A2 x3) (B2 x3)))
  (raleqbidv_2 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wral (λ x3, ps x3) (λ x3, A2 x3)) (wral (λ x3, ch x3) (λ x3, B2 x3))) :=
@ralbidv2 ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3) (λ x3, B2 x3)
  (λ x3, @imbi12d ph (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3)) (ps x3) (ch x3)
    (@eleq2d ph (A2 x3) (B2 x3) (cv x3)
      (raleqbidv_1 x3))
    (raleqbidv_2 x3))


/-- Equality deduction for restricted universal quantifier. (Contributed by NM, 6-Nov-2007.) Remove
usage of ~ ax-10 , ~ ax-11 , and ~ ax-12 and reduce distinct variable conditions. (Revised by Steven
Nguyen, 30-Apr-2023.) -/
theorem rexeqbidv {ph : wff} {ps ch : setvar → wff} {A2 B2 : setvar → «class»}
  (raleqbidv_1 : ∀ x3, ⊦ wi ph (wceq (A2 x3) (B2 x3)))
  (raleqbidv_2 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wrex (λ x3, ps x3) (λ x3, A2 x3)) (wrex (λ x3, ch x3) (λ x3, B2 x3))) :=
@rexbidv2 ph (λ x3, ps x3) (λ x3, ch x3) (λ x3, A2 x3) (λ x3, B2 x3)
  (λ x3, @anbi12d ph (wcel (cv x3) (A2 x3)) (wcel (cv x3) (B2 x3)) (ps x3) (ch x3)
    (@eleq2d ph (A2 x3) (B2 x3) (cv x3)
      (raleqbidv_1 x3))
    (raleqbidv_2 x3))


/-- Version of ~ raleqbidv with additional disjoint variable conditions, not requiring ~ ax-8 nor ~
df-clel . (Contributed by BJ, 22-Sep-2024.) -/
theorem raleqbidvv {ph : wff} {ps ch : setvar → wff} {A2 B2 : «class»}
  (raleqbidvv_1 : ⊦ wi ph (wceq A2 B2))
  (raleqbidvv_2 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wral (λ x3, ps x3) (λ x3, A2)) (wral (λ x3, ch x3) (λ x3, B2))) :=
@«3bitr4g» ph (wal (λ x3, wi (wcel (cv x3) A2) (ps x3))) (wal (λ x3, wi (wcel (cv x3) B2) (ch x3))) (wral (λ x3, ps x3) (λ x3, A2)) (wral (λ x3, ch x3) (λ x3, B2))
  (@syl ph (wal (λ x3, wb (wi (wcel (cv x3) A2) (ps x3)) (wi (wcel (cv x3) B2) (ch x3)))) (wb (wal (λ x3, wi (wcel (cv x3) A2) (ps x3))) (wal (λ x3, wi (wcel (cv x3) B2) (ch x3))))
    (setvar.forget $ λ x3 : setvar,
      show ⊦ wi ph (wal (λ x3, wb (wi (wcel (cv x3) A2) (ps x3)) (wi (wcel (cv x3) B2) (ch x3)))), from
      @sylg (λ x3, ph) (λ x3, wa (wb (ps x3) (ch x3)) (wb (wcel (cv x3) A2) (wcel (cv x3) B2))) (λ x3, wb (wi (wcel (cv x3) A2) (ps x3)) (wi (wcel (cv x3) B2) (ch x3)))
        (λ x3, @sylanbrc ph (wal (λ x3, wb (ps x3) (ch x3))) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))) (wal (λ x3, wa (wb (ps x3) (ch x3)) (wb (wcel (cv x3) A2) (wcel (cv x3) B2))))
          (@alrimiv ph (λ x3, wb (ps x3) (ch x3))
            (λ x3, raleqbidvv_2 x3))
          (@sylib ph (wceq A2 B2) (wal (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2)))
            raleqbidvv_1
            (@dfcleq A2 B2))
          (@«19_26» (λ x3, wb (ps x3) (ch x3)) (λ x3, wb (wcel (cv x3) A2) (wcel (cv x3) B2))))
        (λ x3, @impcom (wb (wcel (cv x3) A2) (wcel (cv x3) B2)) (wb (ps x3) (ch x3)) (wb (wi (wcel (cv x3) A2) (ps x3)) (wi (wcel (cv x3) B2) (ch x3)))
          (@imbi12 (wcel (cv x3) A2) (wcel (cv x3) B2) (ps x3) (ch x3))) x3)
    (@albi (λ x3, wi (wcel (cv x3) A2) (ps x3)) (λ x3, wi (wcel (cv x3) B2) (ch x3))))
  (@df_ral (λ x3, ps x3) (λ x3, A2))
  (@df_ral (λ x3, ch x3) (λ x3, B2))


/-- Version of ~ rexeqbidv with additional disjoint variable conditions, not requiring ~ ax-8 nor ~
df-clel . (Contributed by Wolf Lammen, 25-Sep-2024.) -/
theorem rexeqbidvv {ph : wff} {ps ch : setvar → wff} {A2 B2 : «class»}
  (raleqbidvv_1 : ⊦ wi ph (wceq A2 B2))
  (raleqbidvv_2 : ∀ x3, ⊦ wi ph (wb (ps x3) (ch x3))) :
  ⊦ wi ph (wb (wrex (λ x3, ps x3) (λ x3, A2)) (wrex (λ x3, ch x3) (λ x3, B2))) :=
@con4bid ph (wrex (λ x3, ps x3) (λ x3, A2)) (wrex (λ x3, ch x3) (λ x3, B2))
  (@«3bitr3g» ph (wral (λ x3, wn (ps x3)) (λ x3, A2)) (wral (λ x3, wn (ch x3)) (λ x3, B2)) (wn (wrex (λ x3, ps x3) (λ x3, A2))) (wn (wrex (λ x3, ch x3) (λ x3, B2)))
    (@raleqbidvv ph (λ x3, wn (ps x3)) (λ x3, wn (ch x3)) A2 B2
      raleqbidvv_1
      (λ x3, @notbid ph (ps x3) (ch x3)
        (raleqbidvv_2 x3)))
    (@ralnex (λ x3, ps x3) (λ x3, A2))
    (@ralnex (λ x3, ch x3) (λ x3, B2)))


/-- Equality deduction for restricted universal quantifier. (Contributed by NM, 16-Nov-1995.) (Proof
shortened by Steven Nguyen, 5-May-2023.) -/
theorem raleqbi1dv {ph ps : setvar → wff} {A2 B2 : «class»}
  (raleqbi1dv_1 : ∀ x3, ⊦ wi (wceq A2 B2) (wb (ph x3) (ps x3))) :
  ⊦ wi (wceq A2 B2) (wb (wral (λ x3, ph x3) (λ x3, A2)) (wral (λ x3, ps x3) (λ x3, B2))) :=
@raleqbidvv (wceq A2 B2) (λ x3, ph x3) (λ x3, ps x3) A2 B2
  (@id (wceq A2 B2))
  (λ x3, raleqbi1dv_1 x3)


/-- Equality deduction for restricted existential quantifier. (Contributed by NM, 18-Mar-1997.)
(Proof shortened by Steven Nguyen, 5-May-2023.) -/
theorem rexeqbi1dv {ph ps : setvar → wff} {A2 B2 : «class»}
  (raleqbi1dv_1 : ∀ x3, ⊦ wi (wceq A2 B2) (wb (ph x3) (ps x3))) :
  ⊦ wi (wceq A2 B2) (wb (wrex (λ x3, ph x3) (λ x3, A2)) (wrex (λ x3, ps x3) (λ x3, B2))) :=
@rexeqbidvv (wceq A2 B2) (λ x3, ph x3) (λ x3, ps x3) A2 B2
  (@id (wceq A2 B2))
  (λ x3, raleqbi1dv_1 x3)


/-- Equality theorem for restricted universal quantifier. (Contributed by NM, 16-Nov-1995.) Remove
usage of ~ ax-10 , ~ ax-11 , and ~ ax-12 . (Revised by Steven Nguyen, 30-Apr-2023.) -/
theorem raleq {ph : setvar → wff} {A2 B2 : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wral (λ x3, ph x3) (λ x3, A2)) (wral (λ x3, ph x3) (λ x3, B2))) :=
@raleqbi1dv (λ x3, ph x3) (λ x3, ph x3) A2 B2
  (λ x3, @biidd (wceq A2 B2) (ph x3))


/-- Equality theorem for restricted existential quantifier. (Contributed by NM, 29-Oct-1995.) Remove
usage of ~ ax-10 , ~ ax-11 , and ~ ax-12 . (Revised by Steven Nguyen, 30-Apr-2023.) -/
theorem rexeq {ph : setvar → wff} {A2 B2 : «class»} :
  ⊦ wi (wceq A2 B2) (wb (wrex (λ x3, ph x3) (λ x3, A2)) (wrex (λ x3, ph x3) (λ x3, B2))) :=
@rexeqbi1dv (λ x3, ph x3) (λ x3, ph x3) A2 B2
  (λ x3, @biidd (wceq A2 B2) (ph x3))


/-- Equality inference for restricted universal quantifier. (Contributed by Paul Chapman,
22-Jun-2011.) -/
theorem raleqi {ph : setvar → wff} {A2 B2 : «class»}
  (raleq1i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wral (λ x3, ph x3) (λ x3, A2)) (wral (λ x3, ph x3) (λ x3, B2)) :=
@ax_mp (wceq A2 B2) (wb (wral (λ x3, ph x3) (λ x3, A2)) (wral (λ x3, ph x3) (λ x3, B2)))
  raleq1i_1
  (@raleq (λ x3, ph x3) A2 B2)


/-- Equality inference for restricted existential quantifier. (Contributed by Mario Carneiro,
23-Apr-2015.) -/
theorem rexeqi {ph : setvar → wff} {A2 B2 : «class»}
  (raleq1i_1 : ⊦ wceq A2 B2) :
  ⊦ wb (wrex (λ x3, ph x3) (λ x3, A2)) (wrex (λ x3, ph x3) (λ x3, B2)) :=
@ax_mp (wceq A2 B2) (wb (wrex (λ x3, ph x3) (λ x3, A2)) (wrex (λ x3, ph x3) (λ x3, B2)))
  raleq1i_1
  (@rexeq (λ x3, ph x3) A2 B2)


/-- Equality deduction for restricted universal quantifier. (Contributed by NM, 13-Nov-2005.) -/
theorem raleqdv {ph ps : setvar → wff} {A2 B2 : «class»}
  (raleq1d_1 : ∀ x3, ⊦ wi (ph x3) (wceq A2 B2))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wral (λ x3, ps x3) (λ x3, A2)) (wral (λ x3, ps x3) (λ x3, B2))) :=
@syl (ph x3) (wceq A2 B2) (wb (wral (λ x3, ps x3) (λ x3, A2)) (wral (λ x3, ps x3) (λ x3, B2)))
  (raleq1d_1 x3)
  (@raleq (λ x3, ps x3) A2 B2)


/-- Equality deduction for restricted existential quantifier. (Contributed by NM, 14-Jan-2007.) -/
theorem rexeqdv {ph ps : setvar → wff} {A2 B2 : «class»}
  (raleq1d_1 : ∀ x3, ⊦ wi (ph x3) (wceq A2 B2))
  (x3 : setvar) : ⊦ wi (ph x3) (wb (wrex (λ x3, ps x3) (λ x3, A2)) (wrex (λ x3, ps x3) (λ x3, B2))) :=
@syl (ph x3) (wceq A2 B2) (wb (wrex (λ x3, ps x3) (λ x3, A2)) (wrex (λ x3, ps x3) (λ x3, B2)))
  (raleq1d_1 x3)
  (@rexeq (λ x3, ps x3) A2 B2)

end mm

